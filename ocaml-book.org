#+TITLE: OCaml 杂记
#+OPTIONS: toc:t num:nil  timestamp:nil 

#+HTML_HEAD:  <link rel="stylesheet" type="text/css" href="./myorg.css"/>



* opam包管理器



~opam install XX~

#+begin_src sh
opam install -y utop odoc ounit2 qcheck bisect_ppx menhir ocaml-lsp-server ocamlformat ocamlformat-rpc
#+end_src

* utop交互式解释器

每次启动utop都会自动加载 ~.ocamlinit~ 文件，它会自动执行脚本，
使得不用每次都手动加载库

#+begin_src ocaml
  #use "topfind";;
  #thread;;
  #require "core.top";;
  
#+end_src

** Exit utop

#+begin_src ocaml
  #quit;; 
#+end_src

#+begin_src ocaml
exit 0;;
#+end_src



* 配置Emacs支持ocaml | Configure EMACS supports Ocaml

#+begin_src ocaml
opam install tuareg ocp-indent merlin
opam install user-setup
opam user-setup install
#+end_src


* 编译ocamlc

#+begin_src sh
ocamlc -o test.byte test.ml 
#+end_src
这和gcc类似，不同的是它还会产生中间文件： ~test.cmi test.cmo~


** main()函数？

ocaml中没有专门的main函数，文件（指的是dune中name命令指定的那个）中最后一个函数定义将作为整个程序的入口。

** 构建系统Dune

+ 用dune创建项目根目录 Create a project root directory with dune
  #+begin_src sh
    dune init project dirname
  #+end_src

+ create a file named dune in the project root directory
  
  #+begin_src elisp
    (executable
      (name XX) ;;XX为main函数所在文件的名字
      ;;(libraries yyy) ;; erung: ounit2
      )
  #+end_src

+  Generate executable file

  #+begin_src sh
    dune build XX.exe 
  #+end_src

+  run project
  #+begin_src sh
    # Manually
    ./_build/default/XX.exe

    # automatic
    dune exec ./XX.exe
  #+end_src

+ Clean up the _build directory
  #+begin_src sh
    dune clean # remove the _build directory 
  #+end_src




* ocaml的显著差别


** 递归函数要用 ~rec~ 标记

#+begin_src ocaml
  let rec append lst1 lst2 =
    match lst1 with
    | [] -> lst2
    | h :: t -> h :: (append t lst2 )
  ;;
#+end_src


** 严格区分整数和浮点数的运算：

int： ~0 + - * /  abs~ 

float:  ~0. +. -. *. /. ~


** 连接字符串: 用 ~^~

#+begin_src ocaml
"hello" ^ "world" 
#+end_src


* let 不是表达式


#+begin_src ocaml

utop # let x = 3;;
val x : int = 3

utop # (fun x y -> x * y);;
- : int -> int -> int = <fun>

utop # (fun x y -> x * y) 4 5;;
- : int = 20

utop # let multf x y = x *. y;;
val multf : float -> float -> float = <fun>

utop # multf 1. 4.;;
- : float = 4.
#+end_src

* let ... in ...表达式
在utop环境下，所有的let定义都会被转化成层层嵌套的let..in..表达式。
因此在表面上好像是支持了改变变量的值。


There must be parentheses here:
#+begin_src ocaml
utop # let a = 19 in (fun x -> x + a)  19;;
- : int = 38
#+end_src


本质上在ocaml中不存在多参函数，所谓的多参函数只是语法糖：

#+begin_src ocaml
utop # let multargs = fun x -> (fun y -> ( fun z -> x+y+z )) ;;
val multargs : int -> int -> int -> int = <fun>

utop # multargs 1 2 3 ;;
- : int = 6

utop # let same_as_multargs x y z = x+y+z ;;
val same_as_multargs : int -> int -> int -> int = <fun>

utop # same_as_multargs 1 2 3;;
- : int = 6
#+end_src



范型：带撇的类型名 'a  'b 
#+begin_src ocaml
  utop # let foo = fun (n : int ) (x : 'a) (y : 'a) ->  if n > 0 then x else y ;;
  val foo : int -> 'a -> 'a -> 'a = <fun>

  utop # foo -1 "hello" "fuck" ;;
  Error: This expression has type int -> 'a -> 'a -> 'a
  but an expression was expected of type int

  utop # foo 3 "hello" "fuck" ;;
  - : string = "hello"

  utop # foo (-1)  "hello" "fuck" ;;
  - : string = "fuck"
#+end_src


* 运算符

** 用括号定义标点符号 


** 运算符@@ 分隔开函数和参数

主要是为了避免空格分割导致参数的识别不正常：
#+begin_src ocaml
utop[3]> succ 3;;
- : int = 4
utop[4]> succ 1 * 4 ;;
- : int = 8
utop[5]> succ (1 * 4) ;;
- : int = 5
utop[6]> succ @@ 1 * 4;;
- : int = 5
#+end_src

** 运算符|> 管道符
#+begin_src ocaml
let (|>) x f = f x  ;;
#+end_src


#+begin_src ocaml
  let foo x : int = x*x +1;;
  val foo : int -> int = <fun>

  utop[1]> foo 3;;
  - : int = 10

  utop[2]> 3 |> foo;;
  - : int = 10

utop[13]> succ (foo (foo 3));;
- : int = 102
utop[14]> 3 |> foo |> foo |> succ ;;
- : int = 102
#+end_src





** 文档

~(**  .. *)~ 即是文档的格式。
用方括号包围起来的将会被导出为等宽字体。

#+begin_src ocaml
(** [args] *)
#+end_src

+ 前置条件
  对参数含义的描述，以及对合法参数的约束，对动态类型的语言可能还要加上对参数类型的描述
+ 后置条件：
  对返回值的约定。对错误情况/异常抛出的约定 


** 打印

print_xxx :返回类型为unit.

唯一一个类型是unit的值是 ~()~
类似于void，通常用于不关心输入参数/返回值时，这时候一般想利用函数的副作用。


在let in中要求我们必须为值进行绑定： x = val
对于返回类型为unit的函数：可以写成

#+begin_src ocaml
let _ = func args in ...
#+end_src

或者

#+begin_src ocaml
let () = func args in ...
#+end_src


#+begin_src ocaml
#
let ()  = print_endline "fuck" in 
let ()  = print_endline "your" in 
print_endline "mother" ;;
#+end_src

#+begin_src ocaml
fuck
your
mother
- : unit = ()
#+end_src

这种写法太繁琐了，可以像C中用逗号表达式分别对前面的表达式求值，但只将最后一个表达式的值返回。
在Ocaml中是用 ~;~ 来分割的：

#+begin_src ocaml
 "hello" ; 233  (* 这会发出警告 it will cause warnings*)
#+end_src

#+begin_src ocaml
- : int = 233 
#+end_src

因此可写成更简单的形式，而不用写成嵌套的 let..in..

#+begin_src ocaml
print_endline "fuck";
print_endline "your";
print_endline "mother"  (* 最后一个表达式后面无分号！ *)
#+end_src


在分号表达式中，若前面被忽略值的表达式的类型不是unit，则会发出警告。
通过ignore函数可以消除警告。

(ignore "hello") ; 233


#+begin_src ocaml
let ignore x = ()  
#+end_src

可见，分号表达式的主要作用是串联前面几个产生副作用的表达式，并在最后一个表达式中返回值。

*** 格式化输出

#+begin_src ocaml
utop # Printf.printf "%s %F\n %!" "hello" 3.14 
#+end_src

#+begin_src ocaml
hello 3.14
 - : unit = ()
#+end_src

~%!~ 用来刷写缓冲区，类似于std::endl

~%F~ 浮点数

~%i~ 整数


*** 格式化字符串

Printf.sprintf 会产生一个string







* list
ocaml 中的list是同类型元素构成的单链表： ~'a list~ 。
in OCaml, the list is first class status

ocaml 中的list是第一类的，这意味着有专门的语法支持list.
每个list节点是一个pair.  ~[]~ 表示空list.

** 创建list

有两种方式： 

+ 通过 ~::~ 链接元素
  
  必须在最后链接上一个空节点 ~[]~ 
  #+begin_src ocaml
    1::2::3::[]
    ;;
  #+end_src

+ 通过方括号和分号
  
  这种方式可以看作是上面那种方式的语法糖，可以省略链接空列表。
  #+begin_src ocaml
    [1;2;3]
    ;;
  #+end_src


** 用 ~@~ 连接两个list

#+begin_src ocaml
  let a = 1 :: 3 ::[] ;;
  let b = 2 :: 4 ::[] ;;

  a @ b ;;
  
  a @ [233] ;;
#+end_src














** 通过模式匹配 访问元素
#+begin_src ocaml
  match XX with
  | pattern1 -> do something
  | pattern2 -> do something
  | _ ->  ...
#+end_src

所谓模式就是数据的形式（样子），比如list可以是空的，也可以是不空的。
#+begin_src ocaml
  match lst with
  | [] -> 0
  | head :: tail -> head 
#+end_src
空list的形状就是 ~[]~ ，非空的列表意味着至少有一个有效元素： ~e :: []~ 
因此，其形状是 ~head::tail~ 。

有两种特殊的模式： ~_~ 和 ~x~ (x是随便一个符号名）
它们都能和任意的数据匹配上，不同之处在于匹配上的数据不会绑定到 ~_~ 上，但是会绑定到 ~x~ 上。
也就是说，在 ~->~ 右侧能否引用匹配上的值。
#+begin_src ocaml
  let rec length lst =
    match lst with
    | [] -> 0
    | h :: t -> 1 + length t
  ;;
#+end_src

在这个函数中的模式匹配里，第二个模式的 ~h~ 是没有必要的，因为箭头后面根本就没有使用 ~h~,

~List.hd/List.tl~ 分别能取出list的head和tail, 但是当他们作用于空列表 ~[]~ 时，会抛出异常。
而使用模式匹配的方式访问head/tail的好处是会强制你处理list的所有形式。




* OUnit2

首先创建dune项目
#+begin_src bash
dune init project yourproject
#+end_src

在dune中链接ounit2:

#+begin_src dune
  (executable
    (name test_xx)
    (libraries ounit2))
#+end_src


创建测试文件  ~test_xx.ml~ 
引入ounit2和被测试的模块
#+begin_src ocaml
  open Xx
  open OUnit2

#+end_src


为某个函数/功能创建测试套件：
#+begin_src ocaml
  "测试套件名" >::: [  (* 测试项list *) ] 
#+end_src

编写测试用例：
#+begin_src ocaml
  "测试项目名" >:: (fun _ -> assert_xxx arg1 arg2 .. ) ;
#+end_src

运行一个测试套件：

#+begin_src ocaml
let _ = run_test_tt_main 测试套件 
#+end_src



完整例子：

#+begin_src ocaml
open OUnit2
open Sum

let tests = "test suite for sum" >::: [
    "empty" >:: (fun _ -> assert_equal 0 (sum []) ) ;
    "singleton" >:: (fun _ -> assert_equal 1 (sum [1]) ) ;
    "two elements" >:: (fun _ -> assert_equal 3 (sum [1;2]));
  ]

let _ = run_test_tt_main tests 
#+end_src


** 打印测试用例出错时的值

要给 ~assert_xxx~ 的 ~printer~ 参数传入一个输出字符串表达的函数，eg: ~string_of_int~ 
#+begin_src ocaml

  
  let mytsts = "test suite for some module" >::: [
      "case1" >:: (fun _ -> assert_equal 0 (sum []) ~printer:string_of_int ) ;
      ]
#+end_src


会输出：
#+begin_src 
expected: 0 but got: 1
#+end_src

从这个打印结果能看出，assert的首个参数应该是期望的值。









