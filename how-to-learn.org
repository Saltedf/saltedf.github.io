

* manateelazycat 2018 年12 月 11 日 07:10 #16 

学习Emacs有几条曲线:

1 先会用基本的快捷键, 安装各种简单的插件, 抄各种各样的配置, 先
 体验一下Emacs的强大功能.

2 安装复杂插件, 被各种配置搞崩溃了, 越改挂的越厉害, 大部分人卡
 在这个阶段, 因为不会Elisp, 导致东拼西凑的方法对于复杂插件行
 不通

3 你搞不懂Emacs复杂的配置的原因是因为你不懂 Elisp 编程, 学习
 Elisp的方法: 老老实实读Emacs内置的 Elisp reference
 manual, 这么厚的手册怎么学?

- 一页一页的挨着看, 一个API一个API的读, 不要跳过
- 每个API, 都在 ielm 里面实践一下
- 遇到不知道啥鬼用的API, 去Google或EmacsWiki上搜索一下, 看
 看别人怎么用这些API的?

4 如果你花了一个月耐下心读完 Elisp reference manual 以后,
 Emacs 90% 以上的代码你都可以看懂了, 继续折腾复杂插件, 知
 道 require, autoload, set-key, 各种 hook, defadvice 的在不
 同环境下的细微差别, 编程上知道 save-excursion,
 ignore-errors 这些风骚 macro 的用法. 这个阶段可以尝试手动
 来写一写复杂的配置了, 这个阶段你已经是 Emacs 高级用户了.

5 如果还不满足, 可以像我这样造点有趣的轮子: My Emacs
 Plugins , 如果你自己会写Elisp插件, 你会发现Emacs其实是越
 用越简单的, 因为包括正则表达式, 语法高亮, 模式, 异步子进程,
 hook, overlay, advice 这些代码你写熟悉以后, 你会发现所有插
 件的唯一差别就是复杂度和想象力的区别, 不存在想得出来写不出
 来的东西.

6 到了这个阶段, 唯一可以让你学习到更多知识的就是去 IRC
 #emacs 和那些古老的黑客们交流, 或者去扒Github
 Emacser, 我知道很多日本牛逼哄哄的Emacs开发者都把插件放
 到 ftp 上 (比如当年的 color-moccur.el ), 学点 Google 语法就
 可以定向搜索. 这些人都是你会写Emacs插件后, 需要学习和进阶
 的榜样, 这时候你再看Elisp代码, 你的注意力会放在他们Elisp编程
 的一些细节上, 比如代码写的更简洁, 方法用的妙, 架构设计上等
 等, 这是完全不同阶段的探索体验.

7 如果你还不满足, 好好学习C语言, 然后再找个赚钱的工作, 把自己
 和家人照顾好. 业余时间直接用C或Elisp给Emacs底层做贡献, 把
 你的代码贡献固化到Emacs中, 然后你的名字可以像我一样写到
 Emacs AUTHORS 里面去装逼: Emacs AUTHORS

如果你已经看到这里, 而且也做到上面的所有7点, 你自己的能力和精
神境界都会很高了, 再也不会咋咋呼呼的吵着自己的技术要咋样咋
样, 因为你会发现学的越多, 自己就是傻逼一个, 啥都不懂, 这辈子即
使终身学习也学习不完, 哈哈哈哈.

上面就是我学习Emacs十多年的经验分享, 希望可以给同学们一点参
考.



* Youmu

我来分享我是怎么学习 Linux 服务端开发的吧。

大学时候初始入门时学习的是 C，学校采用的教材是 The C programming language, 比较经典。现在的话，可以选择 Rust 来入手，没有那么多坑。

起初学习Linux C 一站式编程 10。虽然这本书是一个培训机构出的，但是它的内容、质量真得非常高。当时看完之后拿它来写了一个局域网聊天 室 5。看完这本书的最大用处是对 Linux 有 一点熟悉了，了解了一下 posix api、syscall，深度不够。

然后继续看 UNPUnix 网络编程, APUELinux 环境高级编程，这里绕不开的是 内核。于是自己写了个玩具内核了解了下内核的机制。这里首先参考的是 James 4 的版本，因为它比较糙，可以 以最快的速度做出来让人有点成就感。随后可以按照 osdev 上的教程系统得走一遍。现 在国内开源的课程也有了，可以直接学习清华的操作系统课程。

coursera 上有门课程 hardware/software interface 不错，对应的教材是 csapp深入理解计算机系统， 可以给系统一个完整的认识。里面编译、链接相关的内容可以阅读「程序员的自我修养」来 完善一下（当然你也可以挑战自己看 linkers and loaders）。

纯粹看系统相关的也可能会有点无聊，可以找点乐子，例如写个黑白棋AI之类的、刷刷 oj。

然后我是花了比较多的时候学习 C++ 去了（无奈当时根本没听说过 Rust，不然也就不 会学习这么有历史包袱的系统级别语言了）。看了些 C++ 相关的书，这个书单也比较长：

c++ primer
effective c++
more effective c++
c++ 模板元编程
c++ 程序设计原理与实践
深入探索 c++ 对象模型
effective modern c++
c++ draft
c++ idioms
linux 服务端编程 (muduo 为例)，这本书算是有一点 c++ 内容，也放在这里好了
然后知道了 reactor, proactor，找了些资料来看，这里必不可少的是 libevent。 使用它、学习它基本是知道了一个网络库该是什么样子。然后可以模仿着 muduo 写个网络 库（也可以直接用它）来写一个监控系统。这就算是一个比较大型的项目了，会涉及到组件 之间的消息交互，然后可以试着使用一些开源中间件来玩，当然玩的同时也要看看源码，例 如 redis 的代码就相对简单，特别是它里面有个比较经典的 ae eventloop 库。

基本上到了这里能够干后端的活了？

休闲读物:
linux 大学教程
unix 痛恨者






- main()                  Main.cpp:6      
 - ModuleA::Init()      ModuleA.cpp :20
  - foo()                  Foo.cpp:10      负责xx任务
  - bar()                  Bar.cpp:15      负责yy任务 
 - ModuleB::Init()      ModuleB.cpp:10

* 理清思路的方法论之一

- 问题中的那些量可以抽象成变量?
- 所求依赖于哪些量?
- 被依赖的量自身又依赖于哪些量?

- 答案直接依赖的量可能是递归解法的削减方向.(递归函数的参数必含这些量)
- 将每个直接依赖关系定义为一个函数.

eg: 若有 X --> Y, 即: X依赖于Y  
则定义函数solve-x : 
(define (solve-x  Y)
(...body...)
(返回 X )
)
