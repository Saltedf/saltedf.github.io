<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-03-29 三 22:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="org-html-themes/src/bigblow_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="org-html-themes/src/bigblow_theme/css/bigblow.css"/>
<link rel="stylesheet" type="text/css" href="org-html-themes/src/bigblow_theme/css/hideshow.css"/>
<script type="text/javascript" src="org-html-themes/src/bigblow_theme/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="org-html-themes/src/bigblow_theme/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="org-html-themes/src/bigblow_theme/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="org-html-themes/src/bigblow_theme/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="org-html-themes/src/bigblow_theme/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="org-html-themes/src/bigblow_theme/js/bigblow.js"></script>
<script type="text/javascript" src="org-html-themes/src/bigblow_theme/js/hideshow.js"></script>
<script type="text/javascript" src="org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
</head>
<body>
<div id="content" class="content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org7af13b1">1. 数据结构</a></li>
<li><a href="#org80922bc">2. 主要模块</a></li>
<li><a href="#orgcd449fd">3. 不是必要的/暂时可不看的 模块:</a></li>
<li><a href="#orgd3f1723">4. frontend</a>
<ul>
<li><a href="#org4333724">4.1. EntryIndex</a></li>
<li><a href="#org2fdbdb2">4.2. switch.rs</a>
<ul>
<li><a href="#org08f47f8">4.2.1. <code>build_search_tree</code> ()</a></li>
<li><a href="#org825d6fa">4.2.2. 继续  <code>build_search_tree</code> ()</a></li>
<li><a href="#org3a9ffb4">4.2.3. <code>build_jump_tables()</code></a></li>
</ul>
</li>
<li><a href="#org3357265">4.3. ssa.rs</a>
<ul>
<li><a href="#orgacb568b">4.3.1. struct Function</a></li>
<li><a href="#org6149884">4.3.2. SSABuilder: 实施ssa构造算法所需要的中间信息</a></li>
<li><a href="#org87361fb">4.3.3. 继续 <code>program_with_loop()</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
//#+startup: content
</p>


<div id="outline-container-org7af13b1" class="outline-2">
<h2 id="org7af13b1"><span class="section-number-2">1.</span> 数据结构</h2>
<div class="outline-text-2" id="text-1">
<p>
entity : Map/Set/List
</p>

<p>
bforest : 树 
</p>
</div>
</div>


<div id="outline-container-org80922bc" class="outline-2">
<h2 id="org80922bc"><span class="section-number-2">2.</span> 主要模块</h2>
<div class="outline-text-2" id="text-2">
<p>
<code>src</code> : clif-util.rs 中有 <code>main()</code> 函数
</p>

<p>
reader : 读取clif文件(文本格式IR),用来做测试  
</p>

<p>
frontend : 生成IR
</p>

<p>
interpreter : IR解释器 
</p>

<p>
preopt : 对IR的早期优化. 
</p>

<p>
module : 链接? 
</p>

<p>
codegen : IR -&gt; 可执行机器码 
</p>

<p>
native : 检测host机器的架构.
</p>

<p>
object : 生成.o文件 
</p>
</div>
</div>






<div id="outline-container-orgcd449fd" class="outline-2">
<h2 id="orgcd449fd"><span class="section-number-2">3.</span> 不是必要的/暂时可不看的 模块:</h2>
<div class="outline-text-2" id="text-3">
<p>
jit : 实验性
</p>

<p>
umbrella : 无实际代码 
</p>

<p>
serde : IR转JSON
</p>

<p>
isle : 生成rust代码的DSL (用于后端)
</p>

<p>
fuzzgen : 生成随机的 Cranelift modules
</p>

<p>
wasm
</p>
</div>
</div>





<div id="outline-container-orgd3f1723" class="outline-2">
<h2 id="orgd3f1723"><span class="section-number-2">4.</span> frontend</h2>
<div class="outline-text-2" id="text-4">
<p>
创建IR形式的函数, 并用指令将其填充.
</p>

<p>
要先创建 FunctionBuilderContext. 
并将其作为一个参数传给 FunctionBuilder 
</p>


<p>
可变变量和IR value 
</p>

<ol class="org-ol">
<li>声明签名,并指定所使用的调用约定.</li>
<li>为sig声明参数和返回值类型.</li>
<li>创建一个FunctionBuilderContext 对象</li>
<li>使用函数名和签名创建一个Function对象.</li>
<li>用函数对象和函数builder上下文创建一个FunctionBuilder</li>
<li>builder.create<sub>block</sub>()创建入口块</li>
<li></li>
</ol>
</div>


<div id="outline-container-org4333724" class="outline-3">
<h3 id="org4333724"><span class="section-number-3">4.1.</span> EntryIndex</h3>
<div class="outline-text-3" id="text-4-1">
<p>
EntryIndex 的作用是为每个基本块生成一个唯一的标识符，方便在 Cranelift 内部进行引用和操作。可以通过 FunctionBuilder::create<sub>block</sub>() 方法创建一个新的基本块，并得到该基本块的 EntryIndex。在生成跳转指令时，可以通过 Switch::set<sub>entry</sub>() 方法为一个 Switch 表格添加新的条目，其中每个条目都是一个基本块的 EntryIndex 和一个对应的标签（通常是一个整数）组成的元组。
</p>
</div>
</div>



<div id="outline-container-org2fdbdb2" class="outline-3">
<h3 id="org2fdbdb2"><span class="section-number-3">4.2.</span> switch.rs</h3>
<div class="outline-text-3" id="text-4-2">
<p>
测试emit()用:
setup, 返回一个函数
接收两个参数: 第一个是default, 第二个是一个各个分支的值list
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">func</span> : <span style="color: #ECBE7B;">String</span> = <span style="color: #51afef; font-weight: bold;">setup!</span>(0, [0,]);
</pre>
</div>


<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef; font-weight: bold;">macro_rules!</span> setup {
       (<span style="color: #dcaeea;">$default</span>:expr, [$(<span style="color: #dcaeea;">$index</span>:expr,)*]) =&gt; {{
           <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">func</span> = <span style="color: #ECBE7B;">Function</span>::new();
           <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">func_ctx</span> = <span style="color: #ECBE7B;">FunctionBuilderContext</span>::new();
           {
               <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">bx</span> = <span style="color: #ECBE7B;">FunctionBuilder</span>::new(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func_ctx);
               <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">block</span> = bx.create_block();
               bx.switch_to_block(block);<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20351;&#24471;&#28966;&#28857;&#31227;&#21040;block&#19978;, &#20174;&#32780;&#33021;&#22312;block&#20013;&#22635;&#20837;&#25351;&#20196;/&#23545;&#22522;&#26412;&#22359;&#36827;&#34892;&#20854;&#20182;&#25805;&#20316;</span>
               <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">val</span> = bx.ins().iconst(<span style="color: #a9a1e1;">types</span>::<span style="color: #ECBE7B;">I8</span>, 0);<span style="color: #5B6268;">//</span><span style="color: #5B6268;">&#21019;&#24314;&#19968;&#26465;&#25351;&#20196;, &#22768;&#26126;&#19968;&#20010;i8&#31867;&#22411;&#30340;&#20540;,&#29992;&#35813;&#20540;&#26469;&#20915;&#23450;&#24212;&#35813;&#36339;&#24448;switch&#30340;&#21738;&#20010;&#20998;&#25903;</span>
               <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">switch</span> = <span style="color: #ECBE7B;">Switch</span>::new();
               $(
                   <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">block</span> = bx.create_block(); <span style="color: #5B6268;">//</span><span style="color: #5B6268;">&#20026;&#27599;&#20010;&#36755;&#20837;list&#20013;&#30340;&#32034;&#24341;&#21019;&#24314;&#19968;&#20010;&#23545;&#24212;&#30340;&#31354;&#22359; </span>
                   switch.set_entry($index, block);<span style="color: #5B6268;">//</span>
               )*
               switch.emit(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> bx, val, <span style="color: #ECBE7B;">Block</span>::with_number($default).unwrap());
               <span style="color: #5B6268;">//</span><span style="color: #5B6268;">&#20026;&#20989;&#25968;&#29983;&#25104;&#20998;&#25903;&#20195;&#30721;</span>
           }
           func
               .to_string()
               .trim_start_matches(<span style="color: #98be65;">"function u0:0() fast {\n"</span>)
               .trim_end_matches(<span style="color: #98be65;">"\n}\n"</span>)
               .to_string()
               <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23558;&#20989;&#25968;&#36716;&#20026;&#23383;&#31526;&#20018;&#24418;&#24335;, &#24182;&#21435;&#25481;&#22836;&#23614;.</span>
       }};
   }
</pre>
</div>


<p>
分支:
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef; font-weight: bold;">#[derive(Debug, Default)]</span>
<span style="color: #51afef;">pub</span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">Switch</span> {
    <span style="color: #dcaeea;">cases</span>: <span style="color: #ECBE7B;">HashMap</span>&lt;<span style="color: #ECBE7B;">EntryIndex</span>, <span style="color: #ECBE7B;">Block</span>&gt;,
}
</pre>
</div>

<p>
可见核心逻辑在 Switch.emit() 中. switch结构本身只是用来生成分支指令的脚手架.
</p>


<p>
先来看emit的签名:
</p>

<p>
bx代表函数.
val代表跳转基于的值.
otherwise表示default块(即各个分支都落空后,要前往的块)
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">pub</span> <span style="color: #51afef;">fn</span> <span style="color: #c678dd;">emit</span>(<span style="color: #51afef;">self</span>, <span style="color: #dcaeea;">bx</span>: <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #ECBE7B;">FunctionBuilder</span>, <span style="color: #dcaeea;">val</span>: <span style="color: #ECBE7B;">Value</span>, <span style="color: #dcaeea;">otherwise</span>: <span style="color: #ECBE7B;">Block</span>) 
</pre>
</div>

<p>
我们用这个测试用例来研究emit的逻辑:
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef; font-weight: bold;">#[test]</span>
<span style="color: #51afef;">fn</span> <span style="color: #c678dd;">switch_many</span>() {
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">func</span> = <span style="color: #51afef; font-weight: bold;">setup!</span>(0, [0, 1, 5, 7, 10, 11, 12,]);

    <span style="color: #51afef; font-weight: bold;">assert_eq!</span>(
        func,

        <span style="color: #98be65;">"    jt0 = jump_table [block1, block2]</span>
<span style="color: #98be65;">    jt1 = jump_table [block5, block6, block7]</span>

<span style="color: #98be65;">block0:</span>
<span style="color: #98be65;">    v0 = iconst.i8 0</span>
<span style="color: #98be65;">    v1 = icmp_imm uge v0, 7  ; v0 = 0</span>
<span style="color: #98be65;">    brnz v1, block9</span>
<span style="color: #98be65;">    jump block8</span>

<span style="color: #98be65;">block9:</span>
<span style="color: #98be65;">    v2 = icmp_imm.i8 uge v0, 10  ; v0 = 0</span>
<span style="color: #98be65;">    brnz v2, block10</span>
<span style="color: #98be65;">    jump block11</span>

<span style="color: #98be65;">block11:</span>
<span style="color: #98be65;">    v3 = icmp_imm.i8 eq v0, 7  ; v0 = 0</span>
<span style="color: #98be65;">    brnz v3, block4</span>
<span style="color: #98be65;">    jump block0</span>

<span style="color: #98be65;">block8:</span>
<span style="color: #98be65;">    v4 = icmp_imm.i8 eq v0, 5  ; v0 = 0</span>
<span style="color: #98be65;">    brnz v4, block3</span>
<span style="color: #98be65;">    jump block12</span>

<span style="color: #98be65;">block12:</span>
<span style="color: #98be65;">    v5 = uextend.i32 v0  ; v0 = 0</span>
<span style="color: #98be65;">    br_table v5, block0, jt0</span>

<span style="color: #98be65;">block10:</span>
<span style="color: #98be65;">    v6 = iadd_imm.i8 v0, -10  ; v0 = 0</span>
<span style="color: #98be65;">    v7 = uextend.i32 v6</span>
<span style="color: #98be65;">    br_table v7, block0, jt1"</span>
    );
}
</pre>
</div>


<p>
首先的几行是判断条件分支中的最大值是否超过了val的type所能表示的范围.若超过了则报错.
这段暂时不用深究.
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #83898d;">/// emit()</span>
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">max</span> = <span style="color: #51afef;">self</span>.cases.keys().max().copied().unwrap_or(0);
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">val_ty</span> = bx.func.dfg.value_type(val);
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">val_ty_max</span> = val_ty.bounds(<span style="color: #51afef;">false</span>).1;
<span style="color: #51afef;">if</span> max &gt; val_ty_max {
    <span style="color: #51afef; font-weight: bold;">panic!</span>(
        <span style="color: #98be65;">"The index type {} does not fit the maximum switch entry of {}"</span>,
        val_ty, max
    );
}
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">...</span>
</pre>
</div>

<p>
然后一行是:
从switch中计算出 ContiguousCaseRange (连续case范围) 的list
</p>

<p>
gpt:
</p>

<p>
collect<sub>contiguous</sub><sub>case</sub><sub>ranges</sub> 方法用于收集所有连续的 case range，并将它们组合成一个 Vec，以便后续处理。
</p>

<p>
在 build<sub>search</sub><sub>tree</sub> 方法中，首先通过 collect<sub>contiguous</sub><sub>case</sub><sub>ranges</sub> 方法获取到所有连续的 case range，接着通过递归的方式，将这些连续的 case range 分解成更小的 case range。最终，每个 case range 都被组织成一个搜索树。这个搜索树是一个嵌套的结构，每个节点包含一个 case 和一个子搜索树。
</p>

<p>
在 build<sub>jump</sub><sub>tables</sub> 方法中，根据搜索树，生成一个跳转表。跳转表的长度是 case range 的数量，每个 entry 是一个基本块。跳转表可以用于实现跳转语义，比如在 switch 表达式中跳转到对应的基本块。
</p>

<p>
总体来说，collect<sub>contiguous</sub><sub>case</sub><sub>ranges</sub> 方法是用于帮助收集连续的 case range，方便后续的处理。通过递归的方式，将搜索树分解成一个个小的 case range，最终生成一个跳转表，实现了 switch 语义。
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #83898d;">/// emit() </span>
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">contiguous_case_ranges</span> = <span style="color: #51afef;">self</span>.collect_contiguous_case_ranges();
</pre>
</div>

<p>
我们抄一个测试来输出它:
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef; font-weight: bold;">macro_rules!</span> gen_switch {
    (<span style="color: #dcaeea;">$default</span>:expr, [$(<span style="color: #dcaeea;">$index</span>:expr,)*]) =&gt; {{
        <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">func</span> = <span style="color: #ECBE7B;">Function</span>::new();
        <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">func_ctx</span> = <span style="color: #ECBE7B;">FunctionBuilderContext</span>::new();

        <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">bx</span> = <span style="color: #ECBE7B;">FunctionBuilder</span>::new(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func_ctx);
        <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">block</span> = bx.create_block();
        bx.switch_to_block(block);
        <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">val</span> = bx.ins().iconst(<span style="color: #a9a1e1;">types</span>::<span style="color: #ECBE7B;">I8</span>, 0);
        <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">switch</span> = <span style="color: #ECBE7B;">Switch</span>::new();
        $(
            <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">block</span> = bx.create_block();
            switch.set_entry($index, block);
        )*
            switch
    }};
}

<span style="color: #51afef; font-weight: bold;">#[test]</span>
<span style="color: #51afef;">fn</span> <span style="color: #c678dd;">learn_collect_contiguous_case_ranges</span>() {
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">switch</span> = <span style="color: #51afef; font-weight: bold;">gen_switch!</span>(0, [0, 1, 5, 7, 10, 11, 12,]);
    <span style="color: #c678dd;">eprintln!</span>(<span style="color: #98be65;">"</span><span style="color: #98be65; font-style: italic;">{:?}</span><span style="color: #98be65;">"</span>, switch.collect_contiguous_case_ranges());
}
</pre>
</div>

<p>
输出如下, 可见此函数就是将连续的case值放在一组,并记录下这组中的最小case值. 
</p>
<div class="org-src-container">
<pre class="src src-rust">[
    <span style="color: #ECBE7B;">ContiguousCaseRange</span> {
        <span style="color: #dcaeea;">first_index</span>: 0,
        <span style="color: #dcaeea;">blocks</span>: [
            block1, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">0</span>
            block2, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1</span>
        ],
    },
    <span style="color: #ECBE7B;">ContiguousCaseRange</span> {
        <span style="color: #dcaeea;">first_index</span>: 5,
        <span style="color: #dcaeea;">blocks</span>: [
            block3, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">5</span>
        ],
    },
    <span style="color: #ECBE7B;">ContiguousCaseRange</span> {
        <span style="color: #dcaeea;">first_index</span>: 7,
        <span style="color: #dcaeea;">blocks</span>: [
            block4, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">7</span>
        ],
    },
    <span style="color: #ECBE7B;">ContiguousCaseRange</span> {
        <span style="color: #dcaeea;">first_index</span>: 10,
        <span style="color: #dcaeea;">blocks</span>: [
            block5, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10</span>
            block6, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">11</span>
            block7, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">12</span>
        ],
    },
]
</pre>
</div>

<p>
emit()的最后两行调用了switch的两个函数:
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">cases_and_jt_blocks</span> =
    <span style="color: #ECBE7B;">Self</span>::build_search_tree(bx, val, otherwise, contiguous_case_ranges);

<span style="color: #ECBE7B;">Self</span>::build_jump_tables(bx, val, otherwise, cases_and_jt_blocks);
<span style="color: #83898d;">/// emit() &#32467;&#26463;  </span>
</pre>
</div>
</div>


<div id="outline-container-org08f47f8" class="outline-4">
<h4 id="org08f47f8"><span class="section-number-4">4.2.1.</span> <code>build_search_tree</code> ()</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
gpt:
在 switch.emit 中，搜索树（search tree）是一个用于优化分支跳转的数据结构。其目的是在多个条件分支中，使用二分查找的方式快速定位到一个具体的分支。
</p>

<p>
在这里，搜索树被用来优化 switch 语句。switch 语句中的每个 case 都对应着一个基本块，但是如果 case 的数量过多，直接使用分支跳转的方式会带来较大的开销。因此，通过将 case 按照顺序分成多个连续的范围，并将每个范围中的最小值与最大值记录在搜索树的节点上，可以加速查找特定值的 case 所对应的基本块。通过这种方式，即使 switch 语句中的 case 数量很多，查找特定值对应的 case 所对应的基本块的开销也可以降到对数级别。
</p>


<p>
GPT:
</p>
<div class="org-src-container">
<pre class="src src-rust">build_search_tree &#26041;&#27861;&#26159; <span style="color: #ECBE7B;">SwitchBuilder</span> &#20013;&#30340;&#19968;&#20010;&#31169;&#26377;&#26041;&#27861;&#65292;&#20854;&#20027;&#35201;&#20316;&#29992;&#26159;&#26500;&#24314;&#25628;&#32034;&#26641;&#12290;&#36825;&#20010;&#25628;&#32034;&#26641;&#26159;&#19968;&#20010;&#20108;&#21449;&#26641;&#65292;&#20854;&#20013;&#27599;&#20010;&#21494;&#23376;&#33410;&#28857;&#23545;&#24212;&#20110;&#19968;&#20010;&#36830;&#32493;&#30340; case &#33539;&#22260;&#12290;&#27599;&#20010;&#38750;&#21494;&#23376;&#33410;&#28857;&#34920;&#31034;&#23545;&#23376;&#26641;&#20013;&#25152;&#26377; case &#33539;&#22260;&#30340;&#20998;&#21106;&#12290;

&#26041;&#27861;&#30340;&#31532;&#19968;&#20010;&#21442;&#25968;&#26159; <span style="color: #dcaeea;">bx</span>: <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #ECBE7B;">FunctionBuilder&#65292;&#20195;&#34920;&#24403;&#21069;&#20989;&#25968;&#30340;&#29983;&#25104;&#22120;&#65292;&#31532;&#20108;&#20010;&#21442;&#25968;&#26159;</span> <span style="color: #dcaeea;">val</span>: <span style="color: #ECBE7B;">Value&#65292;&#20195;&#34920;</span> switch &#34920;&#36798;&#24335;&#30340;&#20540;&#65292;&#31532;&#19977;&#20010;&#21442;&#25968;&#26159; <span style="color: #dcaeea;">otherwise</span>: <span style="color: #ECBE7B;">Block&#65292;&#20195;&#34920;</span> switch &#20013;&#30340; otherwise &#20998;&#25903;&#12290;&#26041;&#27861;&#30340;&#26368;&#21518;&#19968;&#20010;&#21442;&#25968;&#26159;&#19968;&#20010; <span style="color: #ECBE7B;">Vec</span>&lt;<span style="color: #ECBE7B;">ContiguousCaseRange</span>&gt;&#65292;&#20195;&#34920; switch &#20013;&#25152;&#26377;&#36830;&#32493;&#30340; case &#33539;&#22260;&#12290;

&#22312;&#26041;&#27861;&#30340;&#31532;&#19968;&#34892;&#65292;&#25105;&#20204;&#21019;&#24314;&#20102;&#19968;&#20010;&#31354;&#30340;&#21521;&#37327; cases_and_jt_blocks&#65292;&#29992;&#20110;&#23384;&#20648;&#26368;&#32456;&#29983;&#25104;&#30340;&#20195;&#30721;&#22359;&#21644; jump table&#12290;

&#22914;&#26524; contiguous_case_ranges &#20013;&#30340; case &#25968;&#37327;&#23567;&#20110;&#31561;&#20110; 3&#65292;&#25105;&#20204;&#30452;&#25509;&#35843;&#29992; build_search_branches &#26041;&#27861;&#29983;&#25104;&#20195;&#30721;&#12290;build_search_branches &#26041;&#27861;&#20250;&#29983;&#25104;&#19968;&#32452;&#27604;&#36739;&#65292;&#20197;&#21450;&#23545;&#24212;&#30340;&#20998;&#25903;&#20195;&#30721;&#65292;&#26469;&#22788;&#29702;&#27599;&#20010; case &#33539;&#22260;&#12290;

&#22914;&#26524; contiguous_case_ranges &#20013;&#30340; case &#25968;&#37327;&#22823;&#20110; 3&#65292;&#25105;&#20204;&#23558; case &#33539;&#22260;&#20998;&#25104;&#20004;&#37096;&#20998;&#65292;&#20998;&#21035;&#22788;&#29702;&#24038;&#21491;&#23376;&#26641;&#12290;&#20855;&#20307;&#22320;&#65292;&#25105;&#20204;&#36890;&#36807; contiguous_case_ranges.len() / 2 &#26469;&#30830;&#23450;&#20013;&#38388;&#28857;&#65292;&#23558;&#24038;&#36793;&#30340; case &#33539;&#22260;&#25918;&#21040; left &#20013;&#65292;&#23558;&#21491;&#36793;&#30340; case &#33539;&#22260;&#25918;&#21040; right &#20013;&#12290;&#28982;&#21518;&#25105;&#20204;&#21019;&#24314;&#20004;&#20010;&#26032;&#30340;&#20195;&#30721;&#22359; left_block &#21644; right_block&#65292;&#29992;&#20110;&#34920;&#31034;&#24038;&#23376;&#26641;&#21644;&#21491;&#23376;&#26641;&#12290;

&#25509;&#30528;&#65292;&#25105;&#20204;&#23558; right[0].first_index &#23384;&#20648;&#21040; first_index &#20013;&#65292;&#35813;&#20540;&#26159;&#21491;&#23376;&#26641;&#20013;&#31532;&#19968;&#20010; case &#30340;&#36215;&#22987;&#20540;&#12290;&#28982;&#21518;&#25105;&#20204;&#21019;&#24314;&#19968;&#20010;&#27604;&#36739;&#25351;&#20196; should_take_right_side&#65292;&#29992;&#20110;&#27604;&#36739; val &#21644; first_index &#30340;&#22823;&#23567;&#12290;&#22914;&#26524; val &#22823;&#20110;&#25110;&#31561;&#20110; first_index&#65292;&#21017;&#36339;&#36716;&#21040;&#21491;&#23376;&#26641;&#65307;&#21542;&#21017;&#65292;&#36339;&#36716;&#21040;&#24038;&#23376;&#26641;&#12290;

&#26368;&#21518;&#65292;&#25105;&#20204;&#20351;&#29992; bx.seal_block &#23558;&#26032;&#24314;&#30340;&#20195;&#30721;&#22359;&#23553;&#38381;&#65292;&#34920;&#31034;&#25105;&#20204;&#24050;&#32463;&#23436;&#25104;&#20102;&#23545;&#35813;&#22359;&#30340;&#25152;&#26377;&#20195;&#30721;&#29983;&#25104;&#25805;&#20316;&#12290;&#26368;&#21518;&#65292;&#25105;&#20204;&#23558;&#24038;&#21491;&#23376;&#26641;&#21387;&#20837;&#22534;&#26632;&#65292;&#36827;&#34892;&#19979;&#19968;&#36718;&#22788;&#29702;&#12290;&#22914;&#26524;&#22534;&#26632;&#20026;&#31354;&#65292;&#21017;&#25152;&#26377;&#23376;&#26641;&#24050;&#32463;&#22788;&#29702;&#23436;&#27605;&#65292;&#25105;&#20204;&#36820;&#22238; cases_and_jt_blocks&#12290;

&#35813;&#26041;&#27861;&#20027;&#35201;&#30340;&#30446;&#30340;&#26159;&#23558; switch &#20013;&#30340; case &#33539;&#22260;&#25286;&#20998;&#25104;&#26356;&#23567;&#30340;&#22359;&#65292;&#20197;&#20415;&#26356;&#39640;&#25928;&#22320;&#29983;&#25104;&#20195;&#30721;&#12290;&#36825;&#20010;&#26041;&#27861;&#36890;&#36807;&#26500;&#24314;&#19968;&#20010;&#20108;&#21449;&#26641;&#65292;&#23558; case &#33539;&#22260;&#25353;&#29031;&#20540;&#30340;&#33539;&#22260;&#36827;&#34892;&#20998;&#21106;&#65292;&#20351;&#24471;&#22312;&#20195;&#30721;&#29983;&#25104;&#26102;&#21487;&#20197;&#26356;&#24555;&#22320;&#25214;&#21040;&#38656;&#35201;&#36339;&#36716;&#21040;&#21738;&#20010;&#20195;&#30721;&#22359;&#12290;
</pre>
</div>


<p>
先看 <code>build_search_tree</code>, 它以分好组的块作为输入.返回类型为: 
</p>
<div class="org-src-container">
<pre class="src src-rust">-&gt; <span style="color: #ECBE7B;">Vec</span>&lt;(<span style="color: #ECBE7B;">EntryIndex</span>, <span style="color: #ECBE7B;">Block</span>, <span style="color: #ECBE7B;">Vec</span>&lt;<span style="color: #ECBE7B;">Block</span>&gt;)&gt;
</pre>
</div>
<p>
这个结构将来用于生成 jt<sub>table</sub> 
</p>


<p>
当连续case值形成的分组不超过3时,形成的块的数量较少,可以直接生成跳转代码, 用build<sub>search</sub><sub>branches来实现此函数</sub>.
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">cases_and_jt_blocks</span> = <span style="color: #ECBE7B;">Vec</span>::new(); <span style="color: #5B6268;">//</span><span style="color: #5B6268;">&#23558;&#20316;&#20026;&#36755;&#20986;&#32467;&#26524;</span>

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Avoid allocation in the common case</span>
<span style="color: #51afef;">if</span> contiguous_case_ranges.len() &lt;= 3 {
    <span style="color: #ECBE7B;">Self</span>::build_search_branches(
        bx,
        val,
        otherwise,
        contiguous_case_ranges,
        <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> cases_and_jt_blocks,
    );
    <span style="color: #51afef;">return</span> cases_and_jt_blocks;
}
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="orgd6d7f19"></a><code>build_search_branches</code> ()<br />
<div class="outline-text-5" id="text-4-2-1-1">
<p>
首先是 声明了flag表明当前是否处在分支位置.
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">was_branch</span> = <span style="color: #51afef;">false</span>;
</pre>
</div>
<p>
然后是一个辅助函数, 当处于分支位置时就执行,否则什么都不做.
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">ins_fallthrough_jump</span> = |<span style="color: #dcaeea;">was_branch</span>: <span style="color: #ECBE7B;">bool</span>, <span style="color: #dcaeea;">bx</span>: <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #ECBE7B;">FunctionBuilder</span>| {
    <span style="color: #51afef;">if</span> was_branch {
        <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">block</span> = bx.create_block(); <span style="color: #5B6268;">//</span><span style="color: #5B6268;">&#21019;&#24314;&#19968;&#20010;&#26032;&#30340;&#22522;&#26412;&#22359;</span>
        bx.ins().jump(block, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span>[]);<span style="color: #5B6268;">//</span><span style="color: #5B6268;">&#22312;&#30446;&#21069;&#25152;&#22312;&#20998;&#25903;&#22359;&#20013;&#25554;&#20837;&#19968;&#26465;jump, &#29992;&#26469;&#36339;&#36716;&#21040;&#26032;&#22359;</span>
        bx.seal_block(block); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20026;&#26032;&#22359; "&#23553;&#21475;" (&#24050;&#22788;&#29702;&#22909;&#35813;&#22359;&#25152;&#26377;&#30452;&#25509;&#21069;&#39537;)</span>
        bx.switch_to_block(block); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20999;&#25442;&#21040;&#36825;&#20010;&#26032;&#30340;&#31354;&#22359;&#20013;.</span>
    }
};
</pre>
</div>


<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">for</span> <span style="color: #ECBE7B;">ContiguousCaseRange</span> { first_index, blocks, }
<span style="color: #51afef;">in</span> contiguous_case_ranges.into_iter().rev()
<span style="color: #5B6268;">//</span><span style="color: #5B6268;">...</span>
</pre>
</div>
<p>
反向遍历连续case值的分组, 举个例子就是:
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">switch</span> = <span style="color: #51afef; font-weight: bold;">gen_switch!</span>(0, [0, 1, 5, 7, 8,]);
</pre>
</div>
<div class="org-src-container">
<pre class="src src-rust">[
    <span style="color: #ECBE7B;">ContiguousCaseRange</span> { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#31532;&#19977;&#36718;</span>
        <span style="color: #dcaeea;">first_index</span>: 0,
        <span style="color: #dcaeea;">blocks</span>: [
            block1, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">0</span>
            block2, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1</span>
        ],
    },
    <span style="color: #ECBE7B;">ContiguousCaseRange</span> { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#31532;&#20108;&#36718;</span>
        <span style="color: #dcaeea;">first_index</span>: 5,
        <span style="color: #dcaeea;">blocks</span>: [
            block3, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">5</span>
        ],
    },
    <span style="color: #ECBE7B;">ContiguousCaseRange</span> { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#31532;&#19968;&#36718;</span>
        <span style="color: #dcaeea;">first_index</span>: 7,
        <span style="color: #dcaeea;">blocks</span>: [
            block4, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">7</span>
            block5, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">8</span>
        ],
    },
]
</pre>
</div>

<p>
循环内的具体逻辑是根据每个组中的长度以及最小值做判断, 特殊处理长度=1或最小值=0的情况:
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">match</span> (blocks.len(), first_index) {
    (1, 0) =&gt; {<span style="color: #83898d;">/** ... */</span>}
    (1, _) =&gt; {<span style="color: #83898d;">/** ... */</span>}
    (_, 0) =&gt; {<span style="color: #83898d;">/** ... */</span>}
    (_, _) =&gt; {<span style="color: #83898d;">/** ... */</span>}
}
was_branch = <span style="color: #51afef;">true</span>;
</pre>
</div>

<p>
当组中只有一个块且case值为0时: 
</p>
<div class="org-src-container">
<pre class="src src-rust">(1, 0) =&gt; {
    ins_fallthrough_jump(was_branch, bx); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#33509;&#22788;&#22312;&#20998;&#25903;&#20301;&#32622;, &#21017;&#23558;&#19979;&#38754;&#30340;&#20195;&#30721;&#25918;&#21040;&#26032;&#22359;</span>
    bx.ins().brz(val, blocks[0], <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span>[]); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#26681;&#25454;val&#26159;&#21542;&#20026;0&#26469;&#21028;&#26029;&#26159;&#21542;&#36339;&#36716;&#21040;&#36825;&#20010;&#20998;&#25903;</span>
}
</pre>
</div>

<p>
当组中只有一个case分支,且其case值不等于零时
</p>
<div class="org-src-container">
<pre class="src src-rust">(1, _) =&gt; {
    ins_fallthrough_jump(was_branch, bx); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#33509;&#22788;&#22312;&#20998;&#25903;&#20301;&#32622;, &#21017;&#23558;&#19979;&#38754;&#30340;&#20195;&#30721;&#25918;&#21040;&#26032;&#22359;</span>
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">is_good_val</span> = icmp_imm_u128(bx, <span style="color: #ECBE7B;">IntCC</span>::<span style="color: #ECBE7B;">Equal</span>, val, first_index);
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">is_good_val = (val == &#27492;&#20998;&#25903;&#30340;case&#20540;)</span>
    bx.ins().brnz(is_good_val, blocks[0], <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span>[]); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">brnz&#20026;true&#26102;&#36339;&#36716;</span>
}
</pre>
</div>

<p>
当组中的首个case值==0,且组中不止一个分支时, 说明该组是switch的最后一部分,执行到这里时应该与之前的各组都不能匹配,而因为val&gt;=0 ,
因此最终只能跳入到这一部分.无需再生成jump otherwise.
</p>
<div class="org-src-container">
<pre class="src src-rust">(_, 0) =&gt; {
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">if `first_index` is 0, then `icmp_imm uge val, first_index` is trivially true</span>
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">jt_block</span> = bx.create_block();<span style="color: #5B6268;">//</span><span style="color: #5B6268;">&#21019;&#24314;&#19968;&#20010;&#31354;&#22359;,&gt;= first_index&#26102;&#25165;&#36339;&#20837;&#23427;</span>
    bx.ins().jump(jt_block, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span>[]); <span style="color: #5B6268;">//</span><span style="color: #5B6268;">&#22312;&#24403;&#21069;&#22359;&#20013;&#25554;&#20837;&#19968;&#26465;jump, &#36339;&#21040;&#36825;&#20010;&#31354;&#22359;&#20013;</span>
    bx.seal_block(jt_block); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23558;&#36825;&#20010;&#31354;&#22359;&#23553;&#21475;</span>
    cases_and_jt_blocks.push((first_index, jt_block, blocks));
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">`jump otherwise` below must not be hit, because the current block has been</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">filled above. This is the last iteration anyway, as 0 is the smallest</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">unsigned int, so just return here.</span>
    <span style="color: #51afef;">return</span>;
}
</pre>
</div>

<p>
当连续case分支不止一个且最小case值不是零时:
</p>
<div class="org-src-container">
<pre class="src src-rust">(_, _) =&gt; {
    ins_fallthrough_jump(was_branch, bx);<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#33509;&#20026;&#20998;&#25903;&#22788;,</span>
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">jt_block</span> = bx.create_block();<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21019;&#24314;&#31354;&#22359;, &gt;=first_index&#26102;&#25165;&#36339;&#20837;&#27492;&#22359;</span>
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">is_good_val</span> = <span style="color: #5B6268;">// </span><span style="color: #5B6268;">val &gt;= first_index ? </span>
        icmp_imm_u128(bx, <span style="color: #ECBE7B;">IntCC</span>::<span style="color: #ECBE7B;">UnsignedGreaterThanOrEqual</span>, val, first_index);
    bx.ins().brnz(is_good_val, jt_block, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span>[]);<span style="color: #5B6268;">//</span><span style="color: #5B6268;">&#32467;&#26524;&#20026;true=1&#26102;&#21457;&#29983;&#36339;&#36716;</span>
    bx.seal_block(jt_block); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23494;&#23553;&#26032;&#22359;</span>
    cases_and_jt_blocks.push((first_index, jt_block, blocks));
}
</pre>
</div>

<p>
当for的首次迭代结束后,  <code>was_branch</code> 被置为true. 也就是说 <code>contiguous_case_ranges</code> 剩下的每个组各自开辟一个新块.
并在每个组的块最后插入一个无条件跳转到下个组的jump
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #51afef;">switch</span> (val) {
 <span style="color: #51afef;">case</span> <span style="color: #98be65;">'0'</span>: 
 <span style="color: #51afef;">case</span> <span style="color: #98be65;">'1'</span>:
   <span style="color: #51afef;">break</span>;

 <span style="color: #51afef;">case</span> <span style="color: #98be65;">'5'</span> :
   <span style="color: #51afef;">break</span>;

 <span style="color: #51afef;">case</span> <span style="color: #98be65;">'7'</span>: 
 <span style="color: #51afef;">case</span> <span style="color: #98be65;">'8'</span>:
   <span style="color: #51afef;">break</span>;
 }
</pre>
</div>


<p>
for循环之后:
生成跳转到default块的指令(和各个case都不匹配)
</p>
<div class="org-src-container">
<pre class="src src-rust">bx.ins().jump(otherwise, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span>[]);
</pre>
</div>
</div>
</li>
</ol>
</div>


<div id="outline-container-org825d6fa" class="outline-4">
<h4 id="org825d6fa"><span class="section-number-4">4.2.2.</span> 继续  <code>build_search_tree</code> ()</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
当形成的分组&gt;3时,说明最终要形成的块的数量较多,此时直接生成跳转代码的效率太低, 要将比较逻辑用二叉树搜索的方式来进行.
</p>

<p>
上面这段代码为什么要用到stack+ while循环? 
</p>

<p>
GPT: 这段代码通过使用一个栈结构和 while 循环来构建一个树形结构，其中每个节点都是一个基本块（block），该块的值是在 switch 表达式中被测试的值。在每个节点，根据该节点的连续 case 索引范围，会有一些分支指令用于测试测试值是否在该范围内。如果连续 case 索引范围小于或等于 3，则直接发出这些测试指令。否则，将节点拆分为两个子节点，并在中间插入一个条件分支，该分支将 switch 表达式值与分裂点的索引进行比较，从而确定应选择哪个子节点进行下一步分裂。
这个 while 循环实际上是在模拟一个深度优先搜索过程。在每一次迭代中，从栈顶弹出当前节点的信息，如果连续 case 索引范围小于等于 3，则在当前块中生成对应的分支指令，否则根据范围拆分当前节点，并将生成的子节点信息压入栈顶，这样就可以迭代生成整个搜索树。最终生成的 cases<sub>and</sub><sub>jt</sub><sub>blocks</sub> 向量包含了每个块的入口编号，以及每个 case 索引范围所对应的基本块和跳转表，这些信息将用于后续的跳转表生成过程。
</p>

<p>
先创建一个待处理stack,将 <code>contiguous_case_ranges</code> 不断切分后放入.
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">stack</span>: <span style="color: #ECBE7B;">Vec</span>&lt;(<span style="color: #ECBE7B;">Option</span>&lt;<span style="color: #ECBE7B;">Block</span>&gt;, <span style="color: #ECBE7B;">Vec</span>&lt;<span style="color: #ECBE7B;">ContiguousCaseRange</span>&gt;)&gt; = <span style="color: #ECBE7B;">Vec</span>::new();
stack.push((<span style="color: #ECBE7B;">None</span>, contiguous_case_ranges));
</pre>
</div>

<p>
下面是循环处理stack中的元素:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">while</span> <span style="color: #51afef;">let</span> <span style="color: #ECBE7B;">Some</span>((block, contiguous_case_ranges)) = stack.pop() {
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">...</span>
}
</pre>
</div>

<p>
若取到元素的key不是空的, 则将焦点移到这个块上继续生成代码.
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">if</span> <span style="color: #51afef;">let</span> <span style="color: #ECBE7B;">Some</span>(block) = block {
    bx.switch_to_block(block);
}
</pre>
</div>

<p>
下面对取出来的 <code>contiguous_case_ranges</code> 按照元素个是分别进行处理.
不超过3时和上面的处理一样, 用 build<sub>search</sub><sub>branches</sub> 生成代码
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">if</span> contiguous_case_ranges.len() &lt;= 3 {
    <span style="color: #ECBE7B;">Self</span>::build_search_branches(
        bx,
        val,
        otherwise,
        contiguous_case_ranges,
        <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> cases_and_jt_blocks,
    );
}
</pre>
</div>


<p>
当这个list太长时,顺序地为每个连续case值形成的组生成指令是低效的.(相当于线性查找)
因此要对这个list做切分,并且还能正确地跳转到这两部分.
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">... </span>
<span style="color: #51afef;">else</span> {
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">split_point</span> = contiguous_case_ranges.len() / 2;
    <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">left</span> = contiguous_case_ranges;
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">right</span> = left.split_off(split_point); <span style="color: #5B6268;">//</span><span style="color: #5B6268;">&#20174;split_point&#22788;&#25130;&#26029;.</span>

    <span style="color: #83898d;">/// &#29983;&#25104;&#20004;&#20010;&#36741;&#21161;&#22359;,&#20316;&#20026;&#24038;&#21322;&#37096;&#20998;,&#21491;&#21322;&#37096;&#20998;&#29983;&#25104;&#25351;&#20196;&#30340;&#36215;&#22987;&#22359;: </span>
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">left_block</span> = bx.create_block();
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">right_block</span> = bx.create_block();

    <span style="color: #83898d;">/// &#36873;&#25321;&#36339;&#24448; &#24038;&#21322;&#37096;&#20998;/&#21491;&#21322;&#37096;&#20998; ?</span>
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">first_index</span> = right[0].first_index; <span style="color: #83898d;">/// &#21491;&#21322;&#37096;&#20998;&#31532;&#19968;&#20010;&#36830;&#32493;case&#32452;&#30340;&#26368;&#23567;case&#20540;</span>
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">should_take_right_side</span> = <span style="color: #83898d;">/// val&#26159;&#21542; &gt;= &#36825;&#20010;&#20540;</span>
        icmp_imm_u128(bx, <span style="color: #ECBE7B;">IntCC</span>::<span style="color: #ECBE7B;">UnsignedGreaterThanOrEqual</span>, val, first_index);
    bx.ins().brnz(should_take_right_side, right_block, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span>[]); <span style="color: #83898d;">/// &#33509;&#26159;&#21017;&#36339;&#24448;&#21491;&#21322;&#37096;&#20998;</span>
    bx.ins().jump(left_block, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span>[]); <span style="color: #83898d;">/// &#21542;&#21017;&#30452;&#25509;&#36339;&#24448;&#24038;&#21322;&#37096;&#20998;</span>

    <span style="color: #83898d;">/// &#36127;&#36131;&#26631;&#35760;: &#20004;&#20010;&#36741;&#21161;&#22359;&#30340;&#21069;&#39537;&#22359;(&#20063;&#23601;&#26159;&#24403;&#21069;&#22359;)&#30340;&#20195;&#30721;&#24050;&#32463;&#29983;&#25104;&#23436;&#27605;</span>
    bx.seal_block(left_block); 
    bx.seal_block(right_block);
    <span style="color: #83898d;">/// &#23558;&#20999;&#20998;&#21518;&#30340;&#20004;&#20010;list&#21152;&#20837;&#21040;&#24453;&#29983;&#25104;&#25351;&#20196;&#30340;&#24037;&#20316;&#38431;&#21015;&#20013;,&#24453;&#20043;&#21518;&#30340;&#24490;&#29615;&#20026;&#20854;&#29983;&#25104;&#25351;&#20196;.</span>
    stack.push((<span style="color: #ECBE7B;">Some</span>(left_block), left));
    stack.push((<span style="color: #ECBE7B;">Some</span>(right_block), right));
}
</pre>
</div>

<p>
<code>build_search_tree</code> 的输出是用于产生jt<sub>table的信息</sub>.
</p>

<p>
所谓jt<sub>table</sub>, 在生成ir的开头处声明: 
</p>
<div class="org-src-container">
<pre class="src src-rust">jt0 = jump_table [block2, block3]
</pre>
</div>

<p>
用法为通过br<sub>table指令</sub>: 
</p>
<div class="org-src-container">
<pre class="src src-rust">br_table &#20540;, &#33853;&#31354;&#22359;, jt_table
</pre>
</div>

<p>
值就是jt<sub>table的索引,取值为</sub> 0,1,2,3, &#x2026;
例如值为1时,跳转到jt0的第二个目标 block3 中.
当值无法对应jt<sub>table中的元素时,则跳转到落空块中</sub>(default分支).
</p>
</div>
</div>









<div id="outline-container-org3a9ffb4" class="outline-4">
<h4 id="org3a9ffb4"><span class="section-number-4">4.2.3.</span> <code>build_jump_tables()</code></h4>
<div class="outline-text-4" id="text-4-2-3">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ECBE7B;">Self</span>::build_jump_tables(bx, val, otherwise, cases_and_jt_blocks);
</pre>
</div>



<p>
<code>jt_table</code> 用于生成 跳转到连续case值所对应的块
</p>

<p>
此函数的输入: 就是为了生成jt<sub>table准备的</sub>. 第二个Block是生成指令的起始块.
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #dcaeea;">cases_and_jt_blocks</span>: <span style="color: #ECBE7B;">Vec</span>&lt;(<span style="color: #ECBE7B;">EntryIndex</span>, <span style="color: #ECBE7B;">Block</span>, <span style="color: #ECBE7B;">Vec</span>&lt;<span style="color: #ECBE7B;">Block</span>&gt;)&gt;,
</pre>
</div>
<p>
此函数的主体是一个for循环, 反向取出元素 (first<sub>index从小到大</sub>)
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">for</span> (first_index, jt_block, blocks) <span style="color: #51afef;">in</span> cases_and_jt_blocks.into_iter().rev() {
    <span style="color: #83898d;">/// ...</span>
}
</pre>
</div>

<p>
首先创建并初始化jump<sub>table</sub>. 并将焦点移到此连续case值所对应的块
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">jt_data</span> = <span style="color: #ECBE7B;">JumpTableData</span>::new();
<span style="color: #51afef;">for</span> <span style="color: #dcaeea;">block</span> <span style="color: #51afef;">in</span> blocks {
    jt_data.push_entry(block);
}
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">jump_table</span> = bx.create_jump_table(jt_data);

bx.switch_to_block(jt_block);
</pre>
</div>

<p>
然后要将val和各个分支的连续case值比较转化为 jump<sub>table的索引</sub>.
</p>

<p>
例如: val=12, 一个case值形成的组是 [10,11,12,13]
</p>

<p>
为了生成正确的br<sub>table指令,要将</sub> val-10 作为该指令的操作数,即:
</p>
<div class="org-src-container">
<pre class="src src-rust">br_table  [u32&#20540;](val - first_index), otherwise&#22359;, jump_table
</pre>
</div>

<p>
但这个 first<sub>index</sub> 的类型是 u128, 不能直接转为 Value所表示的值
</p>
</div>

<ol class="org-ol">
<li><a id="org26fb3d6"></a><span class="todo TODO">TODO</span> (val - first<sub>index</sub>)的类型转换???<br />
<div class="outline-text-5" id="text-4-2-3-1">
<p>
最后, 生成 br<sub>table</sub> 指令: 
</p>
<div class="org-src-container">
<pre class="src src-rust">bx.ins().br_table(discr, otherwise, jump_table);
</pre>
</div>


<p>
br<sub>table</sub>() 是一个控制流指令，用于实现基于索引的跳转表。 它有两个操作数：一个是作为索引的值，另一个是指向一系列块的表。指令会根据索引跳转到表中的相应块。
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">selector</span> = &#8230;; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">a value to use as an index into the jump table</span>
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">table</span> = [block0, block1, block2, block3, block4];
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">default_block</span> = &#8230;;
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">jump_dest</span> = builder.br_table(selector, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span>table, default_block);
</pre>
</div>
<p>
在上面的示例中，如果 selector 是 0，那么 jump<sub>dest</sub> 将指向 block0。如果 selector 是 4，那么 jump<sub>dest</sub> 将指向 block4。如果 selector 不在 0..=4 的范围内，则 jump<sub>dest</sub> 将指向 default<sub>block</sub>。
</p>
</div>
</li>
</ol>
</div>
</div>












<div id="outline-container-org3357265" class="outline-3">
<h3 id="org3357265"><span class="section-number-3">4.3.</span> ssa.rs</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef; font-weight: bold;">#[test]</span>
<span style="color: #51afef;">fn</span> <span style="color: #c678dd;">program_with_loop</span>() 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #c678dd;">block0</span>:
          <span style="color: #51afef;">x</span> = 1<span style="color: #5B6268;">;</span>
          <span style="color: #51afef;">y</span> = 2<span style="color: #5B6268;">;</span>
          <span style="color: #51afef;">z</span> = x + y<span style="color: #5B6268;">;</span>
          <span style="color: #51afef;">jump</span> block1
<span style="color: #c678dd;">block1</span>:
          <span style="color: #51afef;">z</span> = z + y<span style="color: #5B6268;">;</span>
          <span style="color: #51afef;">brnz</span> y, block3<span style="color: #5B6268;">;</span>
          <span style="color: #51afef;">jump</span> block2<span style="color: #5B6268;">;</span>
<span style="color: #c678dd;">block2</span>:
          <span style="color: #51afef;">z</span> = z - x<span style="color: #5B6268;">;</span>
          <span style="color: #51afef;">return</span> y
<span style="color: #c678dd;">block3</span>:
          <span style="color: #51afef;">y</span> = y - x
          <span style="color: #51afef;">jump</span> block1
</pre>
</div>


<p>
实际生成的ssa
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #c678dd;">function</span> <span style="color: #51afef;">u0</span>:0() fast {

<span style="color: #c678dd;">block0</span>:
    <span style="color: #51afef;">v0</span> = iconst.i32 1
    <span style="color: #51afef;">v6</span> -&gt; v0
    <span style="color: #51afef;">v1</span> = iconst.i32 2
    <span style="color: #51afef;">v2</span> = iadd v0, v1  <span style="color: #5B6268;">; </span><span style="color: #5B6268;">v0 = 1, v1 = 2</span>
    <span style="color: #51afef;">jump</span> block1(v2, v1)  <span style="color: #5B6268;">; </span><span style="color: #5B6268;">v1 = 2</span>

<span style="color: #c678dd;">block1</span>(v3: i32, v4: i32):
    <span style="color: #51afef;">v5</span> = iadd v3, v4
    <span style="color: #51afef;">brnz</span> v4, block3
    <span style="color: #51afef;">jump</span> block2

<span style="color: #c678dd;">block2</span>:
    <span style="color: #51afef;">v7</span> = isub.i32 v5, v6  <span style="color: #5B6268;">; </span><span style="color: #5B6268;">v6 = 1</span>
    <span style="color: #51afef;">return</span> v4

<span style="color: #c678dd;">block3</span>:
    <span style="color: #51afef;">v8</span> = isub.i32 v4, v6  <span style="color: #5B6268;">; </span><span style="color: #5B6268;">v6 = 1</span>
    <span style="color: #51afef;">jump</span> block1(v5, v8)
}

</pre>
</div>



<p>
如何构建一个Function呢?
首先不必多说, <code>Function::new()</code> 创建出一个对象func. 函数在IR中被表示为控制流图, 因此要有基本块. 这可以通过func.dfg数据流图来创建出一个块: <code>func.dfg.make_block()</code>.
并使用FuncCursor将其插入到函数布局中:
</p>
<div class="org-src-container">
<pre class="src src-rust">cur.insert_block(block0)
</pre>
</div>


<p>
块由一条条指令ins构成, 每条指令是一个表达式. 指令的添加也需要借助 <code>FuncCursor</code> 来完成, 添加完成一个表达式后,返回一个代表表达式结果的值value.
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">value</span> =  {
    <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">cur</span> =  <span style="color: #ECBE7B;">FuncCursor</span>::new(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func).at_bottom(block_curr);
    cur.ins().iadd(x_value,y_value)
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">x_ssa_value</span> = cur.ins().iconst(<span style="color: #ECBE7B;">I32</span>,233);
</pre>
</div>
<p>
而这种方式显然是没有包含变量定义的, 因此当使用变量时也无法从block中获得信息.
</p>

<p>
因此需要构建SSA, 一种记录了变量定义的IR.
ssa的构建要借助SSABuilder. 使用ssa<sub>builder首先要声明当前所操作的块</sub>:
</p>
<div class="org-src-container">
<pre class="src src-rust">ssa.declare_block(block0);
</pre>
</div>

<p>
当需要记录变量定义时,
</p>
<ol class="org-ol">
<li>创建一个"变量Variable": <code>Variable::new(N)</code></li>
<li>将插入函数基本块中的指令所返回的"值Value"记录下来, 并用 <code>def_var()</code> 进行变量定义</li>
</ol>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#34920;&#31034;&#22312;&#22359;0&#20013;&#26377;&#23450;&#20041;: x_var &lt;- x_ssa_value</span>
ssa.def_var(x_var, x_ssa_value, block0);
</pre>
</div>

<p>
当遇到变量的使用时:
用 <code>def_var()</code> 从当前块出发向前寻找变量的值
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">x_value</span> = ssa.use_var(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func,x_var, <span style="color: #ECBE7B;">I32</span>, block0).0 
</pre>
</div>

<p>
当移动到下一个块时, 除了创建新块,并将它记录到函数布局中,以及在ssa中声明后,还需要在ssas中声明它的前驱块:
</p>
<div class="org-src-container">
<pre class="src src-rust">ssa.declare_block_predecessor(block1,pred_block,jump_ins);
</pre>
</div>
<p>
其中的指令是前驱块中的跳转指令.
</p>

<p>
当一个块的所有前驱块全都被构建完成后,要将该块进行"密封":
</p>
<div class="org-src-container">
<pre class="src src-rust">ssa.seal_block(block1,<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func);
</pre>
</div>

<p>
或者也可以在最后, 等到所有的block都创建完成后, 将所有的块密封:
</p>
<div class="org-src-container">
<pre class="src src-rust">ssa.seal_all_blocks(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func)
</pre>
</div>
</div>







<div id="outline-container-orgacb568b" class="outline-4">
<h4 id="orgacb568b"><span class="section-number-4">4.3.1.</span> struct Function</h4>
<div class="outline-text-4" id="text-4-3-1">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">pub</span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">Function</span> {

    <span style="color: #51afef;">pub</span> <span style="color: #dcaeea;">name</span>: <span style="color: #ECBE7B;">UserFuncName</span>, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20989;&#25968;&#21517;, &#20027;&#35201;&#26159;&#29992;&#20110;.clif&#25991;&#20214;</span>

    <span style="color: #51afef;">pub</span> <span style="color: #dcaeea;">stencil</span>: <span style="color: #ECBE7B;">FunctionStencil</span>, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20989;&#25968;&#27169;&#26495;, &#26680;&#24515;&#37096;&#20998;</span>

    <span style="color: #51afef;">pub</span> <span style="color: #dcaeea;">params</span>: <span style="color: #ECBE7B;">FunctionParameters</span>,
}
</pre>
</div>


<p>
函数模板 : 数据和布局分离!
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">pub</span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">FunctionStencil</span> {
    <span style="color: #83898d;">/// ...</span>

    <span style="color: #83898d;">/// Data flow graph containing the primary definition of all instructions, blocks and values.</span>
    <span style="color: #51afef;">pub</span> <span style="color: #dcaeea;">dfg</span>: <span style="color: #ECBE7B;">DataFlowGraph</span>, <span style="color: #5B6268;">//</span><span style="color: #5B6268;">&#30495;&#27491;&#21253;&#21547;block&#30340;&#25968;&#25454;</span>

    <span style="color: #83898d;">/// Layout of blocks and instructions in the function body.</span>
    <span style="color: #51afef;">pub</span> <span style="color: #dcaeea;">layout</span>: <span style="color: #ECBE7B;">Layout</span>, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&lt;&lt;&lt;==!!! &#35760;&#24405;&#20989;&#25968;&#20013;&#22359;&#30340;&#39034;&#24207;, &#20197;&#21450;&#25351;&#20196;&#39034;&#24207;.</span>

    <span style="color: #83898d;">/// ...</span>
}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">pub</span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">Layout</span> {
    <span style="color: #83898d;">/// Linked list nodes for the layout order of blocks Forms a doubly linked list, terminated in</span>
    <span style="color: #83898d;">/// both ends by `None`.</span>
    <span style="color: #dcaeea;">blocks</span>: <span style="color: #ECBE7B;">SecondaryMap</span>&lt;<span style="color: #ECBE7B;">Block</span>, <span style="color: #ECBE7B;">BlockNode</span>&gt;,

    <span style="color: #83898d;">/// Linked list nodes for the layout order of instructions. Forms a double linked list per block,</span>
    <span style="color: #83898d;">/// terminated in both ends by `None`.</span>
    <span style="color: #dcaeea;">insts</span>: <span style="color: #ECBE7B;">SecondaryMap</span>&lt;<span style="color: #ECBE7B;">Inst</span>, <span style="color: #ECBE7B;">InstNode</span>&gt;,

    <span style="color: #83898d;">/// First block in the layout order, or `None` when no blocks have been laid out.</span>
    <span style="color: #dcaeea;">first_block</span>: <span style="color: #ECBE7B;">Option</span>&lt;<span style="color: #ECBE7B;">Block</span>&gt;,

    <span style="color: #83898d;">/// Last block in the layout order, or `None` when no blocks have been laid out.</span>
    <span style="color: #dcaeea;">last_block</span>: <span style="color: #ECBE7B;">Option</span>&lt;<span style="color: #ECBE7B;">Block</span>&gt;,
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org6149884" class="outline-4">
<h4 id="org6149884"><span class="section-number-4">4.3.2.</span> SSABuilder: 实施ssa构造算法所需要的中间信息</h4>
<div class="outline-text-4" id="text-4-3-2">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">pub</span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">SSABuilder</span> {
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">TODO: Consider a sparse representation rather than SecondaryMap-of-SecondaryMap.</span>
    <span style="color: #83898d;">/// Records for every variable and for every relevant block, the last definition of</span>
    <span style="color: #83898d;">/// the variable in the block.</span>
    <span style="color: #dcaeea;">variables</span>: <span style="color: #ECBE7B;">SecondaryMap</span>&lt;<span style="color: #ECBE7B;">Variable</span>, <span style="color: #ECBE7B;">SecondaryMap</span>&lt;<span style="color: #ECBE7B;">Block</span>, <span style="color: #ECBE7B;">PackedOption</span>&lt;<span style="color: #ECBE7B;">Value</span>&gt;&gt;&gt;,
    <span style="color: #5B6268;">//</span><span style="color: #5B6268;">&#35760;&#24405;&#20102;&#27599;&#20010;&#22359;&#20013;&#30340;&#21464;&#37327;&#23450;&#20041;</span>

    <span style="color: #83898d;">/// Records the position of the basic blocks and the list of values used but not defined in the</span>
    <span style="color: #83898d;">/// block.</span>
    <span style="color: #dcaeea;">ssa_blocks</span>: <span style="color: #ECBE7B;">SecondaryMap</span>&lt;<span style="color: #ECBE7B;">Block</span>, <span style="color: #ECBE7B;">SSABlockData</span>&gt;, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">ssa&#31639;&#27861;&#20013;&#25152;&#38656;&#30340;&#22359;&#30340;&#20449;&#24687;</span>

    <span style="color: #83898d;">/// Call stack for use in the `use_var`/`predecessors_lookup` state machine.</span>
    <span style="color: #dcaeea;">calls</span>: <span style="color: #ECBE7B;">Vec</span>&lt;<span style="color: #ECBE7B;">Call</span>&gt;,
    <span style="color: #83898d;">/// Result stack for use in the `use_var`/`predecessors_lookup` state machine.</span>
    <span style="color: #dcaeea;">results</span>: <span style="color: #ECBE7B;">Vec</span>&lt;<span style="color: #ECBE7B;">Value</span>&gt;,

    <span style="color: #83898d;">/// Side effects accumulated in the `use_var`/`predecessors_lookup` state machine.</span>
    <span style="color: #dcaeea;">side_effects</span>: <span style="color: #ECBE7B;">SideEffects</span>,

    <span style="color: #83898d;">/// Reused allocation for blocks we've already visited in the</span>
    <span style="color: #83898d;">/// `can_optimize_var_lookup` method.</span>
    <span style="color: #dcaeea;">visited</span>: <span style="color: #ECBE7B;">HashSet</span>&lt;<span style="color: #ECBE7B;">Block</span>&gt;, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">loop? </span>
}
</pre>
</div>



<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">SSABlockData</span> {
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">The predecessors of the Block with the block and branch instruction. // &#21069;&#39537;</span>
    <span style="color: #dcaeea;">predecessors</span>: <span style="color: #ECBE7B;">PredBlockSmallVec</span>,
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">A block is sealed if all of its predecessors have been declared.&#22914;&#26524;&#19968;&#20010;&#22359;&#30340;&#25152;&#26377;&#21069;&#20219;&#37117;&#24050;&#22768;&#26126;&#65292;&#21017;&#35813;&#22359;&#23558;&#34987;&#23494;&#23553;</span>
    <span style="color: #dcaeea;">sealed</span>: <span style="color: #ECBE7B;">bool</span>,
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">List of current Block arguments for which an earlier def has not been found yet.</span>
    <span style="color: #dcaeea;">undef_variables</span>: <span style="color: #ECBE7B;">Vec</span>&lt;(<span style="color: #ECBE7B;">Variable</span>, <span style="color: #ECBE7B;">Value</span>)&gt;,
}
</pre>
</div>
</div>
</div>



<div id="outline-container-org87361fb" class="outline-4">
<h4 id="org87361fb"><span class="section-number-4">4.3.3.</span> 继续 <code>program_with_loop()</code></h4>
<div class="outline-text-4" id="text-4-3-3">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">func</span> = <span style="color: #ECBE7B;">Function</span>::new();
<span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">ssa</span> = <span style="color: #ECBE7B;">SSABuilder</span>::new();
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">block0</span> = func.dfg.make_block();
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">block1</span> = func.dfg.make_block();
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">block2</span> = func.dfg.make_block();
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">block3</span> = func.dfg.make_block();
</pre>
</div>

<p>
真正创建构成了函数的4个block.
</p>
</div>


<ol class="org-ol">
<li><a id="org9306e6a"></a><code>declare_block</code><br />
<div class="outline-text-5" id="text-4-3-3-1">
<p>
创建在ssa构建中所需的块信息的结构: 
</p>
<div class="org-src-container">
<pre class="src src-rust">ssa.declare_block(blockN)

<span style="color: #51afef;">pub</span> <span style="color: #51afef;">fn</span> <span style="color: #c678dd;">declare_block</span>(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #51afef;">self</span>, <span style="color: #dcaeea;">block</span>: <span style="color: #ECBE7B;">Block</span>) {
    <span style="color: #51afef;">self</span>.ssa_blocks[block] = <span style="color: #ECBE7B;">SSABlockData</span> {
        <span style="color: #dcaeea;">predecessors</span>: <span style="color: #ECBE7B;">PredBlockSmallVec</span>::new(), <span style="color: #83898d;">/// &#21069;&#39537;</span>
        <span style="color: #dcaeea;">sealed</span>: <span style="color: #51afef;">false</span>,  <span style="color: #83898d;">/// &#26159;&#21542;seal</span>
        <span style="color: #dcaeea;">undef_variables</span>: <span style="color: #ECBE7B;">Vec</span>::new(), <span style="color: #83898d;">/// &#23578;&#26410;&#33021;&#25214;&#21040;&#23450;&#20041;&#30340;&#21464;&#37327;</span>
    };
}      
</pre>
</div>
</div>
</li>

<li><a id="org76eacdd"></a>block0:<br />
<div class="outline-text-5" id="text-4-3-3-2">
<p>
block0:
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">block0</span>
ssa.declare_block(block0);
ssa.seal_block(block0, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27809;&#26377;&#21069;&#39537;, &#31435;&#21363;seal</span>
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">x_var</span> = <span style="color: #ECBE7B;">Variable</span>::new(0);
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">x1</span> = {
    <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">cur</span> = <span style="color: #ECBE7B;">FuncCursor</span>::new(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func).at_bottom(block0);
    cur.ins().iconst(<span style="color: #ECBE7B;">I32</span>, 1)  <span style="color: #5B6268;">//</span><span style="color: #5B6268;">&#20026;&#20989;&#25968;&#22312;block0&#20013;&#29983;&#25104;&#25351;&#20196; x = 1</span>
};
ssa.def_var(x_var, x1, block0); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22312;ssa&#20013;&#35760;&#24405; x &#30340;&#23450;&#20041;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">y_var</span> = <span style="color: #ECBE7B;">Variable</span>::new(1);
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">y1</span> = {
    <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">cur</span> = <span style="color: #ECBE7B;">FuncCursor</span>::new(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func).at_bottom(block0);
    cur.ins().iconst(<span style="color: #ECBE7B;">I32</span>, 2)
};
ssa.def_var(y_var, y1, block0);
</pre>
</div>


<p>
调用use<sub>var从当前块开始寻找变量的定义</sub> 
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">z_var</span> = <span style="color: #ECBE7B;">Variable</span>::new(2);
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">x2</span> = ssa.use_var(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func, x_var, <span style="color: #ECBE7B;">I32</span>, block0).0;
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">y2</span> = ssa.use_var(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func, y_var, <span style="color: #ECBE7B;">I32</span>, block0).0;
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">z1</span> = {
    <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">cur</span> = <span style="color: #ECBE7B;">FuncCursor</span>::new(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func).at_bottom(block0);
    cur.ins().iadd(x2, y2) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#29983;&#25104; z = x+y &#25351;&#20196;</span>
};
ssa.def_var(z_var, z1, block0); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22312;ssa&#20013;&#35760;&#24405;z&#22312;&#27492;&#22359;&#20013;&#30340;&#23450;&#20041;</span>
</pre>
</div>

<p>
对应于 <code>jump block1</code> : 
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">jump_block0_block1</span> = {
    <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">cur</span> = <span style="color: #ECBE7B;">FuncCursor</span>::new(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func).at_bottom(block0);
    cur.ins().jump(block1, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span>[])
};
</pre>
</div>
</div>
</li>

<li><a id="org634c644"></a>block1:<br />
<div class="outline-text-5" id="text-4-3-3-3">
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #c678dd;">block1</span>:
          <span style="color: #51afef;">z</span> = z + y<span style="color: #5B6268;">;</span>
          <span style="color: #51afef;">brnz</span> y, block3<span style="color: #5B6268;">;</span>
          <span style="color: #51afef;">jump</span> block2<span style="color: #5B6268;">;</span>
</pre>
</div>

<p>
首先为ssa构建创建关于block1的信息的结构, 然后声明从block0可以通过上面的jump指令跳转到block1.
</p>
<div class="org-src-container">
<pre class="src src-rust">ssa.declare_block(block1);
ssa.declare_block_predecessor(block1, block0, jump_block0_block1);
</pre>
</div>
<p>
因为 block3也会跳到block1,因此它目前还不能标记为sealed.
</p>

<p>
然后处理块中指令: 先利用ssa找出使用的变量的值, 然后为函数生成代码,最后再用ssa记录变量的定义. 
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">z2</span> = ssa.use_var(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func, z_var, <span style="color: #ECBE7B;">I32</span>, block1).0;
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">y3</span> = ssa.use_var(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func, y_var, <span style="color: #ECBE7B;">I32</span>, block1).0;
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">z3</span> = {
    <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">cur</span> = <span style="color: #ECBE7B;">FuncCursor</span>::new(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func).at_bottom(block1);
    cur.ins().iadd(z2, y3)
};
ssa.def_var(z_var, z3, block1);
</pre>
</div>

<p>
接下来是brnz: 
</p>
<div class="org-src-container">
<pre class="src src-rust">brnz y, block3;
</pre>
</div>
<p>
若y不为0 ,则跳到block3 :
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">y4</span> = ssa.use_var(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func, y_var, <span style="color: #ECBE7B;">I32</span>, block1).0;

<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">brnz_block1_block3</span> = {
    <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">cur</span> = <span style="color: #ECBE7B;">FuncCursor</span>::new(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func).at_bottom(block1);
    cur.ins().brnz(y4, block3, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span>[])
};
</pre>
</div>

<p>
然后是 <code>jump block2</code> :
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">jump_block1_block2</span> = {
    <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">cur</span> = <span style="color: #ECBE7B;">FuncCursor</span>::new(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func).at_bottom(block1);
    cur.ins().jump(block2, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span>[])
};
</pre>
</div>
</div>
</li>

<li><a id="org5754a51"></a>block2<br />
<div class="outline-text-5" id="text-4-3-3-4">
<p>
紧接着是
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #c678dd;">block2</span>:
          <span style="color: #51afef;">z</span> = z - x<span style="color: #5B6268;">;</span>
          <span style="color: #51afef;">return</span> y
</pre>
</div>

<p>
仍然是 declare<sub>block</sub> + declare<sub>block</sub><sub>predecessor</sub>
</p>
<div class="org-src-container">
<pre class="src src-rust">ssa.declare_block(block2);
ssa.declare_block_predecessor(block2, block1, jump_block1_block2);
</pre>
</div>

<p>
并且,它的唯一前驱就是block1,因此可以被sealed.
</p>
<div class="org-src-container">
<pre class="src src-rust">ssa.seal_block(block2, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func);
</pre>
</div>

<p>
翻译 <code>z = z - x</code>
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">z4</span> = ssa.use_var(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func, z_var, <span style="color: #ECBE7B;">I32</span>, block2).0; <span style="color: #83898d;">/// z </span>

<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">x3</span> = ssa.use_var(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func, x_var, <span style="color: #ECBE7B;">I32</span>, block2).0; <span style="color: #83898d;">/// x </span>
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">z5</span> = {
    <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">cur</span> = <span style="color: #ECBE7B;">FuncCursor</span>::new(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func).at_bottom(block2);
    cur.ins().isub(z4, x3) <span style="color: #83898d;">/// z - x </span>
};
ssa.def_var(z_var, z5, block2); <span style="color: #83898d;">/// z = ...</span>
</pre>
</div>

<p>
生成 <code>return y</code>
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">y5</span> = ssa.use_var(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func, y_var, <span style="color: #ECBE7B;">I32</span>, block2).0;

{
    <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">cur</span> = <span style="color: #ECBE7B;">FuncCursor</span>::new(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func).at_bottom(block2);
    cur.ins().return_(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span>[y5])
};
</pre>
</div>
</div>
</li>


<li><a id="org3f16e4d"></a>block3<br />
<div class="outline-text-5" id="text-4-3-3-5">
<p>
下面处理block3, 因为在block1中有 <code>brnz y block3</code> 因此block1是其前驱.并且是其唯一前驱.
</p>

<div class="org-src-container">
<pre class="src src-rust">ssa.declare_block(block3);
ssa.declare_block_predecessor(block3, block1, brnz_block1_block3);

ssa.seal_block(block3, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func);
</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #c678dd;">block3</span>:
          <span style="color: #51afef;">y</span> = y - x
          <span style="color: #51afef;">jump</span> block1
</pre>
</div>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #83898d;">/// y = y - x</span>
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">y6</span> = ssa.use_var(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func, y_var, <span style="color: #ECBE7B;">I32</span>, block3).0;

<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">x4</span> = ssa.use_var(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func, x_var, <span style="color: #ECBE7B;">I32</span>, block3).0;

<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">y7</span> = {
    <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">cur</span> = <span style="color: #ECBE7B;">FuncCursor</span>::new(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func).at_bottom(block3);
    cur.ins().isub(y6, x4)
};
ssa.def_var(y_var, y7, block3);
</pre>
</div>



<div class="org-src-container">
<pre class="src src-rust"><span style="color: #83898d;">/// jump block1</span>
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">jump_block3_block1</span> = {
       <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">cur</span> = <span style="color: #ECBE7B;">FuncCursor</span>::new(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func).at_bottom(block3);
       cur.ins().jump(block1, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span>[])
   };
</pre>
</div>
</div>
</li>

<li><a id="org3a9a81f"></a>seal block1<br />
<div class="outline-text-5" id="text-4-3-3-6">
<p>
现在block1的所有前驱已经处理完了,
</p>
<div class="org-src-container">
<pre class="src src-rust">ssa.declare_block_predecessor(block1, block3, jump_block3_block1);
ssa.seal_block(block1, <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> func);
</pre>
</div>

<p>
接下来我们研究最后一个 <code>seal_block</code> 究竟做了什么?
</p>

<p>
首先 对于block1, 它是编号为1的Block结构.
</p>

<p>
此函数返回一个副作用结构.
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">pub</span> <span style="color: #51afef;">fn</span> <span style="color: #c678dd;">seal_block</span>(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #51afef;">self</span>, <span style="color: #dcaeea;">block</span>: <span style="color: #ECBE7B;">Block</span>, <span style="color: #dcaeea;">func</span>: <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #ECBE7B;">Function</span>) -&gt; <span style="color: #ECBE7B;">SideEffects</span> {
    <span style="color: #51afef;">self</span>.seal_one_block(block, func);
    <span style="color: #a9a1e1;">mem</span>::replace(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #51afef;">self</span>.side_effects, <span style="color: #ECBE7B;">SideEffects</span>::new())
}
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org3c118a1"></a><code>seal_one_block()</code><br />
<ol class="org-ol">
<li><a id="orgc510d3d"></a>对当前块中每个未定义变量执行 <code>predecessors_lookup()</code><br />
<div class="outline-text-7" id="text-4-3-3-6-1-1">
<p>
进入到: 
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">fn</span> <span style="color: #c678dd;">seal_one_block</span>(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #51afef;">self</span>, <span style="color: #dcaeea;">block</span>: <span style="color: #ECBE7B;">Block</span>, <span style="color: #dcaeea;">func</span>: <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #ECBE7B;">Function</span>) {
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">block_data</span> = <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #51afef;">self</span>.ssa_blocks[block];
    <span style="color: #83898d;">/// ...</span>
</pre>
</div>

<p>
block1的blockdata: 
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #dcaeea;">predecessors</span>: <span style="color: #ECBE7B;">PredBlockSmallVec</span>,<span style="color: #83898d;">/// block0, block3</span>

<span style="color: #dcaeea;">sealed</span>: <span style="color: #ECBE7B;">bool</span>, <span style="color: #83898d;">/// &#20540;&#20026;&#20551;</span>

<span style="color: #dcaeea;">undef_variables</span>: <span style="color: #ECBE7B;">Vec</span>&lt;(<span style="color: #ECBE7B;">Variable</span>, <span style="color: #ECBE7B;">Value</span>)&gt;,
<span style="color: #83898d;">/// z(2)=3, y(1)=4, x(0)=6,</span>
</pre>
</div>

<p>
继续:
</p>
<div class="org-src-container">
<pre class="src src-rust">  <span style="color: #83898d;">/// ...</span>
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Extract the undef_variables data from the block so that we</span>
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">can iterate over it without borrowing the whole builder.</span>
  <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">undef_vars</span> = <span style="color: #a9a1e1;">mem</span>::replace(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> block_data.undef_variables, <span style="color: #ECBE7B;">Vec</span>::new());

  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">For each undef var we look up values in the predecessors and create a block parameter</span>
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">only if necessary.</span>
  <span style="color: #51afef;">for</span> (var, val) <span style="color: #51afef;">in</span> undef_vars {
      <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">ty</span> = func.dfg.value_type(val);
      <span style="color: #51afef;">self</span>.predecessors_lookup(func, val, var, ty, block);
  }
  <span style="color: #51afef;">self</span>.mark_block_sealed(block);
}
</pre>
</div>

<p>
<code>z(2) = 3</code>
</p>
</div>
</li>

<li><a id="org9c931ef"></a><code>predecessors_lookup()</code><br />
<div class="outline-text-7" id="text-4-3-3-6-1-2">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">self</span>.predecessors_lookup(func, val, var, ty, block);
</pre>
</div>

<p>
其实现为: 
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">self</span>.begin_predecessors_lookup(value=3, block1 );
<span style="color: #51afef;">self</span>.run_state_machine(func, z(2) , ty)
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org9ad8c54"></a><code>begin_predecessors_lookup()</code> 将块的前驱压入调用栈<br />
<div class="outline-text-8" id="text-4-3-3-6-1-2-1">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">fn</span> <span style="color: #c678dd;">begin_predecessors_lookup</span>(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #51afef;">self</span>, <span style="color: #dcaeea;">sentinel</span>: <span style="color: #ECBE7B;">Value</span>, <span style="color: #dcaeea;">dest_block</span>: <span style="color: #ECBE7B;">Block</span>) {
    <span style="color: #51afef;">self</span>.calls
        .push(<span style="color: #ECBE7B;">Call</span>::<span style="color: #ECBE7B;">FinishPredecessorsLookup</span>(sentinel=3, dest_block=block1));
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Iterate over the predecessors.</span>
    <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">calls</span> = <span style="color: #a9a1e1;">mem</span>::replace(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #51afef;">self</span>.calls, <span style="color: #ECBE7B;">Vec</span>::new());
    calls.extend(
        <span style="color: #51afef;">self</span>.predecessors(dest_block)
            .iter()
            .rev()
            .map(|<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #ECBE7B;">PredBlock</span> { <span style="color: #dcaeea;">block</span>: pred, .. }| <span style="color: #ECBE7B;">Call</span>::<span style="color: #ECBE7B;">UseVar</span>(pred)),
    );
    <span style="color: #51afef;">self</span>.calls = calls;
}
</pre>
</div>

<p>
<code>self.calls</code> :
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Call::UseVar(block0)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Call::UseVar(block3)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Call::FinishPredecessorsLookup(val=3,block1)</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="org8026793"></a><code>run_state_machine()</code> 开始<br />
<ol class="org-ol">
<li><a id="orgdd38df7"></a>UseVar(): 在当前块中寻找,找不到则为前驱安排查找任务<br />
<div class="outline-text-9" id="text-4-3-3-6-1-2-2-1">
<p>
准备好任务栈后, 正式由下面的方法来执行. 此时入参var 表示变量z(2)
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">fn</span> <span style="color: #c678dd;">run_state_machine</span>(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #51afef;">self</span>, <span style="color: #dcaeea;">func</span>: <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #ECBE7B;">Function</span>, <span style="color: #dcaeea;">var</span>: <span style="color: #ECBE7B;">Variable</span>, <span style="color: #dcaeea;">ty</span>: <span style="color: #ECBE7B;">Type</span>) -&gt; <span style="color: #ECBE7B;">Value</span> 
</pre>
</div>

<p>
核心逻辑是用while不断从calls栈中弹出任务:
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">while</span> <span style="color: #51afef;">let</span> <span style="color: #ECBE7B;">Some</span>(call) = <span style="color: #51afef;">self</span>.calls.pop() {
    <span style="color: #ECBE7B;">Call</span>::<span style="color: #ECBE7B;">UseVar</span>(ssa_block) =&gt; {
        <span style="color: #83898d;">///...</span>
    },
    <span style="color: #ECBE7B;">Call</span>::<span style="color: #ECBE7B;">FinishSealedOnePredecessor</span>(ssa_block) =&gt; {
        <span style="color: #83898d;">///...</span>
    },
    <span style="color: #ECBE7B;">Call</span>::<span style="color: #ECBE7B;">FinishPredecessorsLookup</span>(sentinel, dest_block) =&gt; {
        <span style="color: #83898d;">///...</span>
    },
}
</pre>
</div>

<p>
按照之前画出的调用栈:
</p>

<p>
首先取出的元素是 <code>Call::UseVar(block0)</code>, 先尝试从当前块block0中找到z的定义,找到终止此次循环.否则尝试用 <code>use_var_nonlocal</code> 从前驱中继续寻找.
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ECBE7B;">Call</span>::<span style="color: #ECBE7B;">UseVar</span>(block0) =&gt; {
    <span style="color: #51afef;">if</span> <span style="color: #51afef;">let</span> <span style="color: #ECBE7B;">Some</span>(var_defs) = <span style="color: #51afef;">self</span>.variables.get(&#21464;&#37327;z) {
        <span style="color: #51afef;">if</span> <span style="color: #51afef;">let</span> <span style="color: #ECBE7B;">Some</span>(val) = var_defs[block0].expand() {
            <span style="color: #51afef;">self</span>.results.push(val);
            <span style="color: #51afef;">continue</span>;
        }
    }
    <span style="color: #51afef;">self</span>.use_var_nonlocal(func, var, ty, block0);
}
</pre>
</div>
<p>
这里能在block0中找到z的定义, 因此提前跳出.
</p>

<p>
下一次从calls中取出的是 <code>Call::UseVar(block3)</code>, 这次不能在block3本身中找到z的定义,因此要借助 <code>use_var_nonlocal</code> 向calls中压入新任务, 用来到block3的前驱中寻找z的定义.
</p>
</div>
</li>

<li><a id="org3a8f384"></a><code>use_var_nonlocal()</code> 将前驱作为任务压入调用栈<br />
<div class="outline-text-9" id="text-4-3-3-6-1-2-2-2">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">fn</span> <span style="color: #c678dd;">use_var_nonlocal</span>(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #51afef;">self</span>, <span style="color: #dcaeea;">func</span>: <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #ECBE7B;">Function</span>, <span style="color: #dcaeea;">var</span>: <span style="color: #ECBE7B;">Variable</span>, <span style="color: #dcaeea;">ty</span>: <span style="color: #ECBE7B;">Type</span>, <span style="color: #dcaeea;">block</span>: <span style="color: #ECBE7B;">Block</span>)
    <span style="color: #83898d;">/// var == z</span>
    <span style="color: #83898d;">/// block == block3</span>
</pre>
</div>



<p>
此函数被特意的分成两段,主要是为了不触犯借用规则.
第一部分返回一个值作为flag来指导第二部分的走向.
</p>
</div>

<ol class="org-ol">
<li><a id="orga4fb7bb"></a>Part1<br />
<div class="outline-text-10" id="text-4-3-3-6-1-2-2-2-1">
<p>
case指示了当前块能否继续向回查找(seal?)
或是此块是否有多个前驱
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">optimize_var_lookup</span> = <span style="color: #51afef;">self</span>.can_optimize_var_lookup(block);
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">data</span> = <span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #51afef;">self</span>.ssa_blocks[block];

<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">case</span> = <span style="color: #51afef;">if</span> data.sealed { <span style="color: #83898d;">/// &#27492;&#33410;&#28857;&#30340;&#25152;&#26377;&#21069;&#39537;&#26159;&#21542;&#24050;&#32463;&#26500;&#36896;&#23436;&#25104;?</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Optimize the common case of one predecessor: no param needed.</span>
    <span style="color: #51afef;">if</span> optimize_var_lookup { <span style="color: #83898d;">/// &#27492;&#33410;&#28857;&#21482;&#26377;&#19968;&#20010;&#21069;&#39537;,&#19988;&#35813;&#21069;&#39537;&#19981;&#22788;&#20110;&#29615;&#20013;</span>
        <span style="color: #ECBE7B;">UseVarCases</span>::<span style="color: #ECBE7B;">SealedOnePredecessor</span>(data.predecessors[0].block)
    } <span style="color: #51afef;">else</span> { <span style="color: #83898d;">/// &#22810;&#20010;&#21069;&#39537;</span>
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Break potential cycles by eagerly adding an operandless param.</span>
        <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">val</span> = func.dfg.append_block_param(block, ty);
        <span style="color: #ECBE7B;">UseVarCases</span>::<span style="color: #ECBE7B;">SealedMultiplePredecessors</span>(val, block)
    }
} <span style="color: #51afef;">else</span> { <span style="color: #83898d;">/// &#20173;&#26377;&#21069;&#39537;&#23578;&#26410;&#26500;&#36896;&#23436;&#25104;,&#27492;&#21464;&#37327;&#30340;&#23450;&#20041;&#19981;&#33021;&#26597;&#25214;</span>
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">val</span> = func.dfg.append_block_param(block, ty);
    data.undef_variables.push((var, val)); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23558;&#36825;&#20010;&#22359;&#20013;&#23578;&#19981;&#33021;&#25214;&#21040;&#23450;&#20041;&#30340;</span>
    <span style="color: #ECBE7B;">UseVarCases</span>::<span style="color: #ECBE7B;">Unsealed</span>(val)
};
</pre>
</div>
</div>
</li>

<li><a id="org8612b1c"></a><code>can_optimize_var_lookup()</code>: 只有一个前驱,且前驱不在环中<br />
<div class="outline-text-10" id="text-4-3-3-6-1-2-2-2-2">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #83898d;">///  &#36820;&#22238;true: block&#21482;&#33021;&#26377;&#19968;&#20010;&#21069;&#39537;,&#19988;&#23427;&#19981;&#22788;&#22312;&#19968;&#20010;&#29615;&#20013;.</span>
<span style="color: #83898d;">///  &#29992;visited: HashSet&lt;Block&gt; &#23454;&#29616;&#26377;&#26080;&#29615;&#26816;&#27979;</span>

  <span style="color: #51afef;">fn</span> <span style="color: #c678dd;">can_optimize_var_lookup</span>(<span style="color: #bbc2cf; background-color: #282c34;">&amp;</span><span style="color: #51afef;">mut</span> <span style="color: #51afef;">self</span>, <span style="color: #dcaeea;">block</span>: <span style="color: #ECBE7B;">Block</span>) -&gt; <span style="color: #ECBE7B;">bool</span> {
      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Check that the initial block only has one predecessor. This is only a requirement</span>
      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">for the first block.</span>
      <span style="color: #51afef;">if</span> <span style="color: #51afef;">self</span>.predecessors(block).len() != 1 {
          <span style="color: #51afef;">return</span> <span style="color: #51afef;">false</span>;
      }

      <span style="color: #51afef;">self</span>.visited.clear(); <span style="color: #83898d;">/// &#32622;&#20026;&#31354;</span>
      <span style="color: #51afef;">let</span> <span style="color: #51afef;">mut</span> <span style="color: #dcaeea;">current</span> = block;

      <span style="color: #51afef;">loop</span> {
          <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">predecessors</span> = <span style="color: #51afef;">self</span>.predecessors(current);

          <span style="color: #5B6268;">// </span><span style="color: #5B6268;">We haven't found the original block and we have either reached the entry</span>
          <span style="color: #5B6268;">// </span><span style="color: #5B6268;">block, or we found the end of this line of dead blocks, either way we are</span>
          <span style="color: #5B6268;">// </span><span style="color: #5B6268;">safe to optimize this line of lookups.</span>
          <span style="color: #51afef;">if</span> predecessors.len() == 0 {
              <span style="color: #51afef;">return</span> <span style="color: #51afef;">true</span>;
          }

          <span style="color: #5B6268;">// </span><span style="color: #5B6268;">We can stop the search here, the algorithm can handle these cases, even if they are</span>
          <span style="color: #5B6268;">// </span><span style="color: #5B6268;">in an undefined island.</span>
          <span style="color: #51afef;">if</span> predecessors.len() &gt; 1 {
              <span style="color: #51afef;">return</span> <span style="color: #51afef;">true</span>;
          }

          <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">next_current</span> = predecessors[0].block;
          <span style="color: #51afef;">if</span> !<span style="color: #51afef;">self</span>.visited.insert(current) { <span style="color: #83898d;">/// &#23558;&#24403;&#21069;&#33410;&#28857;&#25554;&#20837;,&#33509;&#36820;&#22238;false,&#21017;&#20195;&#34920;&#37325;&#22797;&#25554;&#20837;.</span>
              <span style="color: #51afef;">return</span> <span style="color: #51afef;">false</span>;
          }
          current = next_current;
      }
  }
</pre>
</div>
</div>
</li>

<li><a id="org173cbcc"></a><code>append_block_param(block, ty)</code><br /></li>

<li><a id="org45c9879"></a>Part2<br /></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
</div>
</div>
</div>
</body>
</html>
