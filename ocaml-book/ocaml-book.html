<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OCaml 杂记</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="../org-html-themes/src/bigblow_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../org-html-themes/src/bigblow_theme/css/bigblow.css"/>
<link rel="stylesheet" type="text/css" href="../org-html-themes/src/bigblow_theme/css/hideshow.css"/>
<script type="text/javascript" src="../org-html-themes/src/bigblow_theme/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../org-html-themes/src/bigblow_theme/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="../org-html-themes/src/bigblow_theme/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="../org-html-themes/src/bigblow_theme/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="../org-html-themes/src/bigblow_theme/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../org-html-themes/src/bigblow_theme/js/bigblow.js"></script>
<script type="text/javascript" src="../org-html-themes/src/bigblow_theme/js/hideshow.js"></script>
<script type="text/javascript" src="../org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">OCaml 杂记</h1>



<div id="outline-container-org28f1d31" class="outline-2">
<h2 id="org28f1d31">CS3110 练习题</h2>
<div class="outline-text-2" id="text-org28f1d31">
<ul class="org-ul">
<li><a href="./ch2/ex.html">Ch2</a></li>
<li><a href="./ch3/exercises.html">Ch3</a></li>
<li><a href="./ch4/ex.html">Ch4</a></li>
<li><a href="./ch5/ex.html">Ch5</a></li>
</ul>
</div>
</div>


<div id="outline-container-org8310103" class="outline-2">
<h2 id="org8310103">opam包管理器</h2>
<div class="outline-text-2" id="text-org8310103">
<p>
<code>opam install XX</code>
</p>

<div class="org-src-container">
<pre class="src src-sh">opam install -y utop odoc ounit2 qcheck bisect_ppx menhir ocaml-lsp-server ocamlformat ocamlformat-rpc
</pre>
</div>
</div>
</div>


<div id="outline-container-orgb07dafd" class="outline-2">
<h2 id="orgb07dafd">utop交互式解释器</h2>
<div class="outline-text-2" id="text-orgb07dafd">
<p>
每次启动utop都会自动加载 <code>.ocamlinit</code> 文件，它会自动执行脚本，
使得不用每次都手动加载库
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f0e68c;">#</span>use <span style="color: #7bc275;">"topfind"</span><span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">#</span>thread<span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">#</span>require <span style="color: #7bc275;">"core.top"</span><span style="color: #ff4500;">;;</span>

</pre>
</div>
</div>

<div id="outline-container-orge1c5716" class="outline-3">
<h3 id="orge1c5716">Exit utop</h3>
<div class="outline-text-3" id="text-orge1c5716">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f0e68c;">#</span>quit<span style="color: #ff4500;">;;</span> 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #C57BDB;">exit</span> 0<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org3e8f3ad" class="outline-2">
<h2 id="org3e8f3ad">配置Emacs支持ocaml | Configure EMACS supports Ocaml</h2>
<div class="outline-text-2" id="text-org3e8f3ad">
<div class="org-src-container">
<pre class="src src-ocaml">opam install tuareg ocp<span style="color: #f0e68c;">-</span>indent merlin
opam install user<span style="color: #f0e68c;">-</span>setup
opam user<span style="color: #f0e68c;">-</span>setup install
</pre>
</div>
</div>
</div>


<div id="outline-container-org7d85d1b" class="outline-2">
<h2 id="org7d85d1b">编译ocamlc</h2>
<div class="outline-text-2" id="text-org7d85d1b">
<div class="org-src-container">
<pre class="src src-sh">ocamlc -o test.byte test.ml 
</pre>
</div>
<p>
这和gcc类似，不同的是它还会产生中间文件： <code>test.cmi test.cmo</code>
</p>
</div>


<div id="outline-container-orgb210028" class="outline-3">
<h3 id="orgb210028">main()函数？</h3>
<div class="outline-text-3" id="text-orgb210028">
<p>
ocaml中没有专门的main函数，文件（指的是dune中name命令指定的那个）中最后一个函数定义将作为整个程序的入口。
</p>
</div>
</div>

<div id="outline-container-orga492a58" class="outline-3">
<h3 id="orga492a58">构建系统Dune</h3>
<div class="outline-text-3" id="text-orga492a58">
<ul class="org-ul">
<li><p>
用dune创建项目根目录 Create a project root directory with dune
</p>
<div class="org-src-container">
<pre class="src src-sh">dune init project dirname
</pre>
</div></li>

<li><p>
create a file named dune in the project root directory
</p>

<div class="org-src-container">
<pre class="src src-elisp">(executable
  (name XX) <span style="color: #62686E;">;;</span><span style="color: #62686E;">XX&#20026;main&#20989;&#25968;&#25152;&#22312;&#25991;&#20214;&#30340;&#21517;&#23383;</span>
  <span style="color: #62686E;">;;</span><span style="color: #62686E;">(libraries yyy) ;; eg: ounit2</span>
  )
</pre>
</div></li>

<li><p>
Generate executable file
</p>

<div class="org-src-container">
<pre class="src src-sh">dune build XX.exe 
</pre>
</div></li>

<li><p>
run project
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #62686E;"># </span><span style="color: #62686E;">Manually</span>
./_build/default/XX.exe

<span style="color: #62686E;"># </span><span style="color: #62686E;">automatic</span>
dune exec ./XX.exe
</pre>
</div></li>

<li><p>
Clean up the _build directory
</p>
<div class="org-src-container">
<pre class="src src-sh">dune clean <span style="color: #62686E;"># </span><span style="color: #62686E;">remove the _build directory </span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>




<div id="outline-container-org190ad5c" class="outline-2">
<h2 id="org190ad5c">ocaml的显著差别</h2>
<div class="outline-text-2" id="text-org190ad5c">
</div>
<div id="outline-container-org5235a62" class="outline-3">
<h3 id="org5235a62">递归函数要用 <code>rec</code> 标记</h3>
<div class="outline-text-3" id="text-org5235a62">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">append</span><span style="color: #DFDFDF;"> lst1 lst2</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">match</span> lst1 <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> lst2
  <span style="color: #f0e68c;">|</span> h <span style="color: #f0e68c;">::</span> t <span style="color: #f0e68c;">-&gt;</span> h <span style="color: #f0e68c;">::</span> <span style="color: #f0e68c;">(</span>append t lst2 <span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org74e3447" class="outline-3">
<h3 id="org74e3447">严格区分整数和浮点数的运算：</h3>
<div class="outline-text-3" id="text-org74e3447">
<p>
int： <code>0 + - * /  abs</code> 
</p>

<p>
float:  ~0. +. -. *. /. ~
</p>
</div>
</div>


<div id="outline-container-org0095d73" class="outline-3">
<h3 id="org0095d73">连接字符串: 用 <code>^</code></h3>
<div class="outline-text-3" id="text-org0095d73">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #7bc275;">"hello"</span> <span style="color: #f0e68c;">^</span> <span style="color: #7bc275;">"world"</span> 
</pre>
</div>
</div>
</div>


<div id="outline-container-orgccb77ce" class="outline-3">
<h3 id="orgccb77ce">带类型注释的函数定义</h3>
<div class="outline-text-3" id="text-orgccb77ce">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">func</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">a</span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;">int</span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">b</span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> float</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">string</span><span style="color: #62686E;">(*</span><span style="color: #62686E;">&#36820;&#22238;&#20540;</span><span style="color: #62686E;">*)</span> <span style="color: #f0e68c;">=</span>
 <span style="color: #f0e68c;">...</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org4d3d6e6" class="outline-2">
<h2 id="org4d3d6e6">let 不是表达式</h2>
<div class="outline-text-2" id="text-org4d3d6e6">
<div class="org-src-container">
<pre class="src src-ocaml">
utop <span style="color: #f0e68c;">#</span> <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">=</span> 3<span style="color: #ff4500;">;;</span>
<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">x</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 3

utop <span style="color: #f0e68c;">#</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">x y</span> <span style="color: #f0e68c;">-&gt;</span> x <span style="color: #f0e68c;">*</span> y<span style="color: #f0e68c;">)</span><span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&lt;</span><span style="color: #51afef;">fun</span><span style="color: #f0e68c;">&gt;</span>

utop <span style="color: #f0e68c;">#</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">x y</span> <span style="color: #f0e68c;">-&gt;</span> x <span style="color: #f0e68c;">*</span> y<span style="color: #f0e68c;">)</span> 4 5<span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 20

utop <span style="color: #f0e68c;">#</span> <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">multf</span><span style="color: #DFDFDF;"> x y</span> <span style="color: #f0e68c;">=</span> x <span style="color: #f0e68c;">*.</span> y<span style="color: #ff4500;">;;</span>
<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">multf</span> <span style="color: #f0e68c;">:</span> float <span style="color: #f0e68c;">-&gt;</span> float <span style="color: #f0e68c;">-&gt;</span> float <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&lt;</span><span style="color: #51afef;">fun</span><span style="color: #f0e68c;">&gt;</span>

utop <span style="color: #f0e68c;">#</span> multf 1. 4.<span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> float <span style="color: #f0e68c;">=</span> 4.
</pre>
</div>
</div>
</div>

<div id="outline-container-org7ac6da3" class="outline-2">
<h2 id="org7ac6da3">let &#x2026; in &#x2026;表达式</h2>
<div class="outline-text-2" id="text-org7ac6da3">
<p>
在utop环境下，所有的let定义都会被转化成层层嵌套的let..in..表达式。
因此在表面上好像是支持了改变变量的值。
</p>


<p>
There must be parentheses here:
</p>
<div class="org-src-container">
<pre class="src src-ocaml">utop <span style="color: #f0e68c;">#</span> <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">a</span> <span style="color: #f0e68c;">=</span> 19 <span style="color: #f5deb3; font-weight: bold;">in</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">-&gt;</span> x <span style="color: #f0e68c;">+</span> a<span style="color: #f0e68c;">)</span>  19<span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 38
</pre>
</div>


<p>
本质上在ocaml中不存在多参函数，所谓的多参函数只是语法糖：
</p>

<div class="org-src-container">
<pre class="src src-ocaml">utop <span style="color: #f0e68c;">#</span> <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">multargs</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">y</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span> <span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">z</span> <span style="color: #f0e68c;">-&gt;</span> x<span style="color: #f0e68c;">+</span>y<span style="color: #f0e68c;">+</span>z <span style="color: #f0e68c;">))</span> <span style="color: #ff4500;">;;</span>
<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">multargs</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&lt;</span><span style="color: #51afef;">fun</span><span style="color: #f0e68c;">&gt;</span>

utop <span style="color: #f0e68c;">#</span> multargs 1 2 3 <span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 6

utop <span style="color: #f0e68c;">#</span> <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">same_as_multargs</span><span style="color: #DFDFDF;"> x y z</span> <span style="color: #f0e68c;">=</span> x<span style="color: #f0e68c;">+</span>y<span style="color: #f0e68c;">+</span>z <span style="color: #ff4500;">;;</span>
<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">same_as_multargs</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&lt;</span><span style="color: #51afef;">fun</span><span style="color: #f0e68c;">&gt;</span>

utop <span style="color: #f0e68c;">#</span> same_as_multargs 1 2 3<span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 6
</pre>
</div>



<p>
范型：带撇的类型名 'a  'b 
</p>
<div class="org-src-container">
<pre class="src src-ocaml">utop <span style="color: #f0e68c;">#</span> <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">foo</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">fun</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">n </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> int </span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">x </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> 'a</span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">y </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> 'a</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span>  <span style="color: #51afef;">if</span> n <span style="color: #f0e68c;">&gt;</span> 0 <span style="color: #51afef;">then</span> x <span style="color: #51afef;">else</span> y <span style="color: #ff4500;">;;</span>
<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">foo</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&lt;</span><span style="color: #51afef;">fun</span><span style="color: #f0e68c;">&gt;</span>

utop <span style="color: #f0e68c;">#</span> foo <span style="color: #f0e68c;">-</span>1 <span style="color: #7bc275;">"hello"</span> <span style="color: #7bc275;">"fuck"</span> <span style="color: #ff4500;">;;</span>
<span style="color: #bbc2cf; background-color: #242730;">Error</span><span style="color: #f0e68c;">:</span> <span style="color: #bbc2cf; background-color: #242730;">This</span> expression has <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">int</span> <span style="color: #f0e68c;">-&gt;</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a
but an expression was expected <span style="color: #51afef;">of</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">int</span>

utop <span style="color: #f0e68c;">#</span> foo 3 <span style="color: #7bc275;">"hello"</span> <span style="color: #7bc275;">"fuck"</span> <span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> string <span style="color: #f0e68c;">=</span> <span style="color: #7bc275;">"hello"</span>

utop <span style="color: #f0e68c;">#</span> foo <span style="color: #f0e68c;">(-</span>1<span style="color: #f0e68c;">)</span>  <span style="color: #7bc275;">"hello"</span> <span style="color: #7bc275;">"fuck"</span> <span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> string <span style="color: #f0e68c;">=</span> <span style="color: #7bc275;">"fuck"</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org6718296" class="outline-2">
<h2 id="org6718296">运算符</h2>
<div class="outline-text-2" id="text-org6718296">
</div>
<div id="outline-container-org10555b4" class="outline-3">
<h3 id="org10555b4">用括号定义标点符号</h3>
</div>


<div id="outline-container-orgf41cfd3" class="outline-3">
<h3 id="orgf41cfd3">运算符@@ 分隔开函数和参数</h3>
<div class="outline-text-3" id="text-orgf41cfd3">
<p>
主要是为了避免空格分割导致参数的识别不正常：
</p>
<div class="org-src-container">
<pre class="src src-ocaml">utop<span style="color: #f0e68c;">[</span>3<span style="color: #f0e68c;">]&gt;</span> succ 3<span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 4
utop<span style="color: #f0e68c;">[</span>4<span style="color: #f0e68c;">]&gt;</span> succ 1 <span style="color: #f0e68c;">*</span> 4 <span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 8
utop<span style="color: #f0e68c;">[</span>5<span style="color: #f0e68c;">]&gt;</span> succ <span style="color: #f0e68c;">(</span>1 <span style="color: #f0e68c;">*</span> 4<span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 5
utop<span style="color: #f0e68c;">[</span>6<span style="color: #f0e68c;">]&gt;</span> succ <span style="color: #f0e68c;">@@</span> 1 <span style="color: #f0e68c;">*</span> 4<span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 5
</pre>
</div>
</div>
</div>

<div id="outline-container-org7677c2a" class="outline-3">
<h3 id="org7677c2a">运算符|&gt; 管道符</h3>
<div class="outline-text-3" id="text-org7677c2a">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">(|&gt;)</span> x f <span style="color: #f0e68c;">=</span> f x  <span style="color: #ff4500;">;;</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-ocaml">  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">foo</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">int</span> <span style="color: #f0e68c;">=</span> x<span style="color: #f0e68c;">*</span>x <span style="color: #f0e68c;">+</span>1<span style="color: #ff4500;">;;</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">foo</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&lt;</span><span style="color: #51afef;">fun</span><span style="color: #f0e68c;">&gt;</span>

  utop<span style="color: #f0e68c;">[</span>1<span style="color: #f0e68c;">]&gt;</span> foo 3<span style="color: #ff4500;">;;</span>
  <span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 10

  utop<span style="color: #f0e68c;">[</span>2<span style="color: #f0e68c;">]&gt;</span> 3 <span style="color: #f0e68c;">|&gt;</span> foo<span style="color: #ff4500;">;;</span>
  <span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 10

utop<span style="color: #f0e68c;">[</span>13<span style="color: #f0e68c;">]&gt;</span> succ <span style="color: #f0e68c;">(</span>foo <span style="color: #f0e68c;">(</span>foo 3<span style="color: #f0e68c;">))</span><span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 102
utop<span style="color: #f0e68c;">[</span>14<span style="color: #f0e68c;">]&gt;</span> 3 <span style="color: #f0e68c;">|&gt;</span> foo <span style="color: #f0e68c;">|&gt;</span> foo <span style="color: #f0e68c;">|&gt;</span> succ <span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 102
</pre>
</div>
</div>
</div>





<div id="outline-container-orged8e2d4" class="outline-3">
<h3 id="orged8e2d4">文档</h3>
<div class="outline-text-3" id="text-orged8e2d4">
<p>
<code>(**  .. *)</code> 即是文档的格式。
用方括号包围起来的将会被导出为等宽字体。
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #7e7e87;">(** [args] *)</span>
</pre>
</div>

<ul class="org-ul">
<li>前置条件
对参数含义的描述，以及对合法参数的约束，对动态类型的语言可能还要加上对参数类型的描述</li>
<li>后置条件：
对返回值的约定。对错误情况/异常抛出的约定</li>
</ul>
</div>
</div>


<div id="outline-container-org923ef74" class="outline-3">
<h3 id="org923ef74">打印</h3>
<div class="outline-text-3" id="text-org923ef74">
<p>
print<sub>xxx</sub> :返回类型为unit.
</p>

<p>
唯一一个类型是unit的值是 <code>()</code>
类似于void，通常用于不关心输入参数/返回值时，这时候一般想利用函数的副作用。
</p>


<p>
在let in中要求我们必须为值进行绑定： x = val
对于返回类型为unit的函数：可以写成
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">_</span> <span style="color: #f0e68c;">=</span> func args <span style="color: #f5deb3; font-weight: bold;">in</span> <span style="color: #f0e68c;">...</span>
</pre>
</div>

<p>
或者
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">()</span> <span style="color: #f0e68c;">=</span> func args <span style="color: #f5deb3; font-weight: bold;">in</span> <span style="color: #f0e68c;">...</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f0e68c;">#</span>
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">()</span>  <span style="color: #f0e68c;">=</span> print_endline <span style="color: #7bc275;">"fuck"</span> <span style="color: #f5deb3; font-weight: bold;">in</span> 
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">()</span>  <span style="color: #f0e68c;">=</span> print_endline <span style="color: #7bc275;">"your"</span> <span style="color: #f5deb3; font-weight: bold;">in</span> 
print_endline <span style="color: #7bc275;">"mother"</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml">fuck
your
mother
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> unit <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">()</span>
</pre>
</div>

<p>
这种写法太繁琐了，可以像C中用逗号表达式分别对前面的表达式求值，但只将最后一个表达式的值返回。
在Ocaml中是用 <code>;</code> 来分割的：
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #7bc275;">"hello"</span> <span style="color: #f0e68c;">;</span> 233  <span style="color: #62686E;">(* </span><span style="color: #62686E;">&#36825;&#20250;&#21457;&#20986;&#35686;&#21578; it will cause warnings</span><span style="color: #62686E;">*)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 233 
</pre>
</div>

<p>
因此可写成更简单的形式，而不用写成嵌套的 let..in..
</p>

<div class="org-src-container">
<pre class="src src-ocaml">print_endline <span style="color: #7bc275;">"fuck"</span><span style="color: #f0e68c;">;</span>
print_endline <span style="color: #7bc275;">"your"</span><span style="color: #f0e68c;">;</span>
print_endline <span style="color: #7bc275;">"mother"</span>  <span style="color: #62686E;">(* </span><span style="color: #62686E;">&#26368;&#21518;&#19968;&#20010;&#34920;&#36798;&#24335;&#21518;&#38754;&#26080;&#20998;&#21495;&#65281;</span><span style="color: #62686E;"> *)</span>
</pre>
</div>


<p>
在分号表达式中，若前面被忽略值的表达式的类型不是unit，则会发出警告。
通过ignore函数可以消除警告。
</p>

<p>
(ignore "hello") ; 233
</p>


<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #C57BDB;">ignore</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">()</span>  
</pre>
</div>

<p>
可见，分号表达式的主要作用是串联前面几个产生副作用的表达式，并在最后一个表达式中返回值。
</p>
</div>

<div id="outline-container-org40d9299" class="outline-4">
<h4 id="org40d9299">格式化输出</h4>
<div class="outline-text-4" id="text-org40d9299">
<div class="org-src-container">
<pre class="src src-ocaml">utop <span style="color: #f0e68c;">#</span> <span style="color: #FCCE7B;">Printf.</span>printf <span style="color: #7bc275;">"%s %F\n %!"</span> <span style="color: #7bc275;">"hello"</span> 3.14 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml">hello 3.14
 <span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> unit <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">()</span>
</pre>
</div>

<p>
<code>%!</code> 用来刷写缓冲区，类似于std::endl 
</p>

<p>
<code>%F</code> 浮点数
</p>

<p>
<code>%i</code> 整数
</p>
</div>
</div>


<div id="outline-container-orgb79518d" class="outline-4">
<h4 id="orgb79518d">格式化字符串</h4>
<div class="outline-text-4" id="text-orgb79518d">
<p>
Printf.sprintf 会产生一个string
</p>
</div>
</div>
</div>
</div>







<div id="outline-container-orgc734d9c" class="outline-2">
<h2 id="orgc734d9c">list</h2>
<div class="outline-text-2" id="text-orgc734d9c">
<p>
ocaml 中的list是同类型元素构成的单链表： <code>'a list</code> 。
in OCaml, the list is first class status
</p>

<p>
ocaml 中的list是第一类的，这意味着有专门的语法支持list.
每个list节点是一个pair.  <code>[]</code> 表示空list.
</p>
</div>

<div id="outline-container-org2274c8e" class="outline-3">
<h3 id="org2274c8e">创建list</h3>
<div class="outline-text-3" id="text-org2274c8e">
<p>
有两种方式： 
</p>

<ul class="org-ul">
<li><p>
通过 <code>::</code> 链接元素
</p>

<p>
必须在最后链接上一个空节点 <code>[]</code> 
</p>
<div class="org-src-container">
<pre class="src src-ocaml">1<span style="color: #f0e68c;">::</span>2<span style="color: #f0e68c;">::</span>3<span style="color: #f0e68c;">::[]</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div></li>

<li><p>
通过方括号和分号
</p>

<p>
这种方式可以看作是上面那种方式的语法糖，可以省略链接空列表。
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f0e68c;">[</span>1<span style="color: #f0e68c;">;</span>2<span style="color: #f0e68c;">;</span>3<span style="color: #f0e68c;">]</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div></li>
</ul>
</div>
</div>


<div id="outline-container-org25dc306" class="outline-3">
<h3 id="org25dc306">用 <code>@</code> 连接两个list</h3>
<div class="outline-text-3" id="text-org25dc306">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">a</span> <span style="color: #f0e68c;">=</span> 1 <span style="color: #f0e68c;">::</span> 3 <span style="color: #f0e68c;">::[]</span> <span style="color: #ff4500;">;;</span>
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">b</span> <span style="color: #f0e68c;">=</span> 2 <span style="color: #f0e68c;">::</span> 4 <span style="color: #f0e68c;">::[]</span> <span style="color: #ff4500;">;;</span>

a <span style="color: #f0e68c;">@</span> b <span style="color: #ff4500;">;;</span>

a <span style="color: #f0e68c;">@</span> <span style="color: #f0e68c;">[</span>233<span style="color: #f0e68c;">]</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>














<div id="outline-container-org6b08764" class="outline-3">
<h3 id="org6b08764">通过模式匹配 访问元素</h3>
<div class="outline-text-3" id="text-org6b08764">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #51afef;">match</span> <span style="color: #bbc2cf; background-color: #242730;">XX</span> <span style="color: #51afef;">with</span>
<span style="color: #f0e68c;">|</span> pattern1 <span style="color: #f0e68c;">-&gt;</span> <span style="color: #51afef;">do</span> something
<span style="color: #f0e68c;">|</span> pattern2 <span style="color: #f0e68c;">-&gt;</span> <span style="color: #51afef;">do</span> something
<span style="color: #f0e68c;">|</span> _ <span style="color: #f0e68c;">-&gt;</span>  <span style="color: #f0e68c;">...</span>
</pre>
</div>

<p>
所谓模式就是数据的形式（样子），比如list可以是空的，也可以是不空的。
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #51afef;">match</span> lst <span style="color: #51afef;">with</span>
<span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> 0
<span style="color: #f0e68c;">|</span> head <span style="color: #f0e68c;">::</span> tail <span style="color: #f0e68c;">-&gt;</span> head 
</pre>
</div>
<p>
空list的形状就是 <code>[]</code> ，非空的列表意味着至少有一个有效元素： <code>e :: []</code> 
因此，其形状是 <code>head::tail</code> 。
</p>

<p>
在一个模式中不能有两个同名的符号：  <code>x::x</code> 
</p>

<p>
有两种特殊的模式： <code>_</code> 和 <code>x</code> (x是随便一个符号名）
它们都能和任意的数据匹配上，不同之处在于匹配上的数据不会绑定到 <code>_</code> 上，但是会绑定到 <code>x</code> 上。
也就是说，在 <code>-&gt;</code> 右侧能否引用匹配上的值。
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">length</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">match</span> lst <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> 0
  <span style="color: #f0e68c;">|</span> h <span style="color: #f0e68c;">::</span> t <span style="color: #f0e68c;">-&gt;</span> 1 <span style="color: #f0e68c;">+</span> length t
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
在这个函数中的模式匹配里，第二个模式的 <code>h</code> 是没有必要的，因为箭头后面根本就没有使用 <code>h</code>,
</p>

<p>
<code>List.hd/List.tl</code> 分别能取出list的head和tail, 但是当他们作用于空列表 <code>[]</code> 时，会抛出异常。
而使用模式匹配的方式访问head/tail的好处是会强制你处理list的所有形式。
</p>
</div>
</div>






<div id="outline-container-org4ea4c56" class="outline-3">
<h3 id="org4ea4c56">list的不可变</h3>
<div class="outline-text-3" id="text-org4ea4c56">
<p>
在ocaml中，所有变量都是immutable，也就是无法被原地修改的。对list来说，只有被改变的元素才会被拷贝，而未改变的部分是共享的，不会发生额外的拷贝。
</p>

<p>
eg：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">incr_first</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">lst </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> int list</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">int list</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">match</span> lst <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>h<span style="color: #f0e68c;">+</span>1<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">::</span> t
<span style="color: #ff4500;">;;</span>

</pre>
</div>
</div>
</div>
</div>











<div id="outline-container-org3784728" class="outline-2">
<h2 id="org3784728">模式匹配</h2>
<div class="outline-text-2" id="text-org3784728">
<p>
<code>_</code> 是通配符，不会和值进行绑定。
</p>

<p>
在模式匹配中主要做了两件事情：
</p>

<ul class="org-ul">
<li>判断模式和给定的值是否匹配</li>
<li>决定值的那些部分可以和模式中的变量名进行绑定
我们用 <code>h -&gt; 1</code> 这样的写法表示变量绑定：变量h的值为1</li>
</ul>

<p>
用这个记号来看模式：
</p>

<ul class="org-ul">
<li>模式x能匹配上任何value：  <code>x-&gt;value</code></li>
<li>模式 <code>_</code> 能和任何值匹配，但不进行绑定。</li>
<li>模式 <code>[]</code> 匹配上空list ~[]~，它也没有绑定。</li>
<li>模式 <code>[p1;...pn]</code> 能匹配上形如 <code>[v1;...vn]</code> 的值，并且有 <code>pi-&gt;vi</code> .</li>
</ul>
</div>

<div id="outline-container-orgd438484" class="outline-3">
<h3 id="orgd438484">模式匹配的求值规则（动态语义）</h3>
<div class="outline-text-3" id="text-orgd438484">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #51afef;">match</span> e <span style="color: #51afef;">with</span>
<span style="color: #f0e68c;">|</span> p1 <span style="color: #f0e68c;">-&gt;</span> e1
  <span style="color: #f0e68c;">...</span>
<span style="color: #f0e68c;">|</span> pn <span style="color: #f0e68c;">-&gt;</span> en
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<ul class="org-ul">
<li>将表达式 <code>e</code> 求值为 <code>v</code></li>
<li>将v分别和 <code>p1</code> &#x2026; <code>pn</code> 进行匹配。</li>
<li>若v无法和任何模式匹配上，则会抛出 <code>Match_failure</code> 异常。</li>
<li>否则，在第一个和v成功匹配的模式 <code>pi</code> 处停下，并用绑定 <code>pi -&gt; v</code> 将  <code>ei</code> 中的 <code>pi</code> 替换掉，得到新的表达式 <code>e'</code></li>
<li>对表达式 <code>e'</code> 求值为 <code>v'</code></li>
<li>整个match表达式的值为 <code>v'</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgd164486" class="outline-3">
<h3 id="orgd164486">模式匹配静态语义</h3>
<div class="outline-text-3" id="text-orgd164486">
</div>
<div id="outline-container-orgefdae1c" class="outline-4">
<h4 id="orgefdae1c">类型推断/检查</h4>
<div class="outline-text-4" id="text-orgefdae1c">
<p>
若 <code>e : ta</code> ，且  <code>pi:ta</code> ,  <code>ei:tb</code> , 则有：
 <code>match表达式 : tb</code> 
</p>
</div>
</div>

<div id="outline-container-orgafcb65a" class="outline-4">
<h4 id="orgafcb65a">match的分支是否完整包含了所有情况</h4>
<div class="outline-text-4" id="text-orgafcb65a">
<pre class="example">
[partial-match]: this pattern-matching is not exhaustive.
</pre>
<p>
这种警告会在分支未完全覆盖可能出现的所有模式时发出：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"> <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">head</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span>
   <span style="color: #51afef;">match</span> lst <span style="color: #51afef;">with</span>
   <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>_ <span style="color: #f0e68c;">-&gt;</span> h
<span style="color: #62686E;">(* </span><span style="color: #62686E;">| [] -&gt; faliwith  "empty list"</span><span style="color: #62686E;">  *)</span>
 <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-orgaee7195" class="outline-4">
<h4 id="orgaee7195">match中是否包含无用分支</h4>
<div class="outline-text-4" id="text-orgaee7195">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">head</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span>
<span style="color: #51afef;">match</span> lst <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> h
  <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[</span>x<span style="color: #f0e68c;">]</span> <span style="color: #f0e68c;">-&gt;</span> x
  <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> 0
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
因为模式h::t已经包括了模式[x]的情况，因此这时会发出警告：
</p>
<pre class="example">
[redundant-case]: this match case is unused.
</pre>

<p>
但稍微调整一下分支的顺序，就能使这个例子的警告消失：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">head</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span>
<span style="color: #51afef;">match</span> lst <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[</span>x<span style="color: #f0e68c;">]</span> <span style="color: #f0e68c;">-&gt;</span> x
  <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> h
  <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> 0
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-orgaee529b" class="outline-3">
<h3 id="orgaee529b">一些关于list的模式</h3>
<div class="outline-text-3" id="text-orgaee529b">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #62686E;">(* </span><span style="color: #62686E;">&#33267;&#23569;&#21547;3&#20010;&#20803;&#32032;&#30340;list</span><span style="color: #62686E;"> *)</span>
_<span style="color: #f0e68c;">::</span>_<span style="color: #f0e68c;">::</span>_<span style="color: #f0e68c;">::</span>_
<span style="color: #62686E;">(* </span><span style="color: #62686E;">&#27491;&#22909;&#26377;&#20004;&#20010;&#20803;&#32032;&#30340;list</span><span style="color: #62686E;"> *)</span>
_<span style="color: #f0e68c;">::</span>_<span style="color: #f0e68c;">::[]</span> 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcfc2e34" class="outline-3">
<h3 id="orgcfc2e34">用于函数定义的简化模式匹配</h3>
<div class="outline-text-3" id="text-orgcfc2e34">
<ul class="org-ul">
<li>最后一个参数是要进行匹配的，需要省略不写.</li>
<li>用 <code>function</code> 代替 <code>match xx with</code> .</li>
</ul>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">sum</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span>
  <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> h <span style="color: #f0e68c;">+</span> sum t
<span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">sum</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">match</span> lst <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> 0
  <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> h <span style="color: #f0e68c;">+</span> sum t
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcec5ddf" class="outline-3">
<h3 id="orgcec5ddf">更多模式</h3>
<div class="outline-text-3" id="text-orgcec5ddf">
</div>
<div id="outline-container-orgc508b81" class="outline-4">
<h4 id="orgc508b81">匹配上模式并满足when的条件</h4>
<div class="outline-text-4" id="text-orgc508b81">
<p>
<code>p when e</code> : 当和模式p匹配且e的值为true
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">first_zero</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span> 
<span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">true</span> 
<span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #51afef;">when</span> h <span style="color: #f0e68c;">=</span> 0 <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">true</span> 
<span style="color: #f0e68c;">|</span> _ <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span> 
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">number_or_letter</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span> 
  <span style="color: #f0e68c;">|</span><span style="color: #7bc275;">'A'</span> <span style="color: #f0e68c;">..</span> <span style="color: #7bc275;">'Z'</span> <span style="color: #f0e68c;">|</span> <span style="color: #7bc275;">'a'</span> <span style="color: #f0e68c;">..</span> <span style="color: #7bc275;">'z'</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">"letter"</span> 
  <span style="color: #f0e68c;">|</span> <span style="color: #7bc275;">'0'</span> <span style="color: #f0e68c;">..</span> <span style="color: #7bc275;">'9'</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">"number"</span>
  <span style="color: #f0e68c;">|</span> _ <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">"??"</span> 
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
这里有两个模式，一个是关于字符范围的，另一个是表示 OR 的。
</p>

<p>
<code>'A' .. 'Z'</code> 表示从A-Z的任意一个字符。
<code>|</code> 表示或
</p>
</div>
</div>
</div>

<div id="outline-container-org515b8ba" class="outline-3">
<h3 id="org515b8ba">let in 中的模式匹配</h3>
<div class="outline-text-3" id="text-org515b8ba">
<p>
在语法中
<code>let p=e in e1</code>
p可以是模式，而不仅仅是一个标识符：
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">a</span><span style="color: #f0e68c;">,</span><span style="color: #DFDFDF;">b</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span>1<span style="color: #f0e68c;">,</span> <span style="color: #7bc275;">'c'</span> <span style="color: #f0e68c;">)</span> <span style="color: #f5deb3; font-weight: bold;">in</span>
<span style="color: #FCCE7B;">Printf.</span>printf <span style="color: #7bc275;">"%i,%c %!"</span> a b
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org13f53ea" class="outline-3">
<h3 id="org13f53ea">元组的模式匹配</h3>
<div class="outline-text-3" id="text-org13f53ea">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">thrid</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">_</span><span style="color: #f0e68c;">,</span><span style="color: #DFDFDF;">_</span><span style="color: #f0e68c;">,</span><span style="color: #DFDFDF;">x</span><span style="color: #f0e68c;">,</span><span style="color: #DFDFDF;">_</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span> x <span style="color: #ff4500;">;;</span>

thrid 3<span style="color: #f0e68c;">,</span>4<span style="color: #f0e68c;">,</span><span style="color: #7bc275;">"hello"</span><span style="color: #f0e68c;">,</span> 5.0  <span style="color: #ff4500;">;;</span> 
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-org95b06d9" class="outline-2">
<h2 id="org95b06d9">尾递归</h2>
<div class="outline-text-2" id="text-org95b06d9">
<p>
在函数定义中，从递归调用返回后没有其他计算.
</p>

<p>
eg: sum函数
</p>

<p>
这不是尾递归，因为从sum返回后还需要一次加法运算
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">sum</span><span style="color: #DFDFDF;"> n</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">if</span> n <span style="color: #f0e68c;">=</span> 0 <span style="color: #51afef;">then</span> 0
  <span style="color: #51afef;">else</span> n <span style="color: #f0e68c;">+</span> sum <span style="color: #f0e68c;">(</span>n<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">)</span>  
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
通过给递归函数增加一个参数 <code>res</code> 来保存中间结果使得它成为尾递归 <code>tail recursion</code>
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">sum_tr</span><span style="color: #DFDFDF;"> res n</span>  <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">if</span> n <span style="color: #f0e68c;">=</span> 0 <span style="color: #51afef;">then</span> res 
  <span style="color: #51afef;">else</span> sum_tr <span style="color: #f0e68c;">(</span>res<span style="color: #f0e68c;">+</span>n<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>n<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">)</span> 
<span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">sum</span><span style="color: #DFDFDF;"> n</span> <span style="color: #f0e68c;">=</span>
  sum_tr 0 n
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
本质上，这个递归版本的sum函数只是将规模为N的问题转化成了 <code>一个</code> 规模为N-1的子问题，这种原问题和子问题之间的依赖关系只是一个链表结构，而不是一个树状结构。
只有树状的关系才无法成为尾递归，而在sum函数这个例子中完全不需要在 <code>sum(n-1)</code> 调用结束后再进行额外的计算来得到 <code>sum n</code> 的结果，而是将这部分计算放到 <code>sum n-1</code> 中完成
</p>



<p>
eg: 尾递归函数from产生从i ~ j 的列表 
</p>
<div class="org-src-container">
<pre class="src src-ocaml">
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">from</span><span style="color: #DFDFDF;"> i j lst</span>  <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">if</span> j <span style="color: #f0e68c;">&lt;</span> i <span style="color: #51afef;">then</span> lst 
  <span style="color: #51afef;">else</span> from i <span style="color: #f0e68c;">(</span>j<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>j <span style="color: #f0e68c;">::</span> lst<span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">--</span> <span style="color: #f0e68c;">)</span> i j <span style="color: #f0e68c;">=</span>
  from i j <span style="color: #f0e68c;">[]</span>
<span style="color: #ff4500;">;;</span>


<span style="color: #62686E;">(* </span><span style="color: #62686E;">Usage:</span><span style="color: #62686E;"> *)</span>
1 <span style="color: #f0e68c;">--</span> 10 <span style="color: #ff4500;">;;</span>
</pre>
</div>

<pre class="example">
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
</pre>

<p>
OCaml中有类似的函数
</p>

<pre class="example">
List.init  length  func  ==&gt; [f 0;f 1;f 2;...;f (length-1) ] 
</pre>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">plus_one</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> x <span style="color: #f0e68c;">+</span> 1 <span style="color: #ff4500;">;;</span>

<span style="color: #FCCE7B;">List.</span>init 10 plus_one <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-org4fd4c73" class="outline-2">
<h2 id="org4fd4c73">变体 | Variants</h2>
<div class="outline-text-2" id="text-org4fd4c73">
<p>
变体就像是能在enum中使用class的一种东西。
</p>

<p>
Variant不能以大写字母开头！其下面的构造器名以大写字母开头！
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">basic_color</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Red</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Green</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Blue</span>  <span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">which_color</span>  <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Red</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">"red"</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Green</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">"green"</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Blue</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">"blue"</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
这些以大写字母开头的单词是构造器/标签Tag
这些构造器Red能创建就是basic<sub>color类型的值</sub>，并保留了这个值是Red的信息。
构造器能携带值，通过定义时加上 <code>Tag of ValueType</code>
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span>  <span style="color: #FCCE7B;">token</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Ident</span> <span style="color: #51afef;">of</span> string  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Num</span> <span style="color: #51afef;">of</span> int  <span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">tk</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Ident</span> <span style="color: #7bc275;">"foo"</span> <span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">tk</span> <span style="color: #f0e68c;">:</span> token <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Ident</span> <span style="color: #7bc275;">"foo"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #bbc2cf; background-color: #242730;">Num</span> 233 <span style="color: #ff4500;">;;</span>

<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> token <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Num</span> 233
</pre>
</div>

<p>
仍能从变量tk中获得它是一个Id的信息。
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #51afef;">match</span> tk <span style="color: #51afef;">with</span> 
<span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Ident</span> name <span style="color: #f0e68c;">-&gt;</span>  name 
<span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Num</span> n <span style="color: #f0e68c;">-&gt;</span> string_of_int n 
<span style="color: #ff4500;">;;</span>

<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> string <span style="color: #f0e68c;">=</span> <span style="color: #7bc275;">"foo"</span>
</pre>
</div>
</div>


<div id="outline-container-org5f79b5a" class="outline-3">
<h3 id="org5f79b5a">额外携带数据的Variant也被叫做代数数据类型</h3>
<div class="outline-text-3" id="text-org5f79b5a">
<p>
因为它包含了类型的sum product运算：
一个Varant值是多个构造器中的一种
每个构造器能携带record/tuple类型。
</p>
</div>
</div>

<div id="outline-container-org0139b46" class="outline-3">
<h3 id="org0139b46">对Variant使用模式匹配的要点</h3>
<div class="outline-text-3" id="text-org0139b46">
<p>
尽量避免使用 <code>_</code> ,否则当增加Variant的选项后，很可能忘记修改match的代码来增加对应的新分支，
因为 <code>_</code> 通配符会匹配上这个新模式。
</p>
</div>
</div>


<div id="outline-container-org9cf7ffc" class="outline-3">
<h3 id="org9cf7ffc">Variant的递归定义</h3>
<div class="outline-text-3" id="text-org9cf7ffc">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">tnode</span>   <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyNode</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #51afef;">of</span>  int   <span style="color: #f0e68c;">*</span> tnode <span style="color: #f0e68c;">*</span> tnode
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"> <span style="color: #bbc2cf; background-color: #242730;">Node</span>  <span style="color: #f0e68c;">(</span>233 <span style="color: #f0e68c;">,</span> <span style="color: #f0e68c;">(</span><span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #f0e68c;">(</span>123 <span style="color: #f0e68c;">,</span><span style="color: #bbc2cf; background-color: #242730;">EmptyNode</span><span style="color: #f0e68c;">,</span><span style="color: #bbc2cf; background-color: #242730;">EmptyNode</span> <span style="color: #f0e68c;">))</span> <span style="color: #f0e68c;">,</span><span style="color: #bbc2cf; background-color: #242730;">EmptyNode</span> <span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span>

<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> tnode <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #f0e68c;">(</span>233<span style="color: #f0e68c;">,</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #f0e68c;">(</span>123<span style="color: #f0e68c;">,</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyNode</span><span style="color: #f0e68c;">,</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyNode</span><span style="color: #f0e68c;">),</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyNode</span><span style="color: #f0e68c;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8414f09" class="outline-3">
<h3 id="org8414f09"><code>and</code> 关键字使类型定义可以是互相递归的</h3>
<div class="outline-text-3" id="text-org8414f09">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">node</span>  <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">{</span> value <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">;</span> nextnode <span style="color: #f0e68c;">:</span> int mylist<span style="color: #f0e68c;">}</span>
<span style="color: #f5deb3; font-weight: bold;">and</span>  <span style="color: #DFDFDF;">mylist</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Nil</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #51afef;">of</span> int node
<span style="color: #ff4500;">;;</span>
<span style="color: #62686E;">(* </span><span style="color: #62686E;">&#21516;&#26102;&#23450;&#20041;&#20102;&#19968;&#20010; record &#21644;&#19968;&#20010; variant</span><span style="color: #62686E;">*)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"> <span style="color: #bbc2cf; background-color: #242730;">Node</span><span style="color: #f0e68c;">{</span> value <span style="color: #f0e68c;">=</span> 123 <span style="color: #f0e68c;">;</span> nextnode <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span><span style="color: #f0e68c;">{</span>value <span style="color: #f0e68c;">=</span> 2333 <span style="color: #f0e68c;">;</span> nextnode <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Nil</span> <span style="color: #f0e68c;">}</span> <span style="color: #f0e68c;">}</span> 
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">tnode</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">{</span>value <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">;</span> left <span style="color: #f0e68c;">:</span> mytree <span style="color: #f0e68c;">;</span> right<span style="color: #f0e68c;">:</span> mytree<span style="color: #f0e68c;">}</span>
<span style="color: #f5deb3; font-weight: bold;">and</span> <span style="color: #DFDFDF;">mytree</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">TNil</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">TNode</span> <span style="color: #51afef;">of</span> tnode
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org800b0eb" class="outline-3">
<h3 id="org800b0eb">Variants的参数多态</h3>
<div class="outline-text-3" id="text-org800b0eb">
<p>
带范型的Variants 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a node</span>  <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">{</span> value <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">;</span> nextnode <span style="color: #f0e68c;">:</span> 'a mylist<span style="color: #f0e68c;">}</span>
<span style="color: #f5deb3; font-weight: bold;">and</span> 'a mylist <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Nil</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #51afef;">of</span> 'a node
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
当然，一个更清晰的版本是：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a mylist</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Nil</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #51afef;">of</span> 'a <span style="color: #f0e68c;">*</span> 'a mylist  <span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #f0e68c;">(</span> 233 <span style="color: #f0e68c;">,</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #f0e68c;">(</span>123<span style="color: #f0e68c;">,</span> <span style="color: #bbc2cf; background-color: #242730;">Nil</span><span style="color: #f0e68c;">))</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
<b>多个类型参数:</b>
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #f0e68c;">(</span><span style="color: #FCCE7B;">'a </span><span style="color: #f0e68c;">,</span><span style="color: #FCCE7B;"> 'b</span><span style="color: #f0e68c;">)</span><span style="color: #FCCE7B;"> mypair</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">{</span>first <span style="color: #f0e68c;">:</span>'a <span style="color: #f0e68c;">;</span>second <span style="color: #f0e68c;">:</span>'b<span style="color: #f0e68c;">}</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
list/options 就是参数化Variant :
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span>  'a list <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">::</span> <span style="color: #f0e68c;">)</span> <span style="color: #51afef;">of</span> 'a <span style="color: #f0e68c;">*</span> 'a list
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a options</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">None</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> <span style="color: #51afef;">of</span> 'a
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-orgb1e0d10" class="outline-3">
<h3 id="orgb1e0d10">多态Variant/匿名Variant</h3>
<div class="outline-text-3" id="text-orgb1e0d10">
<p>
当某些Variant只需要使用一次（eg 作为返回值），这时候给它一个全局定义是没必要的。
这时需要匿名Variant：
在构造器前面加上 <code>`</code> 
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">mydiv</span><span style="color: #DFDFDF;"> a b</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">if</span> b <span style="color: #f0e68c;">=</span> 0 <span style="color: #51afef;">then</span> <span style="color: #bbc2cf; background-color: #242730;">`Inf</span>
  <span style="color: #51afef;">else</span> <span style="color: #bbc2cf; background-color: #242730;">`Num</span> <span style="color: #f0e68c;">(</span>a<span style="color: #f0e68c;">/</span>b<span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">mydiv</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">`Inf</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">`Num</span> <span style="color: #51afef;">of</span> int <span style="color: #f0e68c;">]</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&lt;</span><span style="color: #51afef;">fun</span><span style="color: #f0e68c;">&gt;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml">utop<span style="color: #f0e68c;">[</span>41<span style="color: #f0e68c;">]&gt;</span> mydiv 2 3 <span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> <span style="color: #f0e68c;">[&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">`Inf</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">`Num</span> <span style="color: #51afef;">of</span> int <span style="color: #f0e68c;">]</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">`Num</span> 0
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml">utop<span style="color: #f0e68c;">[</span>42<span style="color: #f0e68c;">]&gt;</span> mydiv 4 0 <span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> <span style="color: #f0e68c;">[&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">`Inf</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">`Num</span> <span style="color: #51afef;">of</span> int <span style="color: #f0e68c;">]</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">`Inf</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org4b06006" class="outline-2">
<h2 id="org4b06006">和match天生一对的Options= Some/None</h2>
<div class="outline-text-2" id="text-org4b06006">
<p>
在不用空指针的情况下表达“返回结果可能为空。
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">getstr</span><span style="color: #DFDFDF;">  s</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">if</span> s <span style="color: #f0e68c;">=</span> <span style="color: #7bc275;">""</span> <span style="color: #51afef;">then</span> <span style="color: #bbc2cf; background-color: #242730;">None</span>
  <span style="color: #51afef;">else</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> s
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml">getstr <span style="color: #7bc275;">""</span> <span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> string option <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">None</span>

getstr <span style="color: #7bc275;">"hello"</span> <span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> string option <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> <span style="color: #7bc275;">"hello"</span>
</pre>
</div>
<p>
对需要处理值是Options的代码，需要用 <code>match</code> 进行匹配。
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">dealwiths</span><span style="color: #DFDFDF;"> s</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">match</span> s <span style="color: #51afef;">with</span> 
  <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">None</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">"there is nothing"</span>
  <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Some</span> x <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">"this is "</span> <span style="color: #f0e68c;">^</span> x 
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml">dealwiths <span style="color: #f0e68c;">(</span><span style="color: #bbc2cf; background-color: #242730;">Some</span> <span style="color: #7bc275;">"a cat"</span> <span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> string <span style="color: #f0e68c;">=</span> <span style="color: #7bc275;">"this is a cat"</span>

dealwiths <span style="color: #f0e68c;">(</span>getstr <span style="color: #7bc275;">""</span><span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> string <span style="color: #f0e68c;">=</span> <span style="color: #7bc275;">"there is nothing"</span>
</pre>
</div>

<p>
None 的类型是 <code>'a option</code> , Some expr的类型是 <code>t option</code> (expr:t)
用None表示返回一个空 + 模式匹配强制要求处理Options所有可能的模式 = 强制要求检查返回值可能为空的场景。
</p>
</div>
</div>




<div id="outline-container-orga21bada" class="outline-2">
<h2 id="orga21bada">列表推导 | List Comprehensions</h2>
<div class="outline-text-2" id="text-orga21bada">
<p>
一种产生list的语法糖。
</p>
</div>
</div>


<div id="outline-container-org6d541b2" class="outline-2">
<h2 id="org6d541b2">OUnit2</h2>
<div class="outline-text-2" id="text-org6d541b2">
<p>
首先创建dune项目
</p>
<div class="org-src-container">
<pre class="src src-bash">dune init project yourproject
</pre>
</div>

<p>
在dune中链接ounit2:
</p>

<div class="org-src-container">
<pre class="src src-dune">(executable
  (name test_xx)
  (libraries ounit2))
</pre>
</div>


<p>
创建测试文件  <code>test_xx.ml</code> 
引入ounit2和被测试的模块
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">open </span><span style="color: #FCCE7B;">Xx</span>
<span style="color: #f5deb3; font-weight: bold;">open </span><span style="color: #FCCE7B;">OUnit2</span>

</pre>
</div>


<p>
为某个函数/功能创建测试套件：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #7bc275;">"&#27979;&#35797;&#22871;&#20214;&#21517;"</span> <span style="color: #f0e68c;">&gt;:::</span> <span style="color: #f0e68c;">[</span>  <span style="color: #62686E;">(* </span><span style="color: #62686E;">&#27979;&#35797;&#39033;list</span><span style="color: #62686E;"> *)</span> <span style="color: #f0e68c;">]</span> 
</pre>
</div>

<p>
编写测试用例：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #7bc275;">"&#27979;&#35797;&#39033;&#30446;&#21517;"</span> <span style="color: #f0e68c;">&gt;::</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">_</span> <span style="color: #f0e68c;">-&gt;</span> assert_xxx arg1 arg2 <span style="color: #f0e68c;">..</span> <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">;</span>
</pre>
</div>

<p>
运行一个测试套件：
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">_</span> <span style="color: #f0e68c;">=</span> run_test_tt_main &#27979;&#35797;&#22871;&#20214; 
</pre>
</div>



<p>
完整例子：
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">open </span><span style="color: #FCCE7B;">OUnit2</span>
<span style="color: #f5deb3; font-weight: bold;">open </span><span style="color: #FCCE7B;">Sum</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">tests</span> <span style="color: #f0e68c;">=</span> <span style="color: #7bc275;">"test suite for sum"</span> <span style="color: #f0e68c;">&gt;:::</span> <span style="color: #f0e68c;">[</span>
    <span style="color: #7bc275;">"empty"</span> <span style="color: #f0e68c;">&gt;::</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">_</span> <span style="color: #f0e68c;">-&gt;</span> assert_equal 0 <span style="color: #f0e68c;">(</span>sum <span style="color: #f0e68c;">[])</span> <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">;</span>
    <span style="color: #7bc275;">"singleton"</span> <span style="color: #f0e68c;">&gt;::</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">_</span> <span style="color: #f0e68c;">-&gt;</span> assert_equal 1 <span style="color: #f0e68c;">(</span>sum <span style="color: #f0e68c;">[</span>1<span style="color: #f0e68c;">])</span> <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">;</span>
    <span style="color: #7bc275;">"two elements"</span> <span style="color: #f0e68c;">&gt;::</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">_</span> <span style="color: #f0e68c;">-&gt;</span> assert_equal 3 <span style="color: #f0e68c;">(</span>sum <span style="color: #f0e68c;">[</span>1<span style="color: #f0e68c;">;</span>2<span style="color: #f0e68c;">]));</span>
  <span style="color: #f0e68c;">]</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">_</span> <span style="color: #f0e68c;">=</span> run_test_tt_main tests 
</pre>
</div>
</div>


<div id="outline-container-org78a6a08" class="outline-3">
<h3 id="org78a6a08">打印测试用例出错时的值</h3>
<div class="outline-text-3" id="text-org78a6a08">
<p>
要给 <code>assert_xxx</code> 的 <code>printer</code> 参数传入一个输出字符串表达的函数，eg: <code>string_of_int</code> 
</p>
<div class="org-src-container">
<pre class="src src-ocaml">

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">mytsts</span> <span style="color: #f0e68c;">=</span> <span style="color: #7bc275;">"test suite for some module"</span> <span style="color: #f0e68c;">&gt;:::</span> <span style="color: #f0e68c;">[</span>
    <span style="color: #7bc275;">"case1"</span> <span style="color: #f0e68c;">&gt;::</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">_</span> <span style="color: #f0e68c;">-&gt;</span> assert_equal 0 <span style="color: #f0e68c;">(</span>sum <span style="color: #f0e68c;">[])</span> <span style="color: #a991f1;">~printer</span><span style="color: #f0e68c;">:</span>string_of_int <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">;</span>
    <span style="color: #f0e68c;">]</span>
</pre>
</div>


<p>
会输出：
</p>
<pre class="example">
expected: 0 but got: 1
</pre>

<p>
从这个打印结果能看出，assert的首个参数应该是期望的值。
</p>
</div>
</div>





<div id="outline-container-orgbf6b543" class="outline-3">
<h3 id="orgbf6b543">测试是否发出了异常</h3>
<div class="outline-text-3" id="text-orgbf6b543">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #7bc275;">"test case"</span> <span style="color: #f0e68c;">&gt;::</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">_</span> <span style="color: #f0e68c;">-&gt;</span> assert_raise <span style="color: #f0e68c;">(</span>&#24322;&#24120;&#23545;&#35937;<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #f0e68c;">()</span> <span style="color: #f0e68c;">-&gt;</span> &#33021;&#21457;&#20986;&#24322;&#24120;&#30340;&#34920;&#36798;&#24335; <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">)</span> 
</pre>
</div>


<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">open </span><span style="color: #FCCE7B;">OUnit2</span>
<span style="color: #f5deb3; font-weight: bold;">open </span><span style="color: #FCCE7B;">Stdlib</span>   

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">raise_expection</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">()</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #C57BDB;">raise</span> <span style="color: #f0e68c;">(</span><span style="color: #C57BDB;">Failure</span> <span style="color: #7bc275;">"mytest"</span><span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">mytests</span> <span style="color: #f0e68c;">=</span> <span style="color: #7bc275;">"test suite"</span> <span style="color: #f0e68c;">&gt;:::</span> <span style="color: #f0e68c;">[</span>
    <span style="color: #7bc275;">"test-raise-exceptions"</span> <span style="color: #f0e68c;">&gt;::</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">_</span> <span style="color: #f0e68c;">-&gt;</span> assert_raises
                                    <span style="color: #f0e68c;">(</span><span style="color: #C57BDB;">Failure</span> <span style="color: #7bc275;">"mytest"</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #f0e68c;">()</span> <span style="color: #f0e68c;">-&gt;</span> raise_expection <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">))</span>
  <span style="color: #f0e68c;">]</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">_</span> <span style="color: #f0e68c;">=</span> run_test_tt_main mytests <span style="color: #ff4500;">;;</span> 
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org68a88a7" class="outline-2">
<h2 id="org68a88a7">Records &amp; Tuples</h2>
<div class="outline-text-2" id="text-org68a88a7">
<p>
将几个数据放到一起的方式有两种：
Records就像C中的结构体，主要特点是能按名字访问字段。
Tuples不会给字段命名，而是通过位置来访问字段。
二者都是定长的类型。
</p>
</div>

<div id="outline-container-orgcad24b6" class="outline-3">
<h3 id="orgcad24b6">Record定义</h3>
<div class="outline-text-3" id="text-orgcad24b6">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">ptype</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">TNormal</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">TFire</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">TWater</span> <span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">mon</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">{</span>name <span style="color: #f0e68c;">:</span> string <span style="color: #f0e68c;">;</span> hp <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">;</span> ptype <span style="color: #f0e68c;">:</span> ptype <span style="color: #f0e68c;">}</span> <span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">c</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">{</span>name <span style="color: #f0e68c;">=</span> <span style="color: #7bc275;">"bird"</span> <span style="color: #f0e68c;">;</span>hp <span style="color: #f0e68c;">=</span> 40 <span style="color: #f0e68c;">;</span> ptype <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">TNormal</span> <span style="color: #f0e68c;">}</span> <span style="color: #ff4500;">;;</span>
<span style="color: #62686E;">(* </span><span style="color: #62686E;">&#23383;&#27573;&#30340;&#39034;&#24207;&#21487;&#20197;&#21644;&#23450;&#20041;&#19981;&#19968;&#33268;</span><span style="color: #62686E;"> *)</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-org49032fa" class="outline-3">
<h3 id="org49032fa">访问Record的字段</h3>
<div class="outline-text-3" id="text-org49032fa">
</div>
<div id="outline-container-org7fd9829" class="outline-4">
<h4 id="org7fd9829">通过 <code>R.field</code></h4>
<div class="outline-text-4" id="text-org7fd9829">
<p>
field只能是定义中提到的标识符，而不是表达式。
</p>

<p>
若想要通过某些计算来动态获得字段名，应该使用 <code>map</code> 类型。
</p>

<div class="org-src-container">
<pre class="src src-ocaml">c.name <span style="color: #ff4500;">;;</span> 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbcd29fc" class="outline-4">
<h4 id="orgbcd29fc">通过模式匹配</h4>
<div class="outline-text-4" id="text-orgbcd29fc">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #51afef;">match</span> c <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">{</span> name<span style="color: #f0e68c;">=</span>n<span style="color: #f0e68c;">;</span> hp<span style="color: #f0e68c;">=</span>h<span style="color: #f0e68c;">;</span> ptype<span style="color: #f0e68c;">=</span>t <span style="color: #f0e68c;">}</span> <span style="color: #f0e68c;">-&gt;</span> n
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org45cab0b" class="outline-3">
<h3 id="org45cab0b">从旧record中创建新record</h3>
<div class="outline-text-3" id="text-org45cab0b">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">new_c</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">{</span> c <span style="color: #51afef;">with</span> name <span style="color: #f0e68c;">=</span> <span style="color: #7bc275;">"world"</span> <span style="color: #f0e68c;">;</span> hp <span style="color: #f0e68c;">=</span> 123 <span style="color: #f0e68c;">}</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
创建record拷贝，只是某些字段的值不同。
</p>
</div>
</div>








<div id="outline-container-orgb851991" class="outline-3">
<h3 id="orgb851991">Tuple的定义</h3>
<div class="outline-text-3" id="text-orgb851991">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">subject</span> <span style="color: #f0e68c;">=</span> string <span style="color: #f0e68c;">*</span> int <span style="color: #ff4500;">;;</span> 
</pre>
</div>

<p>
用小括号和 <code>,</code> 来创建一个tuple变量。
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">t</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span>23<span style="color: #f0e68c;">,</span>3.0<span style="color: #f0e68c;">,</span><span style="color: #7bc275;">"hello"</span><span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span> 
</pre>
</div>

<p>
<code>int * float * string</code> 是t的类型：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">t</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">*</span> float <span style="color: #f0e68c;">*</span> string <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span>23<span style="color: #f0e68c;">,</span> 3.<span style="color: #f0e68c;">,</span> <span style="color: #7bc275;">"hello)"</span>
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-orgb2badb9" class="outline-2">
<h2 id="orgb2badb9">类型别名</h2>
<div class="outline-text-2" id="text-orgb2badb9">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">point</span> <span style="color: #f0e68c;">=</span> float <span style="color: #f0e68c;">*</span> float <span style="color: #ff4500;">;;</span>
<span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">intlist</span> <span style="color: #f0e68c;">=</span> int list <span style="color: #ff4500;">;;</span>

</pre>
</div>
</div>
</div>






<div id="outline-container-org5c79f48" class="outline-2">
<h2 id="org5c79f48">异常</h2>
<div class="outline-text-2" id="text-org5c79f48">
<p>
OCaml中的异常是一个 <b>可拓展</b> 的Variant.
</p>

<p>
有了异常的概念后，我们能完整地描述OCaml表达式的 <b>动态语义</b> ：
</p>
<ul class="org-ul">
<li>被计算为一个值 evaluates to a value</li>
<li>发出异常 raises an expection</li>
<li>无限循环 an infinite loop</li>
</ul>

<p>
（因此在match的分支中要充分考虑到前两类） 
</p>
</div>

<div id="outline-container-org04880ef" class="outline-3">
<h3 id="org04880ef">定义一个新的异常</h3>
<div class="outline-text-3" id="text-org04880ef">
<p>
不携带数据：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">SomethingWrong</span>  <span style="color: #ff4500;">;;</span> 
</pre>
</div>

<p>
携带数据的构造器
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">MyException</span> <span style="color: #51afef;">of</span> int <span style="color: #f0e68c;">*</span> string <span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #bbc2cf; background-color: #242730;">MyException</span> <span style="color: #f0e68c;">(</span>22<span style="color: #f0e68c;">,</span> <span style="color: #7bc275;">"err"</span> <span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span> 

<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> exn <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">MyException</span><span style="color: #f0e68c;">(</span>22<span style="color: #f0e68c;">,</span> <span style="color: #7bc275;">"err"</span><span style="color: #f0e68c;">)</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-org70a6381" class="outline-3">
<h3 id="org70a6381">抛出异常</h3>
<div class="outline-text-3" id="text-org70a6381">
<p>
raise是引发异常的通用手段。
failwith只能引发Failure这个类型的异常。
</p>
</div>

<div id="outline-container-orgcb04e4a" class="outline-4">
<h4 id="orgcb04e4a">raise</h4>
<div class="outline-text-4" id="text-orgcb04e4a">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #C57BDB;">raise</span> <span style="color: #f0e68c;">(</span> <span style="color: #bbc2cf; background-color: #242730;">MyException</span> <span style="color: #f0e68c;">(</span>233<span style="color: #f0e68c;">,</span><span style="color: #7bc275;">"error"</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
注意raise的返回类型： <code>'a</code>
这是一个范型，因为raise不会求值为某个值，而是抛出异常，因此它的作用是应付类型检查。
在 if / match等结构中，都要求分支的类型相同。raise的返回类型为 <code>'a</code> 使得正常返回值的分支和发出异常的分支能够相容。
</p>


<div class="org-src-container">
<pre class="src src-ocaml"> <span style="color: #C57BDB;">raise</span> <span style="color: #ff4500;">;;</span>

<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> exn <span style="color: #f0e68c;">-&gt;</span> 'a <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&lt;</span><span style="color: #51afef;">fun</span><span style="color: #f0e68c;">&gt;</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-orgcd66667" class="outline-4">
<h4 id="orgcd66667">failwith</h4>
<div class="outline-text-4" id="text-orgcd66667">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #C57BDB;">failwith</span> <span style="color: #7bc275;">"xxx"</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
等价于
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #C57BDB;">raise</span> <span style="color: #f0e68c;">(</span><span style="color: #C57BDB;">Failure</span> <span style="color: #7bc275;">"xxx"</span><span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org6470b7c" class="outline-3">
<h3 id="org6470b7c">捕获并处理异常</h3>
<div class="outline-text-3" id="text-org6470b7c">
<p>
用try with捕获异常后的行为应该是提供一个和表达式类型相同的值 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #51afef;">try</span> &#34920;&#36798;&#24335; <span style="color: #f0e68c;">:</span> <span style="color: #bbc2cf; background-color: #242730;">T</span> <span style="color: #51afef;">with</span>
<span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Exn1</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">e1</span> <span style="color: #f0e68c;">:</span> <span style="color: #bbc2cf; background-color: #242730;">T</span>
<span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Exn2</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">e2</span> <span style="color: #f0e68c;">:</span> <span style="color: #bbc2cf; background-color: #242730;">T</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">raise_some_exn</span><span style="color: #DFDFDF;"> a b</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">match</span> a<span style="color: #f0e68c;">,</span>b <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|</span> 0<span style="color: #f0e68c;">,</span>_ <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">SomethingWrong</span> 
  <span style="color: #f0e68c;">|</span> _<span style="color: #f0e68c;">,</span>0 <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #f0e68c;">(</span> <span style="color: #bbc2cf; background-color: #242730;">MyException</span> <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">(-</span>1<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">,</span> <span style="color: #7bc275;">"div by 0"</span> <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">)</span>
  <span style="color: #f0e68c;">|</span> _<span style="color: #f0e68c;">,</span>_ <span style="color: #f0e68c;">-&gt;</span> a<span style="color: #f0e68c;">/</span>b
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
<code>try with</code> 的目的是让异常消失，并在异常发生时赋予表达式一个值 （类型要和表达式的相同）
</p>

<p>
match则更加通用，分支的类型不必和被匹配的表达式的类型一致。
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">catch_exception</span><span style="color: #DFDFDF;"> a b</span> <span style="color: #f0e68c;">=</span> 
  <span style="color: #51afef;">try</span>
    raise_some_exn a b
  <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">SomethingWrong</span> <span style="color: #f0e68c;">-&gt;</span> 0 
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">MyException</span> <span style="color: #f0e68c;">(</span>i<span style="color: #f0e68c;">,</span>s<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> 4611686018427387903
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
用match也能实现异常的捕获+处理，但更加麻烦：必须要写 <code>exception</code> ！
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #51afef;">match</span> raise_some_exn 1 0 <span style="color: #51afef;">with</span> 
  <span style="color: #f0e68c;">|</span> <span style="color: #51afef;">exception</span> <span style="color: #f0e68c;">(</span><span style="color: #bbc2cf; background-color: #242730;">MyException</span> <span style="color: #f0e68c;">(</span> i<span style="color: #f0e68c;">,</span>s<span style="color: #f0e68c;">))</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>string_of_int i <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">^</span> s 
  <span style="color: #f0e68c;">|</span> <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">SomethingWrong</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">"something wrong"</span>
  <span style="color: #f0e68c;">|</span> x  <span style="color: #f0e68c;">-&gt;</span> string_of_int x 
<span style="color: #ff4500;">;;</span>


<span style="color: #51afef;">match</span>
  <span style="color: #51afef;">try</span> raise_some_exn 1 0 <span style="color: #51afef;">with</span> <span style="color: #62686E;">(*</span><span style="color: #62686E;">&#26681;&#25454;&#21457;&#29983;&#30340;&#24322;&#24120;&#31181;&#31867;&#26469;&#20026;&#34920;&#36798;&#24335;&#36171;&#20197;&#29305;&#27530;&#20540;</span><span style="color: #62686E;"> *)</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">SomethingWrong</span> <span style="color: #f0e68c;">-&gt;</span> 0 
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">MyException</span> <span style="color: #f0e68c;">(</span>i<span style="color: #f0e68c;">,</span>s<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span>  4611686018427387903 
<span style="color: #51afef;">with</span> <span style="color: #62686E;">(*</span><span style="color: #62686E;">&#26681;&#25454;&#36820;&#22238;&#20540;&#30340;&#24418;&#24335;&#26469;&#20915;&#23450;&#21518;&#32493;&#21160;&#20316;</span><span style="color: #62686E;"> *)</span>
<span style="color: #f0e68c;">|</span> 0 <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">"something wrong"</span>
<span style="color: #f0e68c;">|</span>  4611686018427387903   <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">"div 0"</span>
<span style="color: #f0e68c;">|</span> x <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">"result = "</span> <span style="color: #f0e68c;">^</span> string_of_int x
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org606091f" class="outline-2">
<h2 id="org606091f">定义二叉树类型 Binary Tree</h2>
<div class="outline-text-2" id="text-org606091f">
<p>
Leaf表示空节点，即不存放值，仅作为占位使用。
</p>

<p>
Node表示非空节点，是否为叶节点要看它是否有子节点。 
</p>

<p>
叶节点： <code>Node(value,Leaf,Leaf)</code>
非叶节点：左右子节点至少有一个不是 <code>Leaf</code> 
</p>
</div>

<div id="outline-container-org14ee4fd" class="outline-3">
<h3 id="org14ee4fd">用Tuples表示 | representation with tuples</h3>
<div class="outline-text-3" id="text-org14ee4fd">
</div>
<div id="outline-container-org820fd48" class="outline-4">
<h4 id="org820fd48">定义</h4>
<div class="outline-text-4" id="text-org820fd48">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'tp tree</span> <span style="color: #f0e68c;">=</span> 
<span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span> 
<span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #51afef;">of</span> 'tp <span style="color: #f0e68c;">*</span> 'tp tree <span style="color: #f0e68c;">*</span> 'tp tree
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org23618ef" class="outline-4">
<h4 id="org23618ef">创建对象</h4>
<div class="outline-text-4" id="text-org23618ef">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">a_tree</span> <span style="color: #f0e68c;">=</span>  <span style="color: #bbc2cf; background-color: #242730;">Node</span><span style="color: #f0e68c;">(</span>2<span style="color: #f0e68c;">,</span>
  <span style="color: #bbc2cf; background-color: #242730;">Node</span><span style="color: #f0e68c;">(</span>1<span style="color: #f0e68c;">,</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span><span style="color: #f0e68c;">,</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span><span style="color: #f0e68c;">),</span>
  <span style="color: #bbc2cf; background-color: #242730;">Node</span><span style="color: #f0e68c;">(</span>3<span style="color: #f0e68c;">,</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span><span style="color: #f0e68c;">,</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span><span style="color: #f0e68c;">)</span>
<span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgce7f86e" class="outline-4">
<h4 id="orgce7f86e">使用</h4>
<div class="outline-text-4" id="text-orgce7f86e">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">size_of_tree</span><span style="color: #DFDFDF;"> t</span> <span style="color: #f0e68c;">=</span> 
<span style="color: #51afef;">match</span> t <span style="color: #51afef;">with</span> 
<span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span> <span style="color: #f0e68c;">-&gt;</span> 0
<span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Node</span><span style="color: #f0e68c;">(</span>_<span style="color: #f0e68c;">,</span>l<span style="color: #f0e68c;">,</span>r<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> 1 <span style="color: #f0e68c;">+</span> size_of_tree l <span style="color: #f0e68c;">+</span> size_of_tree r
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
</div>






<div id="outline-container-org6026f7c" class="outline-3">
<h3 id="org6026f7c">用Records表示 | representation with records</h3>
<div class="outline-text-3" id="text-org6026f7c">
</div>
<div id="outline-container-org721f955" class="outline-4">
<h4 id="org721f955">定义</h4>
<div class="outline-text-4" id="text-org721f955">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a tree</span> <span style="color: #f0e68c;">=</span> 
<span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span>
<span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #51afef;">of</span> <span style="color: #f0e68c;">{</span> v <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">;</span> 
           l <span style="color: #f0e68c;">:</span> 'a tree <span style="color: #f0e68c;">;</span> 
           r <span style="color: #f0e68c;">:</span> 'a tree <span style="color: #f0e68c;">}</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org21e449e" class="outline-4">
<h4 id="org21e449e">创建对象</h4>
<div class="outline-text-4" id="text-org21e449e">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">a_tree</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #f0e68c;">{</span>v<span style="color: #f0e68c;">=</span>2<span style="color: #f0e68c;">;</span>
                   l<span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span><span style="color: #f0e68c;">{</span>v<span style="color: #f0e68c;">=</span>1<span style="color: #f0e68c;">;</span>l<span style="color: #f0e68c;">=</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span><span style="color: #f0e68c;">;</span>r<span style="color: #f0e68c;">=</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span><span style="color: #f0e68c;">};</span>
                   r<span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span><span style="color: #f0e68c;">{</span>v<span style="color: #f0e68c;">=</span>3<span style="color: #f0e68c;">;</span>l<span style="color: #f0e68c;">=</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span><span style="color: #f0e68c;">;</span>r<span style="color: #f0e68c;">=</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span><span style="color: #f0e68c;">}</span>
                  <span style="color: #f0e68c;">}</span> 
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4506e67" class="outline-4">
<h4 id="org4506e67">使用方法，匹配tree对象</h4>
<div class="outline-text-4" id="text-org4506e67">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span>  <span style="color: #5cEfFF;">size_of_tree</span><span style="color: #DFDFDF;"> tr</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">match</span> tr <span style="color: #51afef;">with</span> 
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Leaf</span> <span style="color: #f0e68c;">-&gt;</span>  0
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span><span style="color: #f0e68c;">{</span>v<span style="color: #f0e68c;">=</span>_<span style="color: #f0e68c;">;</span>l<span style="color: #f0e68c;">=</span>a<span style="color: #f0e68c;">;</span>r<span style="color: #f0e68c;">=</span>b<span style="color: #f0e68c;">}</span> <span style="color: #f0e68c;">-&gt;</span> 1<span style="color: #f0e68c;">+</span> size_of_tree a <span style="color: #f0e68c;">+</span> size_of_tree b 
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
（不要用 <code>val</code>  做变量名！）
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">is_member</span><span style="color: #DFDFDF;"> va t</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">match</span> t <span style="color: #51afef;">with</span> 
<span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span> 
<span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #f0e68c;">{</span>v<span style="color: #f0e68c;">=</span>v<span style="color: #f0e68c;">;</span>l<span style="color: #f0e68c;">=</span>l<span style="color: #f0e68c;">;</span>r<span style="color: #f0e68c;">=</span>r<span style="color: #f0e68c;">}</span> <span style="color: #f0e68c;">-&gt;</span> v<span style="color: #f0e68c;">=</span>va <span style="color: #f0e68c;">||</span> is_member va l <span style="color: #f0e68c;">||</span> is_member va r 
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
先序遍历 preorder traversal
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">preorder</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">t </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;">'a tree</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">:</span>  <span style="color: #FCCE7B;">'a list</span> <span style="color: #f0e68c;">=</span> 
  <span style="color: #51afef;">match</span> t <span style="color: #51afef;">with</span> 
  <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Node</span><span style="color: #f0e68c;">{</span>v<span style="color: #f0e68c;">=</span>v<span style="color: #f0e68c;">;</span>l<span style="color: #f0e68c;">=</span>l<span style="color: #f0e68c;">;</span>r<span style="color: #f0e68c;">=</span>r<span style="color: #f0e68c;">}</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[</span>v<span style="color: #f0e68c;">]</span> <span style="color: #f0e68c;">@</span> preorder l <span style="color: #f0e68c;">@</span> preorder r 
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
因append操作 <code>@</code> 开销太大（线性时间），因此改用 <code>::</code> 来将每个节点的值加入list
</p>

<p>
因此用一个输入参数res来记录上一次迭代过程的返回值
</p>



<pre class="example">
Node{v=1;l=Leaf;r=Leaf}   ==&gt; [1]

[2;1;3] == 2::[1;3]   =&gt; 2::(1::[3])

[mid;l;r] =&gt; mid :: [l;r]   =&gt; mid::( l::( [r] ) )
</pre>


<p>
先被应用 <code>preorder()</code> 的节点 先将值加入 <code>res</code> 队首 因此位置最终更靠后。 
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">preorder</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">res </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;">'a list</span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;">  </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">t </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;">'a tree</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">'a list</span> <span style="color: #f0e68c;">=</span> 
  <span style="color: #51afef;">match</span> t <span style="color: #51afef;">with</span> 
  <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span> <span style="color: #f0e68c;">-&gt;</span> res  <span style="color: #62686E;">(* </span><span style="color: #62686E;">&#19981;&#28155;&#21152;&#20803;&#32032;&#21040;res &#21363;&#21407;&#26679;&#36820;&#22238;</span><span style="color: #62686E;"> *)</span>
  <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Node</span><span style="color: #f0e68c;">{</span>v<span style="color: #f0e68c;">=</span>v<span style="color: #f0e68c;">;</span>l<span style="color: #f0e68c;">=</span>l<span style="color: #f0e68c;">;</span>r<span style="color: #f0e68c;">=</span>r<span style="color: #f0e68c;">}</span> <span style="color: #f0e68c;">-&gt;</span> v<span style="color: #f0e68c;">::(</span>preorder <span style="color: #f0e68c;">(</span>preorder res r<span style="color: #f0e68c;">)</span> l<span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
</div>
</div>





<div id="outline-container-org31aabb8" class="outline-2">
<h2 id="org31aabb8">定义自然数类型 natural numbers</h2>
<div class="outline-text-2" id="text-org31aabb8">
</div>
<div id="outline-container-org17b2279" class="outline-3">
<h3 id="org17b2279">定义 nat</h3>
<div class="outline-text-3" id="text-org17b2279">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">nat</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Zero</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Nextnum</span> <span style="color: #51afef;">of</span> nat <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb61cc6f" class="outline-3">
<h3 id="orgb61cc6f">创建nat对象</h3>
<div class="outline-text-3" id="text-orgb61cc6f">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">zero</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Zero</span> 
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">one</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Nextnum</span> zero 
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">two</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Nextnum</span> one 
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">three</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Nextnum</span> two 
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">four</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Nextnum</span> three <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgee25cca" class="outline-3">
<h3 id="orgee25cca">操作自然数</h3>
<div class="outline-text-3" id="text-orgee25cca">
</div>
<div id="outline-container-org1eae2c1" class="outline-4">
<h4 id="org1eae2c1">是否为0</h4>
<div class="outline-text-4" id="text-org1eae2c1">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">is_zero</span>  <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Zero</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">true</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Nextnum</span> _ <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org9953191" class="outline-4">
<h4 id="org9953191">前驱？</h4>
<div class="outline-text-4" id="text-org9953191">
<div class="org-src-container">
<pre class="src src-ocaml">  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">pred</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Zero</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">None</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Nextnum</span> rest <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> rest
  <span style="color: #ff4500;">;;</span>
<span style="color: #62686E;">(* </span><span style="color: #62686E;">=======================</span><span style="color: #62686E;"> *)</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">pred_e</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Zero</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">failwith</span> <span style="color: #7bc275;">"pred zero is undefined"</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Nextnum</span> rest <span style="color: #f0e68c;">-&gt;</span> rest
  <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org3d71b76" class="outline-4">
<h4 id="org3d71b76">加法运算</h4>
<div class="outline-text-4" id="text-org3d71b76">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">nat_add</span><span style="color: #DFDFDF;"> n1 n2</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">match</span> n1 <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Zero</span> <span style="color: #f0e68c;">-&gt;</span> n2
  <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Nextnum</span> x <span style="color: #f0e68c;">-&gt;</span> nat_add x  <span style="color: #f0e68c;">(</span><span style="color: #bbc2cf; background-color: #242730;">Nextnum</span> n2<span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-org6a85a12" class="outline-4">
<h4 id="org6a85a12">int和nat的相互转换</h4>
<div class="outline-text-4" id="text-org6a85a12">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">int_of_nat</span><span style="color: #DFDFDF;"> n</span> <span style="color: #f0e68c;">=</span> 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">int_of_nat_tr</span><span style="color: #DFDFDF;"> acc</span>  <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Zero</span> <span style="color: #f0e68c;">-&gt;</span> acc
    <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Nextnum</span> x <span style="color: #f0e68c;">-&gt;</span> int_of_nat_tr <span style="color: #f0e68c;">(</span>1<span style="color: #f0e68c;">+</span>acc<span style="color: #f0e68c;">)</span> x
  <span style="color: #f5deb3; font-weight: bold;">in</span>
  int_of_nat_tr 0 n
<span style="color: #ff4500;">;;</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span>  <span style="color: #5cEfFF;">nat_of_int</span><span style="color: #DFDFDF;"> i</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">nat_of_int_tr</span><span style="color: #DFDFDF;"> acc</span> <span style="color: #f0e68c;">=</span>  <span style="color: #51afef;">function</span>
      <span style="color: #f0e68c;">|</span>n <span style="color: #51afef;">when</span> n <span style="color: #f0e68c;">=</span> 0  <span style="color: #f0e68c;">-&gt;</span> acc 
      <span style="color: #f0e68c;">|</span>n <span style="color: #51afef;">when</span> n <span style="color: #f0e68c;">&gt;</span> 0 <span style="color: #f0e68c;">-&gt;</span> nat_of_int_tr <span style="color: #f0e68c;">(</span><span style="color: #bbc2cf; background-color: #242730;">Nextnum</span> acc<span style="color: #f0e68c;">)</span>  <span style="color: #f0e68c;">(</span>n<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">)</span> 
      <span style="color: #f0e68c;">|</span>_  <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">failwith</span> <span style="color: #7bc275;">"n cannot be postived"</span>
  <span style="color: #f5deb3; font-weight: bold;">in</span>
  nat_of_int_tr <span style="color: #bbc2cf; background-color: #242730;">Zero</span> i
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
注意这里模式中使用了 <code>when</code> ，因此最后要有一个通配模式 <code>_</code> .
否则将会有警告，即使模式包含了在逻辑上存在的所有情况：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f0e68c;">....</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|</span>n <span style="color: #51afef;">when</span> n <span style="color: #f0e68c;">=</span> 0  <span style="color: #f0e68c;">-&gt;</span> acc 
  <span style="color: #f0e68c;">|</span>n <span style="color: #51afef;">when</span> n <span style="color: #f0e68c;">&gt;</span> 0 <span style="color: #f0e68c;">-&gt;</span> nat_of_int_tr <span style="color: #f0e68c;">(</span><span style="color: #bbc2cf; background-color: #242730;">Nextnum</span> acc<span style="color: #f0e68c;">)</span>  <span style="color: #f0e68c;">(</span>n<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">)</span> 
  <span style="color: #f0e68c;">|</span>n <span style="color: #51afef;">when</span> n <span style="color: #f0e68c;">&lt;</span> 0  <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">failwith</span> <span style="color: #7bc275;">"n cannot be postived"</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
这种写法仍然会有警告：
</p>
<pre class="example">
[partial-match]: this pattern-matching is not exhaustive.
</pre>
</div>
</div>
</div>
</div>









<div id="outline-container-org28cfb91" class="outline-2">
<h2 id="org28cfb91">高阶函数</h2>
<div class="outline-text-2" id="text-org28cfb91">
<p>
在OCaml中，函数和普通的值处于同一地位。
所谓高阶函数，就是将函数作为参数/返回值的函数。
</p>
</div>

<div id="outline-container-org6f382e2" class="outline-3">
<h3 id="org6f382e2">将函数作为参数</h3>
<div class="outline-text-3" id="text-org6f382e2">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">double</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> 2 <span style="color: #f0e68c;">*</span> x <span style="color: #ff4500;">;;</span> <span style="color: #62686E;">(* </span><span style="color: #62686E;">&#20004;&#20493;</span><span style="color: #62686E;"> *)</span> 

<span style="color: #62686E;">(* </span><span style="color: #62686E;">&#22235;&#20493;</span><span style="color: #62686E;"> *)</span>
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">fourth</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> double <span style="color: #f0e68c;">(</span> double x<span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span> 
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">fourth'</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> x <span style="color: #f0e68c;">|&gt;</span> double <span style="color: #f0e68c;">|&gt;</span> double <span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">square</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> x<span style="color: #f0e68c;">*</span>x <span style="color: #ff4500;">;;</span> <span style="color: #62686E;">(* </span><span style="color: #62686E;">&#24179;&#26041;</span><span style="color: #62686E;"> *)</span>

<span style="color: #62686E;">(* </span><span style="color: #62686E;">&#22235;&#27425;&#26041;</span><span style="color: #62686E;"> *)</span>
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">quad</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> square <span style="color: #f0e68c;">(</span>square x<span style="color: #f0e68c;">)</span> 
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">quad'</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> x <span style="color: #f0e68c;">|&gt;</span> square <span style="color: #f0e68c;">|&gt;</span> square <span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
上面这两个例子有某种相似之处：都apply某个函数两次
因此可以编写一个高阶函数，它将某函数f应用两次到参数上。
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">apply_twice</span><span style="color: #DFDFDF;"> f x</span> <span style="color: #f0e68c;">=</span> f <span style="color: #f0e68c;">(</span>f x<span style="color: #f0e68c;">)</span> 
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">apply_twice'</span><span style="color: #DFDFDF;"> f x</span> <span style="color: #f0e68c;">=</span> x <span style="color: #f0e68c;">|&gt;</span> f <span style="color: #f0e68c;">|&gt;</span> f <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
因此可以重写上面的函数：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">fourth</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> apply_twice double x <span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">quad</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> apply_twice square x <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-org285a63d" class="outline-3">
<h3 id="org285a63d">将函数作为返回值</h3>
<div class="outline-text-3" id="text-org285a63d">
<div class="org-src-container">
<pre class="src src-ocaml">apply_twice double <span style="color: #ff4500;">;;</span>

<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&lt;</span><span style="color: #51afef;">fun</span><span style="color: #f0e68c;">&gt;</span>
</pre>
</div>
<p>
通过部分应用apply<sub>twice</sub>，返回了一个新的函数
</p>
</div>
</div>

<div id="outline-container-orgf0fecf6" class="outline-3">
<h3 id="orgf0fecf6">更多的高阶函数例子</h3>
<div class="outline-text-3" id="text-orgf0fecf6">
</div>
<div id="outline-container-org6a64aea" class="outline-4">
<h4 id="org6a64aea">apply</h4>
<div class="outline-text-4" id="text-org6a64aea">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">apply</span><span style="color: #DFDFDF;"> f x</span> <span style="color: #f0e68c;">=</span> f x <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc5934f9" class="outline-4">
<h4 id="orgc5934f9">pipeline</h4>
<div class="outline-text-4" id="text-orgc5934f9">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">pipeline</span><span style="color: #DFDFDF;"> x f</span> <span style="color: #f0e68c;">=</span> f x 
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">(|&gt;)</span> <span style="color: #f0e68c;">=</span> pipeline <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org50cf263" class="outline-4">
<h4 id="org50cf263">compose</h4>
<div class="outline-text-4" id="text-org50cf263">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">compose</span><span style="color: #DFDFDF;"> f g x</span> <span style="color: #f0e68c;">=</span> f <span style="color: #f0e68c;">(</span>g x<span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
usage: 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">square_then_double</span> <span style="color: #f0e68c;">=</span> compose double square <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org06a853a" class="outline-4">
<h4 id="org06a853a">both</h4>
<div class="outline-text-4" id="text-org06a853a">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">both</span><span style="color: #DFDFDF;"> f g x</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span>f x<span style="color: #f0e68c;">,</span>g x<span style="color: #f0e68c;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgecf058b" class="outline-4">
<h4 id="orgecf058b">cond</h4>
<div class="outline-text-4" id="text-orgecf058b">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">cond</span><span style="color: #DFDFDF;"> p f g x</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">if</span> p <span style="color: #51afef;">then</span> f x <span style="color: #51afef;">else</span> g x <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org1081601" class="outline-3">
<h3 id="org1081601">map/reduce</h3>
<div class="outline-text-3" id="text-org1081601">
<p>
map/reduce 是典型的高阶函数，在逻辑上它们都接收一个函数作为参数。
map将输入的函数/运算应用到list的每个元素上，并返回一个由运算结果构成的list
reduce利用输入的函数/操作将list中的元素合成为一个结果 
</p>
</div>

<div id="outline-container-org6da454d" class="outline-4">
<h4 id="org6da454d">map</h4>
<div class="outline-text-4" id="text-org6da454d">
<p>
map将一个list映射为另一个list
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">addone</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>h<span style="color: #f0e68c;">+</span>1<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">::</span> <span style="color: #f0e68c;">(</span>addone t<span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">concat_3110</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>h<span style="color: #f0e68c;">^</span> <span style="color: #7bc275;">"3110"</span> <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">::</span> <span style="color: #f0e68c;">(</span>concat_3110 t<span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
这两个函数都是将列表中的某个元素变换成另一个，并返回由这些新元素构成的列表。
它们的形式也是十分相似的：将变换后的首个元素 链接上 (递归调用list的剩余部分）
</p>

<p>
因此我们能通过抽取出相同的代码，形成一个新的函数，不同的部分作为参数传入，这就是 <code>map</code> / <code>transform</code>  。
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">map</span><span style="color: #62686E;">(*</span><span style="color: #62686E;">transform</span><span style="color: #62686E;">*)</span><span style="color: #DFDFDF;"> func</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>func h<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">::</span> <span style="color: #f0e68c;">(</span>map func t<span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
OCaml中已经有库函数 <code>List.map</code> (在C++中Map函数是 <code>std::transform</code> )
</p>

<p>
通过map重新定义上面的两个函数 （部分应用map）
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">addone'</span> <span style="color: #f0e68c;">=</span> map <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">-&gt;</span> x<span style="color: #f0e68c;">+</span>1<span style="color: #f0e68c;">)</span>
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">concat_3110'</span> <span style="color: #f0e68c;">=</span> map <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">s</span> <span style="color: #f0e68c;">-&gt;</span> s <span style="color: #f0e68c;">^</span> <span style="color: #7bc275;">"3110"</span> <span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
将int list转换为string list
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">strlist_of_intlist</span> <span style="color: #f0e68c;">=</span> map string_of_int <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="orgebd5087"></a>利用副作用来观察map的作用顺序<br />
<div class="outline-text-5" id="text-orgebd5087">
<p>
我们自己实现的map函数是有点问题的。
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">p</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> print_int x<span style="color: #f0e68c;">;</span> print_newline<span style="color: #f0e68c;">();</span> x<span style="color: #f0e68c;">+</span>1

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">lst</span> <span style="color: #f0e68c;">=</span> map p <span style="color: #f0e68c;">[</span>1<span style="color: #f0e68c;">;</span>2<span style="color: #f0e68c;">]</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
执行结果如下：
</p>
<pre class="example">
2
1

val lst : int list = [2; 3]
</pre>
<p>
虽然 <code>+1</code> 的转换结果是正确的，但我们期望的从左到右输出list元素却不符合预期，打印顺序是刚好相反的。
原因出在我们的 <code>map</code> 实现上，对递归定义的函数来说，先调用的后执行。因此最后一个元素是最先被输出的。
</p>

<p>
我们再来看这个map的实现：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">map</span><span style="color: #62686E;">(*</span><span style="color: #62686E;">transform</span><span style="color: #62686E;">*)</span><span style="color: #DFDFDF;"> func</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
   <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[]</span>
   <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>func h<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">::</span> <span style="color: #f0e68c;">(</span>map func t<span style="color: #f0e68c;">)</span>
 <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
原因在于 (func h) 这个表达式晚于 <code>(map func t)</code> 被求值。
在OCaml中子表达式的求值顺序是不确定的，这要依赖于具体实现，在这个地方能发现其求值顺序是从右到左的。
因此我们要想个办法强制让 <code>(func h)</code> 先执行：
使用 <code>let</code> ！！
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">map</span><span style="color: #DFDFDF;"> func</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">hh</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span>func h<span style="color: #f0e68c;">)</span> <span style="color: #f5deb3; font-weight: bold;">in</span> hh<span style="color: #f0e68c;">::(</span>map func t<span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
List.map的行为就和这个新的map相同。因此最好使用这个库函数。
</p>

<p>
<b>副作用是对求值顺序敏感的</b> ，输出和抛出异常都属于副作用，这时要注意求值顺序（let）
</p>
</div>
</li>




<li><a id="org7ecff32"></a>map和尾递归<br />
<div class="outline-text-5" id="text-org7ecff32">
<p>
想使用尾递归的目的是优化执行时间，很容易能写出一个尾递归的map
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">map</span><span style="color: #DFDFDF;"> func lst</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">map_tr</span><span style="color: #DFDFDF;"> acc func</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> acc
    <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> map_tr <span style="color: #f0e68c;">(</span>acc <span style="color: #f0e68c;">@</span> <span style="color: #f0e68c;">[</span>func h<span style="color: #f0e68c;">])</span> func t 
  <span style="color: #f5deb3; font-weight: bold;">in</span>
  map_tr <span style="color: #f0e68c;">[]</span> func lst
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<pre class="example">
千万注意 =@= 的操作数是两个list，因此对一个元素用 =@= 前要将它用 =[]= 包裹起来。
</pre>
<p>
但是这个实现中有个很扎眼的 <code>@</code> 尾部追加，它导致了线性时间。因此整个算法的时间大概是 O(n<sup>2</sup>) 
因此我们采用对list的惯用操作：先用cons创建list，再反转list
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">map</span><span style="color: #DFDFDF;"> func lst</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">map_tr</span><span style="color: #DFDFDF;"> acc func</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #FCCE7B;">List.</span>rev acc
    <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> map_tr <span style="color: #f0e68c;">(</span>acc <span style="color: #f0e68c;">@</span> <span style="color: #f0e68c;">[</span>func h<span style="color: #f0e68c;">])</span> func t 
  <span style="color: #f5deb3; font-weight: bold;">in</span>
  map_tr <span style="color: #f0e68c;">[]</span> func lst
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</li>
</ul>
</div>


<div id="outline-container-org6bfd416" class="outline-4">
<h4 id="org6bfd416">抽象原则</h4>
<div class="outline-text-4" id="text-org6bfd416">
<p>
抽取出重复出现的代码模式，不要重复编写它们。
不同的东西作为参数，让使用者负责传入。
</p>
</div>
</div>


<div id="outline-container-org29aa84c" class="outline-4">
<h4 id="org29aa84c">fold</h4>
<div class="outline-text-4" id="text-org29aa84c">
<p>
将一个list映射为一个新的list元素。标准库中提供了 <code>fold</code> 函数
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">sum</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> 0
  <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> h <span style="color: #f0e68c;">+</span> <span style="color: #f0e68c;">(</span>sum t<span style="color: #f0e68c;">)</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">concat</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">""</span>
  <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> h <span style="color: #f0e68c;">^</span> <span style="color: #f0e68c;">(</span>concat t<span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
同样能发现重复出现的模式：
</p>

<p>
不同之处在于，这两个函数是将一个二元运算施加到 首个元素 和 （递归调用list的剩余部分）
</p>

<p>
将相同的模式抽出作为函数体，将不同的部分设为参数，让使用者负责提供：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">fold_right</span><span style="color: #DFDFDF;"> op init</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> init
  <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> op  h <span style="color: #f0e68c;">(</span>fold_right op init t<span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
同样重写上面两个函数：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">sum'</span> <span style="color: #f0e68c;">=</span> fold_right 0 <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">+</span> <span style="color: #f0e68c;">)</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">concat'</span> <span style="color: #f0e68c;">=</span> fold_right <span style="color: #7bc275;">""</span> <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">^</span> <span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="org2aacd1e"></a>尾递归的fold<br />
<div class="outline-text-5" id="text-org2aacd1e">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">fold</span><span style="color: #DFDFDF;"> op init lst</span> <span style="color: #f0e68c;">=</span> 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">fold_tr</span><span style="color: #DFDFDF;"> acc op</span>  <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span> 
    <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> acc 
    <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> fold_tr <span style="color: #f0e68c;">(</span>op h acc<span style="color: #f0e68c;">)</span> op t
  <span style="color: #f5deb3; font-weight: bold;">in</span>
   fold_tr init op lst 
  <span style="color: #ff4500;">;;</span> 
</pre>
</div>
</div>
</li>



<li><a id="org14037f5"></a>fold的结合性<br />
<div class="outline-text-5" id="text-org14037f5">
<p>
在这个函数中我们观察op作用到list中的元素的顺序，由于后调用的函数先返回（栈的性质：先进后出，后进先出）
因此后面的reduce调用会先进行计算，反应到list中的元素的计算顺序就是：从list尾部的元素开始向头部进行op运算：
也可以说，运算op是右结合的。
</p>

<p>
有一个库函数反应了这一点：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #FCCE7B;">List.</span>fold_right f list init <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
它计算过程是
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #FCCE7B;">List.</span>fold_right f <span style="color: #f0e68c;">[</span>a<span style="color: #f0e68c;">;</span>b<span style="color: #f0e68c;">;</span>c<span style="color: #f0e68c;">]</span> init <span style="color: #f0e68c;">==</span> f a <span style="color: #f0e68c;">(</span>f b <span style="color: #f0e68c;">(</span>f c init<span style="color: #f0e68c;">))</span> 
</pre>
</div>

<p>
这种fold（reduce）就是上面实现过的函数：
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">fold_right</span><span style="color: #DFDFDF;"> init f</span>  <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> init
    <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> f h <span style="color: #f0e68c;">(</span>fold init f t<span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>


<p>
对称地，也有一个库函数： <code>List.fold_left</code> ，它从list头部向list尾部应用op运算。
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">fold_left</span><span style="color: #DFDFDF;"> init f lst</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">impl</span><span style="color: #DFDFDF;"> acc f</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> acc
    <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> impl <span style="color: #f0e68c;">(</span>f acc h<span style="color: #f0e68c;">)</span> f t
  <span style="color: #f5deb3; font-weight: bold;">in</span>
  impl init f lst
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
务必要注意那些不满足“结合性”的运算，对这种运算要严格区分“从右侧开始折叠”/“从左侧开始折叠”的概念。
（如：减法）
</p>

<p>
另外，对于满足结合性的运算，优先考虑使用fold<sub>left</sub>，因为它是尾递归（迭代）。
对于那些仅满足右结合性的运算，若不想使用非尾递归的 <code>fold_right</code> ，则可以将list反转（ <code>List.rev</code> ），再对其进行 <code>fold_left</code>
</p>

<p>
综合这些，可归纳出这两种版本的fold函数的异同：
</p>
<ul class="org-ul">
<li>fold<sub>left和fold</sub><sub>right的求值顺序不同</sub></li>
<li>fold<sub>left是尾递归</sub>, 而fold<sub>right则不是</sub></li>
<li>两个函数的list元素类型和acc/init类型是无关的, 并且返回类型都是acc/init的类型.</li>
</ul>
</div>
</li>


<li><a id="org9e66b08"></a>用标签参数辅助函数调用<br />
<div class="outline-text-5" id="text-org9e66b08">
<p>
不论是那种fold函数, 在使用他们的时候会发现有时候很难记得参数的顺序 (以及类型)
更不用说比它们更复杂的函数了. 因此一个不依赖参数顺序的函数调用方式是很有用的
而标签参数则能做到这点, 只需要在传入参数时同时指明参数名称即可.
如: 标准库中有模块 <code>ListLabels</code> , 这里定义了带标签版本的fold函数
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #FCCE7B;">ListLabels.</span>fold_left <span style="color: #ff4500;">;;</span>

<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> <span style="color: #a991f1;">f</span><span style="color: #f0e68c;">:(</span>'a <span style="color: #f0e68c;">-&gt;</span> 'b <span style="color: #f0e68c;">-&gt;</span> 'a<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">init</span><span style="color: #f0e68c;">:</span>'a <span style="color: #f0e68c;">-&gt;</span> 'b list <span style="color: #f0e68c;">-&gt;</span> 'a <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&lt;</span><span style="color: #51afef;">fun</span><span style="color: #f0e68c;">&gt;</span> 
</pre>
</div>
<p>
从返回的类型来看, 三个参数中有两个是标签参数: <code>f</code> 和 <code>init</code>
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #FCCE7B;">ListLabels.</span>fold_left <span style="color: #f0e68c;">[</span>1<span style="color: #f0e68c;">;</span>2<span style="color: #f0e68c;">;</span>3<span style="color: #f0e68c;">]</span> <span style="color: #a991f1;">~init</span><span style="color: #f0e68c;">:</span>1 <span style="color: #a991f1;">~f</span><span style="color: #f0e68c;">:</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">x y</span> <span style="color: #f0e68c;">-&gt;</span> x<span style="color: #f0e68c;">*</span>y<span style="color: #f0e68c;">)</span>  <span style="color: #ff4500;">;;</span> 
</pre>
</div>
<p>
可以换成另外一种顺序:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #FCCE7B;">ListLabels.</span>fold_left  <span style="color: #a991f1;">~f</span><span style="color: #f0e68c;">:</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">x y</span> <span style="color: #f0e68c;">-&gt;</span> x<span style="color: #f0e68c;">*</span>y<span style="color: #f0e68c;">)</span>  <span style="color: #f0e68c;">[</span>1<span style="color: #f0e68c;">;</span> 2<span style="color: #f0e68c;">;</span> 3<span style="color: #f0e68c;">]</span>  <span style="color: #a991f1;">~init</span><span style="color: #f0e68c;">:</span>1<span style="color: #ff4500;">;;</span> 
</pre>
</div>
</div>
</li>


<li><a id="org434a4c2"></a>作为标签参数的函数<br />
<div class="outline-text-5" id="text-org434a4c2">
<p>
若一个标签参数表示一个函数, 并且要限制函数也是一个声明含标签参数
和普通的声明不同, 区别在于这种函数的表示中不用为其标签参数名前面加上 <code>~</code> 
<code>~标签: 参数本身</code>
<code>~op: (f:  acc:'a -&gt; elt:'b -&gt; 'a)</code>
注意, 为op传入的函数必须在对应位置也是有标签参数的.
</p>

<p>
带标签参数的fold<sub>left</sub>
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">fold_left</span><span style="color: #DFDFDF;"> </span><span style="color: #a991f1;">~init</span><span style="color: #f0e68c;">:</span><span style="color: #DFDFDF;">acc </span><span style="color: #a991f1;">~op</span><span style="color: #f0e68c;">:(</span><span style="color: #a991f1;">f</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">:</span><span style="color: #DFDFDF;"> acc</span><span style="color: #f0e68c;">:</span><span style="color: #DFDFDF;">'a</span><span style="color: #f0e68c;">-&gt;</span><span style="color: #DFDFDF;"> </span><span style="color: #a991f1;">e</span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> 'b </span><span style="color: #f0e68c;">-&gt;</span><span style="color: #FCCE7B;"> 'a</span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">match</span> lst <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> acc
  <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> fold_left <span style="color: #a991f1;">~init</span><span style="color: #f0e68c;">:(</span>f <span style="color: #a991f1;">~acc</span><span style="color: #f0e68c;">:</span>acc <span style="color: #a991f1;">~e</span><span style="color: #f0e68c;">:</span>h<span style="color: #f0e68c;">)</span>   <span style="color: #a991f1;">~op</span><span style="color: #f0e68c;">:</span>f  t
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
尤其注意这个定义要求传入op的函数的两个参数都是要带标签的, 并且标签分别是 acc 和 e .因此这个op无法接收 <code>( * )</code> , 因为它是不带有指定标签的. 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">s</span> <span style="color: #f0e68c;">=</span> fold_left  <span style="color: #a991f1;">~op</span><span style="color: #f0e68c;">:(</span> <span style="color: #f0e68c;">+</span> <span style="color: #f0e68c;">)</span> <span style="color: #a991f1;">~init</span><span style="color: #f0e68c;">:</span>0 <span style="color: #f0e68c;">[</span>1<span style="color: #f0e68c;">;</span>2<span style="color: #f0e68c;">;</span>3<span style="color: #f0e68c;">]</span> <span style="color: #ff4500;">;;</span>
                       <span style="color: #f0e68c;">^^^^^</span>
<span style="color: #bbc2cf; background-color: #242730;">Error</span><span style="color: #f0e68c;">:</span> <span style="color: #bbc2cf; background-color: #242730;">This</span> expression has <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">int</span> <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f0e68c;">-&gt;</span> int
    but an expression was expected <span style="color: #51afef;">of</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">acc</span><span style="color: #f0e68c;">:</span>int <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">e</span><span style="color: #f0e68c;">:</span>'a <span style="color: #f0e68c;">-&gt;</span> int
</pre>
</div>
<p>
解决这个问题可以为加法重新定义一个带标签的函数:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">add</span><span style="color: #DFDFDF;"> </span><span style="color: #a991f1;">~acc</span><span style="color: #f0e68c;">:</span><span style="color: #DFDFDF;">x </span><span style="color: #a991f1;">~e</span><span style="color: #f0e68c;">:</span><span style="color: #DFDFDF;">y</span> <span style="color: #f0e68c;">=</span> x<span style="color: #f0e68c;">+</span>y <span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
而下面这个实现则取消了对标签参数op的限制, 它可以是任何满足这个类型的函数, 其参数是无需带有标签的 (注意op和f)  
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span>  <span style="color: #5cEfFF;">fold_left'</span><span style="color: #DFDFDF;"> </span><span style="color: #a991f1;">~init</span><span style="color: #f0e68c;">:</span><span style="color: #DFDFDF;">acc </span><span style="color: #a991f1;">~op</span><span style="color: #f0e68c;">:(</span><span style="color: #a991f1;">f</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> 'a </span><span style="color: #f0e68c;">-&gt;</span><span style="color: #FCCE7B;"> 'b </span><span style="color: #f0e68c;">-&gt;</span><span style="color: #FCCE7B;"> 'a</span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">match</span> lst <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> acc
  <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> fold_left' <span style="color: #a991f1;">~init</span><span style="color: #f0e68c;">:(</span>f acc h<span style="color: #f0e68c;">)</span>  <span style="color: #a991f1;">~op</span><span style="color: #f0e68c;">:</span>f t
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
因此这个版本能够接收 <code>( * )</code> :
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">s</span> <span style="color: #f0e68c;">=</span> fold_left' <span style="color: #a991f1;">~op</span><span style="color: #f0e68c;">:(</span> <span style="color: #f0e68c;">+</span> <span style="color: #f0e68c;">)</span> <span style="color: #a991f1;">~init</span><span style="color: #f0e68c;">:</span>0 <span style="color: #f0e68c;">[</span>1<span style="color: #f0e68c;">;</span>2<span style="color: #f0e68c;">;</span>3<span style="color: #f0e68c;">]</span> <span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">s</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 6
</pre>
</div>
</div>
</li>



<li><a id="orgc2b9073"></a>应用fold的例子<br />
<div class="outline-text-5" id="text-orgc2b9073">
<p>
fold函数不仅能完成一些"求和"的计算, 也能用来实现filter和map.
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">length</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span>
  fold_left <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">len _</span> <span style="color: #f0e68c;">-&gt;</span> len<span style="color: #f0e68c;">+</span>1<span style="color: #f0e68c;">)</span> 0 lst <span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">rev</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span>
  fold_left <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">e acc</span> <span style="color: #f0e68c;">-&gt;</span> e<span style="color: #f0e68c;">::</span>acc<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">[]</span> lst <span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
注意下面这两个函数的实现都采用了fold<sub>right</sub>(从右到左), 这是因为传入的函数采用了cons来合并结果,
这样最终返回的list的顺序才和原来一致.
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">map</span><span style="color: #DFDFDF;"> f lst</span> <span style="color: #f0e68c;">=</span>
  fold_right <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">e acc</span><span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>f e<span style="color: #f0e68c;">)::</span>acc<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">[]</span> lst <span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">filter</span><span style="color: #DFDFDF;"> p lst</span> <span style="color: #f0e68c;">=</span>
  fold_right <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">e acc</span><span style="color: #f0e68c;">-&gt;</span> <span style="color: #51afef;">if</span> p e <span style="color: #51afef;">then</span> e<span style="color: #f0e68c;">::</span>acc <span style="color: #51afef;">else</span> acc<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">[]</span> lst <span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
在OCaml标准库中,这两个函数不是用fold实现的.可能这样的可读性更好. 另一方面, 用fold实现其它函数避免了自己写递归函数.
</p>
</div>
</li>







<li><a id="orgb5446da"></a>对比使用递归/fold/库函数的三种方案<br />
<div class="outline-text-5" id="text-orgb5446da">
<p>
要编写一个作用在 bool list上的and函数,有三种写法:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">list_and_rec</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">true</span>
  <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> h <span style="color: #f0e68c;">&amp;&amp;</span> list_and_rec t
<span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">list_and_fold</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span>
  fold_left <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">e acc</span> <span style="color: #f0e68c;">-&gt;</span> acc <span style="color: #f0e68c;">&amp;&amp;</span> e <span style="color: #f0e68c;">)</span> <span style="color: #a991f1;">true</span> lst
<span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">list_and_lib</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #FCCE7B;">List.</span>for_all <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">-&gt;</span> x<span style="color: #f0e68c;">)</span> lst
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
因为实现中包含了短路与,因此第一种和第三种的实现在某个元素为false时就会立即返回.
而第二种仍要遍历整个list. 
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org7c6f7a9" class="outline-4">
<h4 id="org7c6f7a9">filter</h4>
<div class="outline-text-4" id="text-org7c6f7a9">
<p>
过滤：接收一个函数作为谓词，将list中满足谓词的元素组成的新list返回。
</p>

<p>
从list中过滤出奇数/偶数 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">evens</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #51afef;">if</span> <span style="color: #f0e68c;">(</span>h <span style="color: #f0e68c;">mod</span> 2<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">==</span> 0 <span style="color: #51afef;">then</span> h<span style="color: #f0e68c;">::(</span>evens t<span style="color: #f0e68c;">)</span> <span style="color: #51afef;">else</span>  t
<span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">odds</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #51afef;">if</span> <span style="color: #f0e68c;">(</span>h <span style="color: #f0e68c;">mod</span> 2<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">!=</span> 0 <span style="color: #51afef;">then</span> h<span style="color: #f0e68c;">::(</span>odds t<span style="color: #f0e68c;">)</span> <span style="color: #51afef;">else</span> t
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
显然这两个函数几乎就是一样的，因此将相同的部分抽取出来作为函数体，不同的部分提取为参数
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">filter</span><span style="color: #DFDFDF;"> p</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #51afef;">if</span> <span style="color: #f0e68c;">(</span>p h<span style="color: #f0e68c;">)</span> <span style="color: #51afef;">then</span> h<span style="color: #f0e68c;">::(</span>filter p t<span style="color: #f0e68c;">)</span> <span style="color: #51afef;">else</span> filter p t
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">evens</span> <span style="color: #f0e68c;">=</span> filter <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">i</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>i <span style="color: #f0e68c;">mod</span> 2<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span> 0 <span style="color: #f0e68c;">)</span>
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">odds</span> <span style="color: #f0e68c;">=</span> filter <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">i</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>i <span style="color: #f0e68c;">mod</span> 2<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">!=</span> 0 <span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>


<p>
目前这个filter函数不是尾递归的，可以将它改写成尾递归版本。
一般地改写成尾递归的方法如下：
</p>

<ol class="org-ol">
<li>为递归定义的函数增加一个 acc 参数，作为每次的累计值。</li>
<li>为递归的平凡情况返回acc</li>
<li>在每次递归调用时更新acc</li>
</ol>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">filter</span><span style="color: #DFDFDF;"> p lst</span> <span style="color: #f0e68c;">=</span> 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">impl</span><span style="color: #DFDFDF;"> acc p</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #FCCE7B;">List.</span>rev acc 
    <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> impl <span style="color: #f0e68c;">(</span><span style="color: #51afef;">if</span> <span style="color: #f0e68c;">(</span>p h<span style="color: #f0e68c;">)</span> <span style="color: #51afef;">then</span> h<span style="color: #f0e68c;">::</span>acc <span style="color: #51afef;">else</span> acc<span style="color: #f0e68c;">)</span> p t 
  <span style="color: #f5deb3; font-weight: bold;">in</span>
  impl <span style="color: #f0e68c;">[]</span> p lst 
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
这个例子不完全符合上面的三步，主要是为了避免使用list的添加到尾部的操作（线性时间）
而选择了用 <code>::</code> (cons)来更新acc，因此最后得到acc的顺序是反的，最后返回时需要List.rev来反转列表。
</p>
</div>
</div>



<div id="outline-container-orgc0b4f60" class="outline-4">
<h4 id="orgc0b4f60">tree版本的map/fold/filter</h4>
<div class="outline-text-4" id="text-orgc0b4f60">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a tree</span> <span style="color: #f0e68c;">=</span>
    <span style="color: #bbc2cf; background-color: #242730;">Leaf</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #51afef;">of</span> 'a <span style="color: #f0e68c;">*</span> 'a tree <span style="color: #f0e68c;">*</span> 'a tree
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">tree_map</span><span style="color: #DFDFDF;"> func</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Leaf</span>
  <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #f0e68c;">(</span>v<span style="color: #f0e68c;">,</span>l<span style="color: #f0e68c;">,</span>r<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span><span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">(</span>func v<span style="color: #f0e68c;">),(</span>tree_map func l<span style="color: #f0e68c;">),(</span>tree_map func r<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">tree_fold</span><span style="color: #DFDFDF;"> init op</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Leaf</span> <span style="color: #f0e68c;">-&gt;</span> init
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span> <span style="color: #f0e68c;">(</span>v<span style="color: #f0e68c;">,</span>l<span style="color: #f0e68c;">,</span>r<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> op v <span style="color: #f0e68c;">(</span>tree_fold init op l<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>tree_fold init op r<span style="color: #f0e68c;">)</span> 
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
这个fold的区别在于op是一个三元运算, 第一个参数是当前节点的值, 第二三个参数是左右子树的递归计算结果
</p>

<p>
应用tree<sub>fold</sub>:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">size</span><span style="color: #DFDFDF;"> t</span> <span style="color: #f0e68c;">=</span>
  tree_fold 0 <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">_ l r</span> <span style="color: #f0e68c;">-&gt;</span> 1<span style="color: #f0e68c;">+</span>l<span style="color: #f0e68c;">+</span>r<span style="color: #f0e68c;">)</span>  t
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">depth</span><span style="color: #DFDFDF;"> t</span> <span style="color: #f0e68c;">=</span>
  tree_fold 0 <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">_ l r</span> <span style="color: #f0e68c;">-&gt;</span> 1<span style="color: #f0e68c;">+</span> <span style="color: #f0e68c;">(</span>max l r<span style="color: #f0e68c;">))</span> t
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
用先序遍历的方式生成list 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">preorder</span><span style="color: #DFDFDF;"> t</span> <span style="color: #f0e68c;">=</span>
  tree_fold <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">e l r</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[</span>e<span style="color: #f0e68c;">]</span> <span style="color: #f0e68c;">@</span> l <span style="color: #f0e68c;">@</span> r <span style="color: #f0e68c;">)</span> t
<span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>




<div id="outline-container-orgddbab1c" class="outline-4">
<h4 id="orgddbab1c">流水线 (流式操作 管道符)</h4>
<div class="outline-text-4" id="text-orgddbab1c">
<p>
来考虑计算 1<sup>2</sup> + &#x2026; + n<sup>2</sup>
用递归
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">sum_square</span><span style="color: #DFDFDF;"> n</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">loop</span><span style="color: #DFDFDF;"> acc i</span>  <span style="color: #f0e68c;">=</span>
    <span style="color: #51afef;">if</span> i<span style="color: #f0e68c;">&gt;</span>n <span style="color: #51afef;">then</span> acc
    <span style="color: #51afef;">else</span> loop acc<span style="color: #f0e68c;">+(</span>i<span style="color: #f0e68c;">*</span>i<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>i<span style="color: #f0e68c;">+</span>1<span style="color: #f0e68c;">)</span>
  <span style="color: #f5deb3; font-weight: bold;">in</span>
  loop 0 1
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
也可以用流式操作+fold/map 
先需要有一个容器:1,&#x2026;,n
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">--</span> <span style="color: #f0e68c;">)</span> i j <span style="color: #f0e68c;">=</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">loop</span><span style="color: #DFDFDF;"> acc i j</span> <span style="color: #f0e68c;">=</span>
    <span style="color: #51afef;">if</span> i<span style="color: #f0e68c;">&gt;</span>j <span style="color: #51afef;">then</span> acc
    <span style="color: #51afef;">else</span> loop <span style="color: #f0e68c;">(</span>j<span style="color: #f0e68c;">::</span>acc<span style="color: #f0e68c;">)</span> i <span style="color: #f0e68c;">(</span>j<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">)</span>
  <span style="color: #f5deb3; font-weight: bold;">in</span>
  loop <span style="color: #f0e68c;">[]</span> i j
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
在对这个list作用上fold/map运算
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">sum_square</span><span style="color: #DFDFDF;"> n</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #f0e68c;">(</span>1 <span style="color: #f0e68c;">--</span> n<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">|&gt;</span> <span style="color: #f0e68c;">(</span>fold_left <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">acc e</span> <span style="color: #f0e68c;">-&gt;</span> acc<span style="color: #f0e68c;">+</span>e<span style="color: #f0e68c;">*</span>e<span style="color: #f0e68c;">)</span> 0<span style="color: #f0e68c;">)</span> 
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
下面这个版本虽然没有直接用fold的简洁,但是含义更加清楚: 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">sum</span> <span style="color: #f0e68c;">=</span> fold_left <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">acc e</span> <span style="color: #f0e68c;">-&gt;</span> acc<span style="color: #f0e68c;">+</span>e<span style="color: #f0e68c;">)</span> 0 <span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">sum_square</span><span style="color: #DFDFDF;"> n</span> <span style="color: #f0e68c;">=</span>
   <span style="color: #f0e68c;">(</span>1 <span style="color: #f0e68c;">--</span> n<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">|&gt;</span> map <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">e</span> <span style="color: #f0e68c;">-&gt;</span> e<span style="color: #f0e68c;">*</span>e<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">|&gt;</span> sum
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
不过下面这两个版本上在实现上都有缺陷: 每次递归调用fold/map时都要重新求值参数 <code>(1 -- n)</code>
可以用 <code>let</code> 修正这一点:
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">sum_square</span><span style="color: #DFDFDF;"> n</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">lst</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span>1 <span style="color: #f0e68c;">--</span> n<span style="color: #f0e68c;">)</span> <span style="color: #f5deb3; font-weight: bold;">in</span>
  lst <span style="color: #f0e68c;">|&gt;</span> <span style="color: #f0e68c;">(</span>fold_left <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">acc e</span> <span style="color: #f0e68c;">-&gt;</span> acc<span style="color: #f0e68c;">+</span>e<span style="color: #f0e68c;">*</span>e<span style="color: #f0e68c;">)</span> 0<span style="color: #f0e68c;">)</span> 
 <span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">sum_square</span><span style="color: #DFDFDF;"> n</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">l</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span>1 <span style="color: #f0e68c;">--</span> n<span style="color: #f0e68c;">)</span> <span style="color: #f5deb3; font-weight: bold;">in</span> 
   l <span style="color: #f0e68c;">|&gt;</span> map <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">e</span> <span style="color: #f0e68c;">-&gt;</span> e<span style="color: #f0e68c;">*</span>e<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">|&gt;</span> sum
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
总结来看,目前let有两个用法:
</p>
<ul class="org-ul">
<li>避免重复计算同一变量</li>
<li>提前计算某些表达式 (改变子表达式的计算顺序)</li>
</ul>
</div>
</div>




<div id="outline-container-org6f3bb06" class="outline-4">
<h4 id="org6f3bb06">curried和uncurried</h4>
<div class="outline-text-4" id="text-org6f3bb06">
<p>
我们知道在OCaml中的多参函数实际上只是语法糖,本质上只是层层嵌套的单参匿名函数.
这种单参函数的嵌套形成的函数被称为curried函数.
反之,下面这两个函数不是curried函数
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">f</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">x</span><span style="color: #f0e68c;">,</span><span style="color: #DFDFDF;">y</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span> x<span style="color: #f0e68c;">+</span>y

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">g</span><span style="color: #DFDFDF;"> t</span> <span style="color: #f0e68c;">=</span> fst t <span style="color: #f0e68c;">+</span> snd t 
</pre>
</div>
<p>
它们的类型是: 
</p>
<div class="org-src-container">
<pre class="src src-ocaml">int <span style="color: #f0e68c;">*</span> int <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&lt;</span><span style="color: #51afef;">fun</span><span style="color: #f0e68c;">&gt;</span>
</pre>
</div>
<p>
参数是tuple类型的. 在逻辑上这两个函数也是接收两个参数的.这种多参函数被叫做uncurried函数.
</p>

<p>
采用curried函数的好处是这种函数允许 <b>部分应用</b> .
</p>

<p>
偶尔需要在curried函数和uncurried之间相互转换:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">curried</span><span style="color: #DFDFDF;"> f x y</span> <span style="color: #f0e68c;">=</span> f <span style="color: #f0e68c;">(</span>x<span style="color: #f0e68c;">,</span>y<span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">uncurried</span><span style="color: #DFDFDF;"> f </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">x</span><span style="color: #f0e68c;">,</span><span style="color: #DFDFDF;">y</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span> f x y <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>
</div>
</div>



<div id="outline-container-org83775f5" class="outline-2">
<h2 id="org83775f5">模块</h2>
<div class="outline-text-2" id="text-org83775f5">
<p>
引入模块的动机就是希望能将代码分成一个个能被单独理解和编写的部分。
这样就能做到"局部推理": 只需要思考一个模块的编写和它如何与剩下部分的程序进行通信的契约.
提供模块的抽象需要有语言的支持：
</p>

<ul class="org-ul">
<li>命名空间 ：structure</li>
<li>接口：signature 为使用者提供关于模块的功能,并隐藏实现细节(可看作是structure的类型)</li>
<li>封装：abstract type ( 以及signatures )</li>
<li>代码重用：include:更智能的复制粘贴, 可以只引入一部分代码 / functor: 从旧模块中产生新模块.</li>
</ul>


<p>
module ModuleName = module<sub>expression</sub>
这是准确的定义module语法, 右侧的表达式不一定是struct开头的, 也可以是一个已经定义过的模块:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">Alias</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>


<div id="outline-container-org6aaab16" class="outline-3">
<h3 id="org6aaab16"><code>struct</code> 关键字</h3>
<div class="outline-text-3" id="text-org6aaab16">
</div>
<div id="outline-container-org1415236" class="outline-4">
<h4 id="org1415236">用struct创建模块</h4>
<div class="outline-text-4" id="text-org1415236">
<p>
用module关键字将名字绑定到一个module值上.可以将module看作是特殊的 <code>let</code>
struct的名字必须是以大写字母开头的 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">Myspace</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">inc</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> x<span style="color: #f0e68c;">+</span>1
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">color</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Red</span><span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Green</span><span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Blue</span>
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">Oops</span>

  <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">NestedSpace</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
    <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">DivideByZero</span> 
    <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">frac</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">::</span> <span style="color: #f0e68c;">)</span> <span style="color: #51afef;">of</span> int <span style="color: #f0e68c;">*</span> int

    <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">+</span> <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>a<span style="color: #f0e68c;">::</span>b<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>x<span style="color: #f0e68c;">::</span>y<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span>
      <span style="color: #51afef;">if</span> b<span style="color: #f0e68c;">=</span>0 <span style="color: #f0e68c;">||</span> y<span style="color: #f0e68c;">==</span>0 <span style="color: #51afef;">then</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">DivideByZero</span>
      <span style="color: #51afef;">else</span> <span style="color: #f0e68c;">(</span>a<span style="color: #f0e68c;">*</span>y <span style="color: #f0e68c;">+</span> x<span style="color: #f0e68c;">*</span>b<span style="color: #f0e68c;">)::(</span>b<span style="color: #f0e68c;">*</span>y<span style="color: #f0e68c;">)</span>
    <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">*</span> <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>a<span style="color: #f0e68c;">::</span>b<span style="color: #f0e68c;">)</span>  <span style="color: #f0e68c;">(</span>x<span style="color: #f0e68c;">::</span>y<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span>
      <span style="color: #51afef;">if</span> b<span style="color: #f0e68c;">=</span>0 <span style="color: #f0e68c;">||</span> y<span style="color: #f0e68c;">==</span>0 <span style="color: #51afef;">then</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">DivideByZero</span>
      <span style="color: #51afef;">else</span> <span style="color: #f0e68c;">(</span>a<span style="color: #f0e68c;">*</span>x<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">::</span> <span style="color: #f0e68c;">(</span>b<span style="color: #f0e68c;">*</span>y<span style="color: #f0e68c;">)</span>
    <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>a<span style="color: #f0e68c;">::</span>b<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>x<span style="color: #f0e68c;">::</span>y<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span>  <span style="color: #f0e68c;">(</span>a<span style="color: #f0e68c;">::</span>b<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">+</span> <span style="color: #f0e68c;">((</span>0<span style="color: #f0e68c;">-</span>x<span style="color: #f0e68c;">)::</span>y<span style="color: #f0e68c;">)</span> 
    <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">/</span> <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>a<span style="color: #f0e68c;">::</span>b<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>x<span style="color: #f0e68c;">::</span>y<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span>a<span style="color: #f0e68c;">::</span>b<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">*</span> <span style="color: #f0e68c;">(</span>y<span style="color: #f0e68c;">::</span>x<span style="color: #f0e68c;">)</span> 

  <span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="orgf79957f"></a>在struct中使用双分号 <code>;;</code><br />
<div class="outline-text-5" id="text-orgf79957f">
<p>
下面这段是无法通过编译的 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">M</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">=</span> 0
  <span style="color: #51afef;">assert</span> <span style="color: #f0e68c;">(</span>x <span style="color: #f0e68c;">!=</span> 0<span style="color: #f0e68c;">)</span>
<span style="color: #f5deb3; font-weight: bold;">end</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
而在中间加上一个 <code>;;</code> 就能通过编译 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"> <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">M</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">=</span> 0 <span style="color: #ff4500;">;;</span>
  <span style="color: #51afef;">assert</span> <span style="color: #f0e68c;">(</span>x <span style="color: #f0e68c;">!=</span> 0<span style="color: #f0e68c;">)</span>
<span style="color: #f5deb3; font-weight: bold;">end</span> <span style="color: #ff4500;">;;</span> 
</pre>
</div>

<p>
或者也有不加分号的解决方案
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">M</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">=</span> 0 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">_</span> <span style="color: #f0e68c;">=</span>  <span style="color: #51afef;">assert</span> <span style="color: #f0e68c;">(</span>x <span style="color: #f0e68c;">!=</span> 0<span style="color: #f0e68c;">)</span>
<span style="color: #f5deb3; font-weight: bold;">end</span> <span style="color: #ff4500;">;;</span> 
</pre>
</div>
</div>
</li>
</ul>
</div>



<div id="outline-container-org84d1aef" class="outline-4">
<h4 id="org84d1aef">struct module的语义</h4>
<div class="outline-text-4" id="text-org84d1aef">
<p>
模块不能作为参数/返回值，也不能用let绑定到某个名字上。
</p>

<ul class="org-ul">
<li>求值</li>
</ul>
<p>
从上到下依次对每个定义进行求值，最后返回一个module类型的值，它绑定了名字和值
而后又将module值绑定到 <code>module MyName</code> 中的名字上。
因此被依赖的定义要写在前面. 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">M</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">y</span> <span style="color: #f0e68c;">=</span> 1
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">=</span> y
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
模块中也允许相互递归的定义:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">M</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">even</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span> <span style="color: #f0e68c;">|</span>0 <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">true</span> <span style="color: #f0e68c;">|</span>n<span style="color: #f0e68c;">-&gt;</span> odd<span style="color: #f0e68c;">(</span>n<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">)</span>
  <span style="color: #f5deb3; font-weight: bold;">and</span> <span style="color: #5cEfFF;">odd</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span> <span style="color: #f0e68c;">|</span>1 <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">true</span> <span style="color: #f0e68c;">|</span>n <span style="color: #f0e68c;">-&gt;</span> even<span style="color: #f0e68c;">(</span>n<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">)</span>

<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-org21abf36" class="outline-4">
<h4 id="org21abf36">使用struct模块中的定义</h4>
<div class="outline-text-4" id="text-org21abf36">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #FCCE7B;">Myspace.</span>myfunc <span style="color: #f0e68c;">....</span>
</pre>
</div>

<p>
在使用中有个麻烦的问题是，若出现的多个定义同属于同一模块时，没有必要每次都加上命名空间前缀。
有3个方法能避免重复书写struct模块名：
</p>

<ul class="org-ul">
<li>1. <code>open</code> 关键字</li>
</ul>

<p>
<b>函数定义open</b> 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">retval</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">open </span><span style="color: #FCCE7B;">MyStack</span> <span style="color: #f5deb3; font-weight: bold;">in</span>
  <span style="color: #bbc2cf; background-color: #242730;">Empty</span> <span style="color: #f0e68c;">|&gt;</span> push 3 <span style="color: #f0e68c;">|&gt;</span> top
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
<b>在structure内open</b>
使得在此模块内可以不加前缀地引用该模块中的定义 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">MyStruct</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">open </span><span style="color: #FCCE7B;">List</span>
  <span style="color: #f5deb3; font-weight: bold;">open </span><span style="color: #FCCE7B;">String</span> <span style="color: #62686E;">(* </span><span style="color: #62686E;">&#20063;&#23450;&#20041;&#20102;map</span><span style="color: #62686E;"> *)</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">to_upper</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>map uppercase_ascii 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
这里因为两个模块中都有map函数的定义. 因此后open的String.map会遮挡List.map的定义
因此这里最好的做法是不要用任何open
</p>


<p>
<b>全局open</b> 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">open </span><span style="color: #FCCE7B;">MyStack</span> <span style="color: #62686E;">(* </span><span style="color: #62686E;">&#21040;&#25991;&#20214;&#26411;&#23614;</span><span style="color: #62686E;"> *)</span>
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Empty</span> <span style="color: #f0e68c;">|&gt;</span> push 3 <span style="color: #f0e68c;">|&gt;</span> push 4 <span style="color: #f0e68c;">|&gt;</span> top 
</pre>
</div>
<p>
全局open相当于对模块中的每个定义都用let重新绑定了一个简短的新名字
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">open </span><span style="color: #FCCE7B;">String</span>
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">length</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">String.</span>length
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">get</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">String.</span>get
        <span style="color: #f0e68c;">...</span>    <span style="color: #f0e68c;">...</span>
</pre>
</div>
<p>
在OCaml中有个默认被open的模块是 <code>Stdlib.</code>
</p>

<ul class="org-ul">
<li>2. 在表达式之前加上 <code>MyName.</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">t</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">MyTree.</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span><span style="color: #f0e68c;">(</span>2<span style="color: #f0e68c;">,</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span><span style="color: #f0e68c;">,</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span><span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
编译器能自行推断出Node/Leaf所属的命名空间 
</p>

<ul class="org-ul">
<li>3. 为变量添加类型注释</li>
</ul>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">t</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">int </span><span style="color: #FCCE7B;">MyTree.</span><span style="color: #FCCE7B;">tree </span><span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Node</span><span style="color: #f0e68c;">(</span>2<span style="color: #f0e68c;">,</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span><span style="color: #f0e68c;">,</span><span style="color: #bbc2cf; background-color: #242730;">Leaf</span><span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-org5f574e7" class="outline-4">
<h4 id="org5f574e7">例子 ListStack</h4>
<div class="outline-text-4" id="text-org5f574e7">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListStackImpl</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>

  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a stack</span> <span style="color: #f0e68c;">=</span>
    <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Empty</span> 
    <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Entry</span> <span style="color: #51afef;">of</span> 'a <span style="color: #f0e68c;">*</span> 'a stack

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Empty</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">push</span><span style="color: #DFDFDF;"> e stk</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Entry</span><span style="color: #f0e68c;">(</span>e<span style="color: #f0e68c;">,</span>stk<span style="color: #f0e68c;">)</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Empty</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Empty</span>
    <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Entry</span><span style="color: #f0e68c;">(</span>_<span style="color: #f0e68c;">,</span>rest<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span>  rest

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Empty</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">None</span>
    <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Entry</span><span style="color: #f0e68c;">(</span>top<span style="color: #f0e68c;">,</span> _ <span style="color: #f0e68c;">)-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> top

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">peek_exn</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Empty</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">failwith</span> <span style="color: #7bc275;">"Empty Stack"</span>
    <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Entry</span><span style="color: #f0e68c;">(</span>top<span style="color: #f0e68c;">,</span>_<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> top

<span style="color: #f5deb3; font-weight: bold;">end</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
两种使用module的方式 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f0e68c;">#</span> <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">open </span><span style="color: #FCCE7B;">MyStack</span> <span style="color: #f5deb3; font-weight: bold;">in</span> 
      empty <span style="color: #f0e68c;">|&gt;</span> push 2 <span style="color: #f0e68c;">|&gt;</span> push 3 <span style="color: #f0e68c;">|&gt;</span> push 4 <span style="color: #f0e68c;">|&gt;</span> peek <span style="color: #ff4500;">;;</span>

  <span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int option <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> 4
</pre>
</div>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f0e68c;">#</span> <span style="color: #FCCE7B;">MyStack.</span> <span style="color: #f0e68c;">(</span>empty <span style="color: #f0e68c;">|&gt;</span> push 2 <span style="color: #f0e68c;">|&gt;</span> push 3 <span style="color: #f0e68c;">|&gt;</span> push 4 <span style="color: #f0e68c;">|&gt;</span> peek<span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span>

<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int option <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> 4
</pre>
</div>

<p>
这里实现是一个函数式数据结构，这意味着任何对数据结构的操作都无法修改它的数据，而是创建一个新的数据结构对象。
我们称这种数据结构是持久的。
</p>
</div>
</div>


<div id="outline-container-org0cf3df1" class="outline-4">
<h4 id="org0cf3df1">例子 ListQueue <a id="org4c3241e"></a></h4>
<div class="outline-text-4" id="text-org0cf3df1">
<p>
用list实现queue
</p>
<div class="org-src-container">
<pre class="src src-ocaml"> <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListQueue</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>

   <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a queue</span> <span style="color: #f0e68c;">=</span> 'a list

   <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">enqueue</span><span style="color: #DFDFDF;"> v  que</span> <span style="color: #f0e68c;">=</span>
     que <span style="color: #f0e68c;">@</span> <span style="color: #f0e68c;">[</span>v<span style="color: #f0e68c;">]</span>  <span style="color: #62686E;">(*</span><span style="color: #62686E;">&#32447;&#24615;&#26102;&#38388;</span><span style="color: #62686E;">*)</span>

   <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">dequeue</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
     <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">None</span>
     <span style="color: #f0e68c;">|</span>_<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> t 

   <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">dequeue_exn</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
     <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">failwith</span> <span style="color: #7bc275;">"empty queue"</span>
     <span style="color: #f0e68c;">|</span>_<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> t

   <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">first</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
     <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">None</span>
     <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>_ <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> h

   <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">first_exn</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
     <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">failwith</span> <span style="color: #7bc275;">"empty queue"</span>
     <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>_ <span style="color: #f0e68c;">-&gt;</span> h

 <span style="color: #f5deb3; font-weight: bold;">end</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
这个实现的一个问题就是其入队操作要花费线性时间。
有一个解决方法是用两个list，分别表示queue的前面和后面。
eg: front= [2;4], back=[7;6;5] (逆序) ==&gt; queue = [2;4; 5;6;7]
这样实现的队列在均摊时间上是常数级的。
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">TwoListQueue</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>

  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a queue</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">{</span>
    front<span style="color: #f0e68c;">:</span> 'a list <span style="color: #f0e68c;">;</span>
    back<span style="color: #f0e68c;">:</span> 'a list 
  <span style="color: #f0e68c;">}</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">{</span>
    front<span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[];</span>
    back <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f0e68c;">}</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|{</span>front<span style="color: #f0e68c;">=[]</span> <span style="color: #f0e68c;">}</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">None</span>
    <span style="color: #f0e68c;">|{</span>front<span style="color: #f0e68c;">=</span>x<span style="color: #f0e68c;">::</span>_ <span style="color: #f0e68c;">;}</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> x
  <span style="color: #ff4500;">;;</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">enqueue</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|{</span>front<span style="color: #f0e68c;">=[]</span> <span style="color: #f0e68c;">}</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">{</span>front<span style="color: #f0e68c;">=[</span>x<span style="color: #f0e68c;">]</span> <span style="color: #f0e68c;">;</span> back<span style="color: #f0e68c;">=[]</span> <span style="color: #f0e68c;">}</span>
    <span style="color: #f0e68c;">|</span>q <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">{</span>q <span style="color: #51afef;">with</span> back<span style="color: #f0e68c;">=</span>x<span style="color: #f0e68c;">::</span>q.back<span style="color: #f0e68c;">}</span>  <span style="color: #62686E;">(* </span><span style="color: #62686E;">&#21363;&#65306;&#24403;front&#19981;&#20026;&#31354;list&#26102;</span><span style="color: #62686E;">*)</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">dequeue</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|{</span>front<span style="color: #f0e68c;">=[]}</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">None</span>
    <span style="color: #f0e68c;">|{</span>front<span style="color: #f0e68c;">=</span> _<span style="color: #f0e68c;">::[]</span> <span style="color: #f0e68c;">;</span>back<span style="color: #f0e68c;">=</span>b<span style="color: #f0e68c;">}</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> <span style="color: #f0e68c;">{</span>front <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>rev b <span style="color: #f0e68c;">;</span>back<span style="color: #f0e68c;">=[]</span> <span style="color: #f0e68c;">}</span> 
    <span style="color: #f0e68c;">|{</span>front<span style="color: #f0e68c;">=</span>_<span style="color: #f0e68c;">::</span>t<span style="color: #f0e68c;">;</span>back<span style="color: #f0e68c;">=</span>b<span style="color: #f0e68c;">}</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> <span style="color: #f0e68c;">{</span>front <span style="color: #f0e68c;">=</span> t <span style="color: #f0e68c;">;</span>back<span style="color: #f0e68c;">=</span>b<span style="color: #f0e68c;">}</span>

<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<p>
在peek的实现中，面临着一个选择就是当front为空时应该如何匹配，我们可以分别列出back为[]或非空的list。
或者我们来假设front为空时，back也必然为空，这个假设基于我们的入队操作优先作用到哪个list上。
只要我们在实现中优先让入队作用到front上，这样就能确保front为空时，必然能推出back也为空。
并且在出队操作时保证front为空时，将back中的元素自动补充到front中。
</p>

<p>
基于这个假设，queue的模式大致有两类：
{front=[]}，以及其它情况。
</p>


<p>
dequeue的实现中，看似只需要第一个模式和第三个模式即可，即当front为空以及front不为空时。
但是第三个模式的操作结果可能会破坏之前的假设（不变量）：front为空必然推出back为空
</p>

<p>
因此需要在出队时额外区分一种情况：front中只有一个元素。此时需要在出队后，将back中的元素补充到front,这样才能维持不变量。
</p>






<blockquote>
<p>
<b>异常和Options的选择</b> 
</p>

<p>
采用异常的好处是不用额外处理函数的返回值，相对地，用Options的坏处是可能需要额外剥离 <code>Some x</code>
换句话讲，采用异常的函数更容易和管道符 <code>|&gt;</code> 一起使用。而采用option的函数则不能出现在管道符的之间。
</p>


<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #62686E;">(* </span><span style="color: #62686E;">&#36825;&#26679;&#26080;&#27861;&#36890;&#36807;&#32534;&#35793;&#65306; *&#65289;</span>
<span style="color: #62686E;">empty |&gt; enqueue 2 |&gt; enqueue 4 |&gt; dequeue |&gt; peek </span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #62686E;">(* </span><span style="color: #62686E;">&#25442;&#29992;&#25243;&#20986;&#24322;&#24120;&#30340;&#29256;&#26412;&#23601;&#21487;&#20197;&#20102;</span><span style="color: #62686E;"> *)</span>
empty <span style="color: #f0e68c;">|&gt;</span> enqueue 2 <span style="color: #f0e68c;">|&gt;</span> enqueue 4 <span style="color: #f0e68c;">|&gt;</span> dequeue_exn <span style="color: #f0e68c;">|&gt;</span> peek
</pre>
</div>

<p>
为此可以重写2个能自动剥离输入参数为 <code>Some</code> 的新管道符，
</p>

<p>
一个专门用于连接那些返回option的函数： <code>&gt;&gt;|</code>
</p>

<p>
另一个用于那些返回普通值的函数（使用用异常的） <code>&gt;&gt;=</code>
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">&gt;&gt;|</span> <span style="color: #f0e68c;">)</span> opt func <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">match</span> opt  <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">None</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">None</span> 
  <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Some</span> v <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>func v<span style="color: #f0e68c;">)</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">&gt;&gt;=</span> <span style="color: #f0e68c;">)</span> opt f_exn <span style="color: #f0e68c;">=</span>
   <span style="color: #51afef;">match</span> opt  <span style="color: #51afef;">with</span>
   <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">None</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">None</span> 
   <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Some</span> v <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> <span style="color: #f0e68c;">(</span>f_exn v<span style="color: #f0e68c;">)</span>
 <span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">open </span><span style="color: #FCCE7B;">TwoListQueue</span> <span style="color: #f5deb3; font-weight: bold;">in</span> 
empty <span style="color: #f0e68c;">|&gt;</span> enqueue 2 <span style="color: #f0e68c;">|&gt;</span> enqueue 4 <span style="color: #f0e68c;">|&gt;</span> dequeue <span style="color: #f0e68c;">&gt;&gt;=</span> enqueue 3 <span style="color: #f0e68c;">&gt;&gt;|</span>  dequeue <span style="color: #f0e68c;">&gt;&gt;=</span>  peek
<span style="color: #ff4500;">;;</span>  
</pre>
</div>
</blockquote>
</div>
</div>
</div>






<div id="outline-container-org7d33643" class="outline-3">
<h3 id="org7d33643"><code>sig</code> 关键字</h3>
<div class="outline-text-3" id="text-org7d33643">
</div>
<div id="outline-container-org603ea78" class="outline-4">
<h4 id="org603ea78">signature是module的类型</h4>
<div class="outline-text-4" id="text-org603ea78">
<p>
在utop中定义一个模块:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"> <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">MyModule</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">inc</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> x<span style="color: #f0e68c;">+</span>1
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">primary_color</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Red</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Green</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Blue</span> 
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">Oops</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>
 <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
返回结果是: 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">MyModule</span> <span style="color: #f0e68c;">:</span>

  <span style="color: #f5deb3; font-weight: bold;">sig</span>
    <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">inc</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> int
    <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">primary_color</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Red</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Green</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Blue</span>
    <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">Oops</span>
  <span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f0e68c;">#</span> <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">foo</span> <span style="color: #f0e68c;">=</span> 100 <span style="color: #ff4500;">;;</span>
<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">foo</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">=</span> 100

<span style="color: #f0e68c;">#</span> <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">inc</span><span style="color: #DFDFDF;"> y</span> <span style="color: #f0e68c;">=</span> y<span style="color: #f0e68c;">+</span>1 <span style="color: #ff4500;">;;</span>
<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">inc</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&lt;</span><span style="color: #51afef;">fun</span><span style="color: #f0e68c;">&gt;</span>
</pre>
</div>

<p>
参考上面的格式, 能启发我们得知 名字"MyModule" 对应的不是一个变量/函数, 而是一个module.
并且这个module的类型是一个 <b>无名的signature</b> : 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">inc</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> int
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">primary_color</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Red</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Green</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Blue</span>
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">Oops</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
因此一个signature就是一个module的类型. 
</p>
</div>
</div>

<div id="outline-container-org967505f" class="outline-4">
<h4 id="org967505f">定义接口</h4>
<div class="outline-text-4" id="text-org967505f">
<p>
（ 定义一个新的 module type ）
</p>

<p>
变量和函数要以 <code>val</code> 开头, 在名字后面用冒号指明类型.
还能定义 <code>exception</code> , <code>type</code> , 和嵌套的 <code>module type</code> 
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">Fact</span> <span style="color: #f0e68c;">=</span>
<span style="color: #f5deb3; font-weight: bold;">sig</span> 
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">fact</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> int 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">LIST_STACK</span> <span style="color: #f0e68c;">=</span>
<span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyStack</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">empty</span> <span style="color: #f0e68c;">:</span> 'a list
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">is_empty</span> <span style="color: #f0e68c;">:</span> 'a list <span style="color: #f0e68c;">-&gt;</span> bool
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">push</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a list <span style="color: #f0e68c;">-&gt;</span> 'a list
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">:</span> 'a list <span style="color: #f0e68c;">-&gt;</span> 'a list
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">:</span> 'a list <span style="color: #f0e68c;">-&gt;</span> 'a 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge0b2ad9" class="outline-4">
<h4 id="orge0b2ad9">实现接口</h4>
<div class="outline-text-4" id="text-orge0b2ad9">
<p>
（创建一个类型为 module type Fact类型的“对象” ）
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> &#27169;&#22359;&#21517; <span style="color: #f0e68c;">:</span> &#27169;&#22359;&#31867;&#22411;<span style="color: #f5deb3; font-weight: bold;">sig</span> <span style="color: #f0e68c;">=</span>  <span style="color: #f5deb3; font-weight: bold;">struct</span> <span style="color: #f0e68c;">....</span>  <span style="color: #f5deb3; font-weight: bold;">end</span>  <span style="color: #ff4500;">;;</span> 
</pre>
</div>




<div class="org-src-container">
<pre class="src src-ocaml">  <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">RescursiveFact</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Fact</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
    <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">fact</span><span style="color: #DFDFDF;"> n</span> <span style="color: #f0e68c;">=</span>
      <span style="color: #51afef;">if</span> n<span style="color: #f0e68c;">=</span>0 <span style="color: #51afef;">then</span> 1 <span style="color: #51afef;">else</span> n <span style="color: #f0e68c;">*</span> fact <span style="color: #f0e68c;">(</span>n<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">)</span>
  <span style="color: #f5deb3; font-weight: bold;">end</span>
<span style="color: #62686E;">(*****************************************)</span> 
  <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">TailRescursiveFact</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Fact</span> <span style="color: #f0e68c;">=</span><span style="color: #f5deb3; font-weight: bold;">struct</span>
    <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">fact_iteration</span><span style="color: #DFDFDF;"> acc</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
      <span style="color: #f0e68c;">|</span>0 <span style="color: #f0e68c;">-&gt;</span> acc
      <span style="color: #f0e68c;">|</span>n <span style="color: #f0e68c;">-&gt;</span> fact_iteration <span style="color: #f0e68c;">(</span>acc<span style="color: #f0e68c;">*</span>n<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>n<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">)</span>
    <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">fact</span><span style="color: #DFDFDF;"> n</span> <span style="color: #f0e68c;">=</span> fact_iteration 1 n
  <span style="color: #f5deb3; font-weight: bold;">end</span>
  <span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListStack</span> <span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;">LIST_STACK</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span> 
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyStack</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[]</span> 

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">is_empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span> 
    <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">true</span> 
    <span style="color: #f0e68c;">|</span>_ <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span> 

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">push</span><span style="color: #DFDFDF;"> e stk</span><span style="color: #f0e68c;">=</span> e<span style="color: #f0e68c;">::</span>stk

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span> 
    <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyStack</span> 
    <span style="color: #f0e68c;">|</span>_<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> t 

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span> 
    <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyStack</span>
    <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>_ <span style="color: #f0e68c;">-&gt;</span> h 
<span style="color: #f5deb3; font-weight: bold;">end</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>


<p>
在实现中必须出现接口中定义过的东西，这时在实现中定义其它东西是不会报错的。
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">Addone</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">addone</span><span style="color: #f0e68c;">:</span> int list <span style="color: #f0e68c;">-&gt;</span> int list
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">MyAddone</span><span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Addone</span>  <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">incr</span><span style="color: #DFDFDF;"> x</span>  <span style="color: #f0e68c;">=</span> x<span style="color: #f0e68c;">+</span>1
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">addone</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[]</span>
    <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>1<span style="color: #f0e68c;">+</span> h <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">::</span> <span style="color: #f0e68c;">(</span>addone t<span style="color: #f0e68c;">)</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>

<p>
使用这种实现某个接口sig的struct时，只能使用sig声明过的东西，struct中的其它定义对外是不可访问的。
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #62686E;">(* </span><span style="color: #62686E;">&#36825;&#26159;&#19981;&#20801;&#35768;&#30340;&#65306;</span>
<span style="color: #62686E;"> MyAddone.incr 4;;</span><span style="color: #62686E;"> *)</span>

<span style="color: #FCCE7B;">MyAddone.</span>addone <span style="color: #f0e68c;">[</span>1<span style="color: #f0e68c;">;</span>3<span style="color: #f0e68c;">;</span>5<span style="color: #f0e68c;">]</span> <span style="color: #ff4500;">;;</span><span style="color: #62686E;">(*</span><span style="color: #62686E;">&#21512;&#27861;&#25805;&#20316;</span><span style="color: #62686E;">*)</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-org05debd4" class="outline-4">
<h4 id="org05debd4">在signature中声明module类型的量</h4>
<div class="outline-text-4" id="text-org05debd4">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">X</span>  <span style="color: #f0e68c;">=</span>
<span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">x</span> <span style="color: #f0e68c;">:</span> int 
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">T</span> <span style="color: #f0e68c;">=</span>
<span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">Inner</span><span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">X</span> 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">T_impl</span>  <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>

  <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">Inner</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">X</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
    <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">=</span> 100 
  <span style="color: #f5deb3; font-weight: bold;">end</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org81d8ea4" class="outline-4">
<h4 id="org81d8ea4">signature 的语义</h4>
<div class="outline-text-4" id="text-org81d8ea4">
<p>
这里的语义主要指的是和类型检查相关的.
</p>
<ol class="org-ol">
<li>签名匹配: 确保在sig中声明的都在相应的模块中有正确的定义
<ul class="org-ul">
<li>任何在sig中出现的名字都必须在module struct中被定义</li>
<li>module中定义的类型必须和对应在sig中的类型一致或更"广泛"</li>
</ul></li>
</ol>


<ol class="org-ol">
<li>封装: 只允许在sig中指定的那些东西能在模块外使用</li>
</ol>

<div class="org-src-container">
<pre class="src src-ocaml">  <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">IntFunc</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span> 
    <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">foo</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> int 
  <span style="color: #f5deb3; font-weight: bold;">end</span>
  <span style="color: #ff4500;">;;</span>
<span style="color: #62686E;">(* </span><span style="color: #62686E;">&#19979;&#38754;&#23454;&#29616;&#20013;&#30340;foo&#20854;&#23454;&#26159; 'a -&gt; 'a &#31867;&#22411;&#30340;, &#20294;&#21482;&#35201;&#33021;&#31526;&#21512;&#25509;&#21475;&#20013;&#30340;&#35268;&#23450;&#21363;&#21487;</span><span style="color: #62686E;"> *)</span>
  <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">IntFuncImpl</span><span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">IntFunc</span> <span style="color: #f0e68c;">=</span>  <span style="color: #f5deb3; font-weight: bold;">struct</span> 
    <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">foo</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> x 
  <span style="color: #f5deb3; font-weight: bold;">end</span>
  <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
ocaml中的类型不是像java/c++ 中的那样, 是按照声明的名称来进行区分的.也就是说同样包含两个 int a = 0 作为字段的不同名称的类代表着两个不同的类型.
而在OCaml中, 类型是根据结构进行判断的.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">M</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">=</span> 0
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">z</span> <span style="color: #f0e68c;">=</span>1
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
module M : sig val x : int val z : int end
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">X</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">x</span> <span style="color: #f0e68c;">:</span> int
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
这里将M这个具体的模块当作是类型X是可以的.
因为类型上是相容的: 模块M中定义了名称x且类型也是int, 这符合类型X的定义 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">Mx</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">X</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">M</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
类似地有
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">Z</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">z</span> <span style="color: #f0e68c;">:</span> int
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">Mz</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Z</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">M</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
当然M也符合一个同时含有z和x的sig类型
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">XZ</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">x</span> <span style="color: #f0e68c;">:</span> int
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">z</span> <span style="color: #f0e68c;">:</span> int
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">Mxz</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">XZ</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">M</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
最后有一个值得注意的点:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">Mxz'</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">((</span><span style="color: #bbc2cf; background-color: #242730;">M</span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;">X</span><span style="color: #f0e68c;">):</span><span style="color: #FCCE7B;">Z</span><span style="color: #f0e68c;">)</span> <span style="color: #ff4500;">;;</span> 
</pre>
</div>
<p>
这个定义是无法通过编译的,会提示没有提供z的定义
不能简单地看M中的定义. 因为 (M:X) 相当于将M的类型转换为X ,而X 中是没有关于z的定义的, 因此它不能再用 (? : Z)来转换为类型Z的模块.
</p>

<p>
综上所述, 有两条关于模块的类型注释的静态语义:
</p>
<ol class="org-ol">
<li>模块类型注释(M:T)是合法的, 若M的类型是T的子类型(结构是相容的). 并且得到的模块(M:T) 的类型是T</li>
<li><p>
module类型S是T的子类型, 若S中的定义之集是T中定义之集的超集(包含), 并且T中的定义类型可以是S中对应定义类型的特化版本.
</p>

<p>
ocaml中的类型注释是静态的, 和java/python不同, 他们二者是在运行时进行的.
</p></li>
</ol>
<pre class="example">
第一类module: OCaml中的module本身不是firstclass的, 但可以通过"打包"将其变为第一类的值,从而能作为函数的参数/返回值
</pre>
</div>
</div>
</div>


<div id="outline-container-orgf55f850" class="outline-3">
<h3 id="orgf55f850">在utop中使用module</h3>
<div class="outline-text-3" id="text-orgf55f850">
</div>
<div id="outline-container-org1a20245" class="outline-4">
<h4 id="org1a20245">直接加载文件 (不当作模块使用)</h4>
<div class="outline-text-4" id="text-org1a20245">
<p>
命令 <code>#use XX.ml</code> 的效果等同于将文件中的代码一行行地输入到utop中.
</p>

<p>
实现自定义的 <code>sig</code> 的module:
其具体实现是不回显的
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">NumType</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">t</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">n</span> <span style="color: #f0e68c;">:</span> t
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">NumInt</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">NumType</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">t</span> <span style="color: #f0e68c;">=</span> int
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">n</span> <span style="color: #f0e68c;">=</span> 100
<span style="color: #f5deb3; font-weight: bold;">end</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
实际实现的类型和值都不会显示: 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f0e68c;">#</span> <span style="color: #FCCE7B;">NumInt.</span>n <span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">NumInt.</span>t <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&lt;</span>abstr<span style="color: #f0e68c;">&gt;</span>
</pre>
</div>
<p>
而对一个未指定sig的普通模块
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">N</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span> 
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">t</span> <span style="color: #f0e68c;">=</span> int
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">n</span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;">t</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span> 100 
<span style="color: #f5deb3; font-weight: bold;">end</span> 
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
其内部定义的值是可以被直接显示的 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f0e68c;">#</span> <span style="color: #FCCE7B;">N.</span>n <span style="color: #ff4500;">;;</span>
  <span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">N.</span>t <span style="color: #f0e68c;">=</span> 100
</pre>
</div>
</div>
</div>

<div id="outline-container-org87eaab1" class="outline-4">
<h4 id="org87eaab1">作为模块加载文件</h4>
<div class="outline-text-4" id="text-org87eaab1">
<ol class="org-ol">
<li>将模块进行编译</li>
</ol>

<p>
<code>ocamlbuild XX.cmi XX.cmo</code> 
将分别对 XX.mli 和 XX.ml 进行编译
</p>

<p>
<code>ocamlc xx.ml</code> -&gt; <code>xx.cmo</code>
</p>


<ol class="org-ol">
<li>指定编译后的模块所在目录
<code>#directory "_build"</code></li>

<li>加载编译后的模块
<code>#load "xx.cmo"</code></li>
</ol>
</div>
</div>



<div id="outline-container-org14b75aa" class="outline-4">
<h4 id="org14b75aa">加载已经安装的第三方模块</h4>
<div class="outline-text-4" id="text-org14b75aa">
<p>
<code>#require "ounit2"</code>
然后再进行 open OUnit2 
</p>
</div>
</div>

<div id="outline-container-org541fa45" class="outline-4">
<h4 id="org541fa45">借助dune在utop中加载module</h4>
<div class="outline-text-4" id="text-org541fa45">
<p>
先编写dune文件: 用xxx.ml和同目录下的其它文件创建库xxx 
</p>
<div class="org-src-container">
<pre class="src src-lisp">(library
 (name xxx))
</pre>
</div>
<p>
然后运行 <code>dune utop</code>
</p>
</div>
</div>


<div id="outline-container-org1fc834a" class="outline-4">
<h4 id="org1fc834a">在工作目录中创建 .ocamlinit</h4>
<div class="outline-text-4" id="text-org1fc834a">
<p>
在xx.ml所在目录中创建 <code>.ocamlinit</code> 文件, 并在文件中使用命令 <code>open / #require / #library/ #load / #use</code>  载入所需要的模块
并用 <code>dune utop</code> 启动
</p>
</div>
</div>
</div>

<div id="outline-container-org3fd36df" class="outline-3">
<h3 id="org3fd36df">封装 Encapsulation</h3>
<div class="outline-text-3" id="text-org3fd36df">
<p>
模块系统
</p>
</div>

<div id="outline-container-orgf14b10f" class="outline-4">
<h4 id="orgf14b10f">不透明度</h4>
<div class="outline-text-4" id="text-orgf14b10f">
<p>
在一个模块的实现中, 有时可能会定义一些不希望暴露给使用者的辅助函数:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #62686E;">(* </span><span style="color: #62686E;">&#23454;&#29616;&#38454;&#20056;fact</span><span style="color: #62686E;">*)</span> 
<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">Math</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">fact_impl</span><span style="color: #DFDFDF;"> acc n</span> <span style="color: #f0e68c;">=</span>
    <span style="color: #51afef;">if</span> n<span style="color: #f0e68c;">=</span>0 <span style="color: #51afef;">then</span> acc 
    <span style="color: #51afef;">else</span> fact_impl <span style="color: #f0e68c;">(</span>n<span style="color: #f0e68c;">*</span>acc<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>n<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">)</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">fact</span> <span style="color: #f0e68c;">=</span> fact_impl 1

<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
如何让辅助函数fact<sub>impl对使用者是隐藏的呢</sub>?
一种方式就是在函数定义中再定义辅助函数(就像之前实现尾递归函数做的那样) 但这种方式的弊端是会降低代码的可读性 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #62686E;">(* </span><span style="color: #62686E;">&#23454;&#29616;&#38454;&#20056;fact</span><span style="color: #62686E;">*)</span> 
<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">Math</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">fact</span><span style="color: #DFDFDF;"> n</span> <span style="color: #f0e68c;">=</span> 
    <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">fact_impl</span><span style="color: #DFDFDF;"> acc n</span> <span style="color: #f0e68c;">=</span>
      <span style="color: #51afef;">if</span> n<span style="color: #f0e68c;">=</span>0 <span style="color: #51afef;">then</span> acc 
      <span style="color: #51afef;">else</span> fact_impl <span style="color: #f0e68c;">(</span>n<span style="color: #f0e68c;">*</span>acc<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>n<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">)</span>
    <span style="color: #f5deb3; font-weight: bold;">in</span> fact_impl 1 n 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<p>
可以用模块的方式来实现隐藏: 定义一个Math的signature
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">Math</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">fact</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> int
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">MathImpl</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Math</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">fact_impl</span><span style="color: #DFDFDF;"> acc n</span> <span style="color: #f0e68c;">=</span>
    <span style="color: #51afef;">if</span> n<span style="color: #f0e68c;">=</span>0 <span style="color: #51afef;">then</span> acc 
    <span style="color: #51afef;">else</span> fact_impl <span style="color: #f0e68c;">(</span>n<span style="color: #f0e68c;">*</span>acc<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">(</span>n<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">)</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">fact</span> <span style="color: #f0e68c;">=</span> fact_impl 1
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
被Math模块类型约束过的struct就能实现对外隐藏信息 
</p>
</div>
</div>

<div id="outline-container-orgeb06f17" class="outline-4">
<h4 id="orgeb06f17">抽象类型 abstract type</h4>
<div class="outline-text-4" id="text-orgeb06f17">
<p>
C++中的泛型 std::vector&lt;T&gt; ?
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">ListStack</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">StackIsEmpty</span>

  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">empty</span> <span style="color: #f0e68c;">:</span> 'a list

  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">is_empty</span> <span style="color: #f0e68c;">:</span> 'a list <span style="color: #f0e68c;">-&gt;</span> bool
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">push</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a list <span style="color: #f0e68c;">-&gt;</span> 'a list
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">:</span> 'a list <span style="color: #f0e68c;">-&gt;</span> 'a
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">:</span> 'a list <span style="color: #f0e68c;">-&gt;</span> 'a list

<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListStackImpl</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">ListStack</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">StackIsEmpty</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">is_empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">true</span>
    <span style="color: #f0e68c;">|</span> _ <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">push</span><span style="color: #DFDFDF;"> e s</span> <span style="color: #f0e68c;">=</span> e<span style="color: #f0e68c;">::</span>s
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
     <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">StackIsEmpty</span>
     <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>_ <span style="color: #f0e68c;">-&gt;</span> h
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">StackIsEmpty</span>
    <span style="color: #f0e68c;">|</span> _<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> t
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
然后我们要添加一个操作 : size
</p>
<div class="org-src-container">
<pre class="src src-ocaml">  <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">ListStack</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
    <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">size</span> <span style="color: #f0e68c;">:</span> 'a list <span style="color: #f0e68c;">-&gt;</span> int
      <span style="color: #f0e68c;">....</span>
  <span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListStackImpl</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">size</span>  <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>length 
      <span style="color: #f0e68c;">....</span> 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
这个size的实现显然是线性时间的.我们希望通过保存size变量, 来使得size的实现是常数时间的.(和 std::array 类似)
为此我们要将stack的类型实现为一个 <code>pair: list + int</code>
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListStackCachedSizeImpl</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">StackIsEmpty</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">([],</span>0<span style="color: #f0e68c;">)</span> 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">is_empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">([],</span>_<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">true</span>
    <span style="color: #f0e68c;">|</span> _ <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">size</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">s</span><span style="color: #f0e68c;">,</span><span style="color: #DFDFDF;">n</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span> n 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">push</span><span style="color: #DFDFDF;"> e </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">s</span><span style="color: #f0e68c;">,</span><span style="color: #DFDFDF;">n</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span>e<span style="color: #f0e68c;">::</span>s<span style="color: #f0e68c;">,</span> <span style="color: #f0e68c;">(</span>1<span style="color: #f0e68c;">+</span>n<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">)</span> 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
     <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">([],</span>_<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">StackIsEmpty</span>
     <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">(</span>h<span style="color: #f0e68c;">::</span>_<span style="color: #f0e68c;">,</span>_ <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> h 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">([],</span>_<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">StackIsEmpty</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">(</span>_<span style="color: #f0e68c;">::</span>t<span style="color: #f0e68c;">,</span>n<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>t<span style="color: #f0e68c;">,(</span>n<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">))</span>

<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #FCCE7B;">ListStackCachedSize.</span> <span style="color: #f0e68c;">(</span>empty <span style="color: #f0e68c;">|&gt;</span> push 1 <span style="color: #f0e68c;">|&gt;</span> push 2 <span style="color: #f0e68c;">|&gt;</span> size <span style="color: #f0e68c;">)</span>  <span style="color: #ff4500;">;;</span>
<span style="color: #62686E;">(* </span><span style="color: #62686E;">--&gt; 2</span><span style="color: #62686E;"> *)</span>
</pre>
</div>
<p>
虽然这样能实现,但是它不符合signature ListStack的要求, 因为在接口中已经固定了stack的实现类型为 <code>'a list</code> , 而这里的类型是 <code>'a list * int</code>
</p>

<p>
因此我们需要修改接口中stack的类型, 不能让它在接口的规范中就固定下来. 而是将具体实现交给 <code>struct</code> .因此不能在接口中出现stack的具体实现类型, 而是用一个变量来暂时代表它 完成接口的定义. 
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">ListStack</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>

  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a stack</span>
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">StackIsEmpty</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">empty</span> <span style="color: #f0e68c;">:</span> 'a stack
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">is_empty</span> <span style="color: #f0e68c;">:</span> 'a stack <span style="color: #f0e68c;">-&gt;</span> bool
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">push</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a stack <span style="color: #f0e68c;">-&gt;</span> 'a stack
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">:</span> 'a stack <span style="color: #f0e68c;">-&gt;</span> 'a
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">:</span> 'a stack <span style="color: #f0e68c;">-&gt;</span> 'a stack
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">size</span> <span style="color: #f0e68c;">:</span> 'a stack <span style="color: #f0e68c;">-&gt;</span> int

<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml">  <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListStackCachedSizeImpl</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
      <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a stack</span> <span style="color: #f0e68c;">=</span> 'a list <span style="color: #f0e68c;">*</span> int 
      <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">StackIsEmpty</span>

      <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">([],</span>0<span style="color: #f0e68c;">)</span> 
      <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">is_empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
        <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">([],</span>_<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">true</span>
        <span style="color: #f0e68c;">|</span> _ <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span>
      <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">size</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">s</span><span style="color: #f0e68c;">,</span><span style="color: #DFDFDF;">n</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span> n 
      <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">push</span><span style="color: #DFDFDF;"> e </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">s</span><span style="color: #f0e68c;">,</span><span style="color: #DFDFDF;">n</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span>e<span style="color: #f0e68c;">::</span>s<span style="color: #f0e68c;">,</span> <span style="color: #f0e68c;">(</span>1<span style="color: #f0e68c;">+</span>n<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">)</span> 
      <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
         <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">([],</span>_<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">StackIsEmpty</span>
         <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">(</span>h<span style="color: #f0e68c;">::</span>_<span style="color: #f0e68c;">,</span>_ <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> h 
      <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
        <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">([],</span>_<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">StackIsEmpty</span>
        <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">(</span>_<span style="color: #f0e68c;">::</span>t<span style="color: #f0e68c;">,</span>n<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>t<span style="color: #f0e68c;">,(</span>n<span style="color: #f0e68c;">-</span>1<span style="color: #f0e68c;">))</span>
    <span style="color: #f5deb3; font-weight: bold;">end</span>
<span style="color: #62686E;">(*************************)</span>
  <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListStackCachedSize</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">ListStack</span> <span style="color: #f0e68c;">=</span>  <span style="color: #FCCE7B;">ListStackCachedSizeImpl</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
使用在接口中声明抽象类型意味着 在module外部无法直接使用实现类型的具体值
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">IntType</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">inttype</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">element</span> <span style="color: #f0e68c;">:</span> inttype 
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">MyInt</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">IntType</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">inttype</span> <span style="color: #f0e68c;">=</span> int
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">element</span> <span style="color: #f0e68c;">=</span> 0 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f0e68c;">#</span> <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">a</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">MyInt.</span>element <span style="color: #ff4500;">;;</span>
<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">a</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">MyInt.</span>inttype <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&lt;</span>abstr<span style="color: #f0e68c;">&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd48bd0d" class="outline-4">
<h4 id="orgd48bd0d">更好的打印</h4>
<div class="outline-text-4" id="text-orgd48bd0d">
<p>
对于抽象类型的数据的打印结果, 只会显示出一个 &lt;abstr&gt;
这的确起到了隐藏数据的目的, 但对于可以公开的信息, 目前的没有一个可以显示它们的方式.
在utop中提供了一个命令 <code>#install_printer</code> 来注册打印函数:
</p>

<ul class="org-ul">
<li>编写一个类型为 <code>Format.formatter -&gt; t -&gt; unit</code> 的函数 pp</li>

<li>调用指令: <code>install_printer pp</code></li>

<li>取消注册打印函数 <code>#remove_printer pp</code></li>
</ul>

<p>
那么 Format.fomatter 代表什么呢? 它可以理解为某种输出地点 
那么一个典型的pp函数是用 <code>Format.fprintf</code> 来定义的
</p>
<div class="org-src-container">
<pre class="src src-ocaml"> <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">IntType</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">inttype</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">element</span> <span style="color: #f0e68c;">:</span> inttype 
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">pp</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Format.</span>formatter <span style="color: #f0e68c;">-&gt;</span> inttype <span style="color: #f0e68c;">-&gt;</span> unit 
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">MyInt</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">IntType</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">inttype</span> <span style="color: #f0e68c;">=</span> int
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">element</span> <span style="color: #f0e68c;">=</span> 0 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">pp</span><span style="color: #DFDFDF;"> fmt </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">i</span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> inttype</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span>
    <span style="color: #FCCE7B;">Format.</span>fprintf fmt <span style="color: #7bc275;">"&gt;%d&lt;"</span> i 

<span style="color: #f5deb3; font-weight: bold;">end</span> <span style="color: #ff4500;">;;</span>

<span style="color: #f0e68c;">#</span>install_printer <span style="color: #FCCE7B;">MyInt.</span>pp <span style="color: #ff4500;">;;</span>  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f0e68c;">#</span> <span style="color: #FCCE7B;">MyInt.</span>element <span style="color: #ff4500;">;;</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">MyInt.</span>inttype <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&gt;</span>0<span style="color: #f0e68c;">&lt;</span>

<span style="color: #f0e68c;">#</span> <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">a</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">MyInt.</span>element <span style="color: #ff4500;">;;</span>
<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">a</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">MyInt.</span>inttype <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">&gt;</span>0<span style="color: #f0e68c;">&lt;</span>
</pre>
</div>
</div>
</div>
</div>









<div id="outline-container-orgc3ad403" class="outline-3">
<h3 id="orgc3ad403">编译单元</h3>
<div class="outline-text-3" id="text-orgc3ad403">
<p>
编译单元 = XX.ml + XX.mli 这两个文件
</p>

<p>
编译单元可以看成是隐式定义 signature 和 struct的语法糖 
</p>

<p>
设XX.ml中的内容表示为 "DM"
XX.mli中的内容为 "DS"
</p>

<p>
则编译单元实际上做的事情等价于:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">XX</span> <span style="color: #f0e68c;">[:</span> <span style="color: #f5deb3; font-weight: bold;">sig</span> <span style="color: #bbc2cf; background-color: #242730;">DS</span> <span style="color: #f5deb3; font-weight: bold;">end</span> <span style="color: #f0e68c;">]</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #bbc2cf; background-color: #242730;">DM</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
</div>


<div id="outline-container-orgf7df5eb" class="outline-4">
<h4 id="orgf7df5eb">在utop中使用编译单元</h4>
<div class="outline-text-4" id="text-orgf7df5eb">
<ol class="org-ol">
<li>在dune项目中, 进入 lib 目录</li>

<li>分别创建 xx.mli 和 xx.ml 文件</li>

<li>编辑dune文件</li>
</ol>
<pre class="example">
(library
 (name xxx )) 
</pre>

<ol class="org-ol">
<li>编译并启动utop:</li>
</ol>
<pre class="example">
dune utop 
</pre>
</div>
</div>



<div id="outline-container-org3951177" class="outline-4">
<h4 id="org3951177">不完整的编译单元</h4>
<div class="outline-text-4" id="text-org3951177">
<p>
我们知道完整的编译单元由两个文件组成, 当二者有一个缺失会如何呢?
</p>
</div>

<ul class="org-ul">
<li><a id="orgb4d8508"></a>缺失接口文件 <code>.mli</code><br /></li>


<li><a id="org8e6815c"></a>缺失实现文件 <code>.ml</code><br />
<div class="outline-text-5" id="text-org8e6815c">
<p>
缺失 .ml 可能是因为对编译单元的误用上.
比如现有接口 stack.mli , 而stack有两种以上的实现: stack1.ml stack2.ml
ocaml中没有办法指明 stack.mli分别能和 stack1.ml 或 stack2.ml 组成编译单元.
</p>

<p>
因此解决方案有两个 :
</p>
<ol class="org-ol">
<li>不使用编译单元, 也就是不用 <code>.mli</code> 文件
编写一个stack的简短名字的 signature</li>
</ol>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #62686E;">(* </span><span style="color: #62686E;">stack.ml</span><span style="color: #62686E;"> *)</span>
<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">S</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">push</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
实现 Stack模块中的接口 S 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #62686E;">(* </span><span style="color: #62686E;">stack01.ml</span><span style="color: #62686E;"> *)</span>
<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">Stack01</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Stack.S</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> <span style="color: #f0e68c;">=</span> 'a list
      <span style="color: #f0e68c;">...</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #62686E;">(* </span><span style="color: #62686E;">stack02.ml</span><span style="color: #62686E;"> *)</span>
<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">Stack02</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Stack.S</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f0e68c;">...</span> 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<ol class="org-ol">
<li>使用编译单元(接口文件 <code>.mli</code> )
这个解决方案的想法是在接口文件中声明 其它 signature和 module</li>
</ol>


<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #62686E;">(* </span><span style="color: #62686E;">stack.mli</span><span style="color: #62686E;"> *)</span>
<span style="color: #7e7e87;">(** &#36825;&#20010;&#25509;&#21475;&#20013;&#35268;&#23450;&#20102;&#23454;&#29616;&#20013;&#24517;&#39035;&#23450;&#20041;&#19977;&#20010;&#19996;&#35199;:</span>
<span style="color: #7e7e87;">&#19968;&#20010;&#26159;&#21517;&#20026;S&#30340;module type, &#21097;&#19979;&#20004;&#20010;&#26159; &#23454;&#29616;&#25509;&#21475;S&#30340; module struct *)</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">S</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> 
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">push</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a
    <span style="color: #f0e68c;">...</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">StackImpl</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">S</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">OtherStackImpl</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">S</span> 
</pre>
</div>

<p>
实现: 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #62686E;">(* </span><span style="color: #62686E;">stack.ml</span><span style="color: #62686E;"> *)</span>
<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">S</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> 
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">push</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a
    <span style="color: #f0e68c;">....</span> 
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">StackImpl</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">S</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> <span style="color: #f0e68c;">=</span> 'a list 
      <span style="color: #f0e68c;">....</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">OtherStackImpl</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">S</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> <span style="color: #f0e68c;">=</span> int <span style="color: #f0e68c;">*</span> 'a list
      <span style="color: #f0e68c;">....</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
但这个解决方案会导致代码的重复: <code>module type</code> 的重复定义
(之后会用functor解决这个问题)
</p>
</div>
</li>
</ul>
</div>
</div>



<div id="outline-container-orgc9ccc5f" class="outline-3">
<h3 id="orgc9ccc5f">函数式数据结构</h3>
<div class="outline-text-3" id="text-orgc9ccc5f">
</div>
<div id="outline-container-orge7b33ea" class="outline-4">
<h4 id="orge7b33ea">函数式数据结构的特点</h4>
<div class="outline-text-4" id="text-orge7b33ea">
<ul class="org-ul">
<li>无mutable更新操作: 即没有原地修改数据结构的操作. 只是接收旧的数据结构,返回新的数据结构. 不会改变旧的数据结构</li>

<li>所有绑定到名字上的数据结构都是持久的, 被使用后不会被销毁.</li>
</ul>
</div>
</div>


<div id="outline-container-org1dab803" class="outline-4">
<h4 id="org1dab803">lists</h4>
<div class="outline-text-4" id="text-org1dab803">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">lst</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[</span>1<span style="color: #f0e68c;">;</span>3<span style="color: #f0e68c;">;</span>4<span style="color: #f0e68c;">;</span>5<span style="color: #f0e68c;">;</span>7<span style="color: #f0e68c;">]</span>
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">lst'</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>tl lst <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
list是持久的数据结构:
</p>
<div class="org-src-container">
<pre class="src src-ocaml">lst<span style="color: #ff4500;">;;</span>
<span style="color: #62686E;">(* </span><span style="color: #62686E;">lst&#24182;&#26410;&#22240;tl&#25805;&#20316;&#32780;&#34987;&#20462;&#25913;</span><span style="color: #62686E;"> *)</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> int list <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[</span>3<span style="color: #f0e68c;">;</span> 4<span style="color: #f0e68c;">;</span> 5<span style="color: #f0e68c;">;</span> 7<span style="color: #f0e68c;">]</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-orgb008592" class="outline-4">
<h4 id="orgb008592">stacks</h4>
<div class="outline-text-4" id="text-orgb008592">
<p>
我们之前实现的stack也是持久的 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">Stack</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span>
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyStack</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">empty</span> <span style="color: #f0e68c;">:</span> 'a t 
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">is_empty</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> bool
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">size</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> int
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">push</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">peek_opt</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a option
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">pop_opt</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t option 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">StackImpl</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Stack</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> <span style="color: #f0e68c;">=</span> 'a list
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyStack</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[]</span> 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">is_empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">true</span> 
    <span style="color: #f0e68c;">|</span> _ <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">size</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>length
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">push</span><span style="color: #DFDFDF;"> e s</span> <span style="color: #f0e68c;">=</span> e<span style="color: #f0e68c;">::</span>s

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">StackEmpty</span>
    <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>_ <span style="color: #f0e68c;">-&gt;</span> h
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">peek_opt</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">None</span>
    <span style="color: #f0e68c;">|</span>h<span style="color: #f0e68c;">::</span>_ <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> h

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">StackEmpty</span>
    <span style="color: #f0e68c;">|</span>_<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> t
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">pop_opt</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">None</span>
    <span style="color: #f0e68c;">|</span>_<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> t


<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-org4016118" class="outline-4">
<h4 id="org4016118">用options还是exceptions?</h4>
<div class="outline-text-4" id="text-org4016118">
<p>
在之前的大部分实现中, 我们都选择了用异常来处理意外情况. 还可以使用options, 使用options的坏处是这样的函数因为返回了 Some/None 导致 <code>|&gt;</code> 无法串联起一系列操作. 一个补救方法是定义新的管道符:
</p>

<ol class="org-ol">
<li>对输入/输出类型都不是 option 的函数</li>
</ol>
<p>
<code>... &gt;&gt;| f</code>
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">&gt;&gt;|</span> <span style="color: #f0e68c;">)</span> opt f <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">match</span> opt <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">None</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">None</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> x <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Some</span> <span style="color: #f0e68c;">(</span>f x<span style="color: #f0e68c;">)</span> 
</pre>
</div>
<ol class="org-ol">
<li>对输入类型不是option, 但输出类型为 option的函数</li>
</ol>
<p>
<code>... &gt;&gt;= f</code> 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">&gt;&gt;=</span> <span style="color: #f0e68c;">)</span> opt f <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">match</span> opt <span style="color: #51afef;">with</span>
  <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">None</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">None</span>
  <span style="color: #f0e68c;">|</span><span style="color: #bbc2cf; background-color: #242730;">Some</span> x <span style="color: #f0e68c;">-&gt;</span> f x 
</pre>
</div>


<p>
通常来说, 可以同时提供两种版本的函数, 比如: <code>peek</code> 和 <code>peek_opt</code> .
用opt后缀来标识返回类型为options的函数.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #FCCE7B;">StackImpl.</span> <span style="color: #f0e68c;">(</span>empty <span style="color: #f0e68c;">|&gt;</span> push 1 <span style="color: #f0e68c;">|&gt;</span> push 2 <span style="color: #f0e68c;">|&gt;</span> pop_opt <span style="color: #f0e68c;">&gt;&gt;|</span> push 4 <span style="color: #f0e68c;">&gt;&gt;=</span> peek_opt <span style="color: #f0e68c;">)</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-org4b11436" class="outline-4">
<h4 id="org4b11436">queues</h4>
<div class="outline-text-4" id="text-org4b11436">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">Queue</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span>
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyQueue</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">empty</span> <span style="color: #f0e68c;">:</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">is_empty</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> bool
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">size</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> int
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">enqueue</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">front</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">dequeue</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">to_list</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a list 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListQueue</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Queue</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> <span style="color: #f0e68c;">=</span> 'a list
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyQueue</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">is_empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">true</span>
    <span style="color: #f0e68c;">|</span> _ <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">size</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>length

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">enqueue</span><span style="color: #DFDFDF;"> e q</span> <span style="color: #f0e68c;">=</span> q <span style="color: #f0e68c;">@</span> <span style="color: #f0e68c;">[</span>e<span style="color: #f0e68c;">]</span>  <span style="color: #62686E;">(* </span><span style="color: #62686E;">!!</span><span style="color: #62686E;"> *)</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">front</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyQueue</span>
    <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>_ <span style="color: #f0e68c;">-&gt;</span> h
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">dequeue</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyQueue</span>
    <span style="color: #f0e68c;">|</span> _<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> t 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">to_list</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">Fun.</span>id <span style="color: #62686E;">(* </span><span style="color: #62686E;">&#24658;&#31561;&#26144;&#23556;</span><span style="color: #62686E;"> *)</span>
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="orge4ff116"></a>更高效的queue实现<br />
<div class="outline-text-5" id="text-orge4ff116">
<p>
“implementing a queue with two stacks”
</p>

<p>
主要是为避免入队操作是线性时间的. 分别用两个list 标识队列的前半和后半 , 后半部分是逆序存储的(为了能用cons完成入队操作) : 
</p>

<ul class="org-ul">
<li><code>前半[1;2] + 后半[6;5;4]  ==&gt; 队列[1;2;4;5;6]</code></li>

<li>入队: 当表示前半部分的list为空时, 入队元素优先进入前半list</li>

<li><p>
出队: 出队导致前半list为空后, 用后半list补充前半list .
</p>

<p>
在前面已经<a href="#org4c3241e">实现</a>过了
</p></li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org8593a23" class="outline-4">
<h4 id="org8593a23">maps</h4>
<div class="outline-text-4" id="text-org8593a23">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">Map</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #f0e68c;">(</span><span style="color: #FCCE7B;">'k</span><span style="color: #f0e68c;">,</span><span style="color: #FCCE7B;">'v</span><span style="color: #f0e68c;">)</span><span style="color: #FCCE7B;"> t</span>
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyMap</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">empty</span> <span style="color: #f0e68c;">:</span> <span style="color: #f0e68c;">(</span>'k<span style="color: #f0e68c;">,</span>'v<span style="color: #f0e68c;">)</span> t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">insert</span> <span style="color: #f0e68c;">:</span> 'k <span style="color: #f0e68c;">-&gt;</span> 'v <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>'k<span style="color: #f0e68c;">,</span>'v<span style="color: #f0e68c;">)</span> t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>'k<span style="color: #f0e68c;">,</span>'v<span style="color: #f0e68c;">)</span> t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">lookup</span> <span style="color: #f0e68c;">:</span> 'k <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>'k<span style="color: #f0e68c;">,</span>'v<span style="color: #f0e68c;">)</span> t <span style="color: #f0e68c;">-&gt;</span> 'v
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">bindings</span> <span style="color: #f0e68c;">:</span> <span style="color: #f0e68c;">(</span>'k<span style="color: #f0e68c;">,</span>'v<span style="color: #f0e68c;">)</span> t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>'k <span style="color: #f0e68c;">*</span> 'v<span style="color: #f0e68c;">)</span> list 
<span style="color: #f5deb3; font-weight: bold;">end</span> 
</pre>
</div>
<p>
允许有重复key:
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">AssocListMap</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Map</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #f0e68c;">(</span><span style="color: #FCCE7B;">'k</span><span style="color: #f0e68c;">,</span><span style="color: #FCCE7B;">'v</span><span style="color: #f0e68c;">)</span><span style="color: #FCCE7B;"> t</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span>'k<span style="color: #f0e68c;">*</span>'v<span style="color: #f0e68c;">)</span> list
  <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyMap</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">insert</span><span style="color: #DFDFDF;"> k v m</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span>k<span style="color: #f0e68c;">,</span>v<span style="color: #f0e68c;">)::</span>m

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">lookup</span><span style="color: #DFDFDF;"> k</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyMap</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">(</span>key<span style="color: #f0e68c;">,</span>value<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">::</span> t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #51afef;">if</span> k <span style="color: #f0e68c;">=</span> key <span style="color: #51afef;">then</span> value <span style="color: #51afef;">else</span> <span style="color: #f0e68c;">(</span>lookup k t<span style="color: #f0e68c;">)</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">bindings_aux</span><span style="color: #DFDFDF;"> m</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span> <span style="color: #f0e68c;">(</span>m <span style="color: #f0e68c;">|&gt;</span> map fst <span style="color: #f0e68c;">|&gt;</span>sort_uniq <span style="color: #FCCE7B;">Stdlib.</span>compare <span style="color: #f0e68c;">)</span>  
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">bindings</span><span style="color: #DFDFDF;"> m</span> <span style="color: #f0e68c;">=</span>  m <span style="color: #f0e68c;">|&gt;</span> bindings_aux <span style="color: #f0e68c;">|&gt;</span> <span style="color: #FCCE7B;">List.</span>map <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">k</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span> k<span style="color: #f0e68c;">,(</span>lookup k m<span style="color: #f0e68c;">)))</span>

<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
不允许有重复的key 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">UniqAssocListMap</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Map</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
   <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #f0e68c;">(</span><span style="color: #FCCE7B;">'k</span><span style="color: #f0e68c;">,</span><span style="color: #FCCE7B;">'v</span><span style="color: #f0e68c;">)</span><span style="color: #FCCE7B;"> t</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span>'k<span style="color: #f0e68c;">*</span>'v<span style="color: #f0e68c;">)</span> list
   <span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyMap</span>

   <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[]</span>

   <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">insert</span><span style="color: #DFDFDF;"> k v</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
     <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[(</span>k<span style="color: #f0e68c;">,</span>v<span style="color: #f0e68c;">)]</span>
     <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">(</span>key<span style="color: #f0e68c;">,</span>value<span style="color: #f0e68c;">)::</span>t <span style="color: #f0e68c;">-&gt;</span>  <span style="color: #51afef;">if</span> k<span style="color: #f0e68c;">=</span>key <span style="color: #51afef;">then</span> <span style="color: #f0e68c;">(</span>key<span style="color: #f0e68c;">,</span>v<span style="color: #f0e68c;">)::</span>t <span style="color: #51afef;">else</span> <span style="color: #f0e68c;">(</span>insert k v t <span style="color: #f0e68c;">)</span>

   <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">lookup</span><span style="color: #DFDFDF;"> k</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
     <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">EmptyMap</span>
     <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">(</span>key<span style="color: #f0e68c;">,</span>value<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">::</span> t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #51afef;">if</span> k <span style="color: #f0e68c;">=</span> key <span style="color: #51afef;">then</span> value <span style="color: #51afef;">else</span> <span style="color: #f0e68c;">(</span>lookup k t<span style="color: #f0e68c;">)</span>

   <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">bindings</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">Fun.</span>id 
 <span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org20027cd" class="outline-4">
<h4 id="org20027cd">sets</h4>
<div class="outline-text-4" id="text-org20027cd">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">Set</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">empty</span> <span style="color: #f0e68c;">:</span> 'a t 
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">add</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">mem</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a t <span style="color: #f0e68c;">-&gt;</span> bool
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">elements</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a list 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListSet</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Set</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> <span style="color: #f0e68c;">=</span> 'a list
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">add</span><span style="color: #DFDFDF;"> e s</span> <span style="color: #f0e68c;">=</span> e<span style="color: #f0e68c;">::</span>s
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">mem</span><span style="color: #DFDFDF;"> e</span>  <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span>
    <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #51afef;">if</span> h <span style="color: #f0e68c;">=</span> e <span style="color: #51afef;">then</span> <span style="color: #a991f1;">true</span> <span style="color: #51afef;">else</span> <span style="color: #f0e68c;">(</span>mem e t<span style="color: #f0e68c;">)</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">elements</span><span style="color: #DFDFDF;"> s</span> <span style="color: #f0e68c;">=</span> s <span style="color: #f0e68c;">|&gt;</span> <span style="color: #f0e68c;">(</span> <span style="color: #FCCE7B;">List.</span>sort_uniq <span style="color: #FCCE7B;">Stdlib.</span>compare <span style="color: #f0e68c;">)</span> 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">UniqListSet</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> <span style="color: #f0e68c;">=</span> 'a list
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">add</span><span style="color: #DFDFDF;"> e s</span> <span style="color: #f0e68c;">=</span>
    <span style="color: #51afef;">match</span> s <span style="color: #51afef;">with</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[</span>e<span style="color: #f0e68c;">]</span>
    <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #51afef;">if</span> h <span style="color: #f0e68c;">=</span> e <span style="color: #51afef;">then</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #51afef;">else</span> h<span style="color: #f0e68c;">::(</span>add e t<span style="color: #f0e68c;">)</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">mem</span><span style="color: #DFDFDF;"> e</span>  <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span>
    <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #51afef;">if</span> h <span style="color: #f0e68c;">=</span> e <span style="color: #51afef;">then</span> <span style="color: #a991f1;">true</span> <span style="color: #51afef;">else</span> mem e t

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">elements</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">Fun.</span>id 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3994f6f" class="outline-3">
<h3 id="org3994f6f">模块类型约束 module type constraints</h3>
<div class="outline-text-3" id="text-org3994f6f">
<p>
创建新的module type: 特化已有module type中的抽象类型 
</p>

<p>
module type 中允许声明 type / module / val(函数/变量)
其中不确定的是用type声明抽象类型, 以及声明module中包含的抽象类型 
</p>

<p>
我们可以基于一个已有的包含抽象类型的module type来创建一个指明了内部抽象类型的module type
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #bbc2cf; background-color: #242730;">MyType</span> <span style="color: #f5deb3; font-weight: bold;">with type</span> <span style="color: #FCCE7B;">t</span> <span style="color: #f0e68c;">=</span> int

<span style="color: #bbc2cf; background-color: #242730;">MyType</span> <span style="color: #f5deb3; font-weight: bold;">with module</span> <span style="color: #FCCE7B;">M</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">OtherModule</span>

<span style="color: #bbc2cf; background-color: #242730;">MyType</span> <span style="color: #f5deb3; font-weight: bold;">with type</span> <span style="color: #FCCE7B;">t1</span> <span style="color: #f0e68c;">=</span> int <span style="color: #f5deb3; font-weight: bold;">and type</span><span style="color: #DFDFDF;"> </span><span style="color: #FCCE7B;">t2</span> <span style="color: #f0e68c;">=</span> string <span style="color: #f5deb3; font-weight: bold;">and module</span> <span style="color: #FCCE7B;">M</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">OtherModule</span> 
</pre>
</div>
<p>
对module进行约束实际上是对其中的一组抽象type进行约束
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">XY</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">x</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">y</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">MyType</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">t</span>
  <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">M</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">XY</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">data</span> <span style="color: #f0e68c;">:</span> int 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ModImpl</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">XY</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">x</span> <span style="color: #f0e68c;">=</span> float
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">y</span> <span style="color: #f0e68c;">=</span> float 
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">New</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">MyType</span> <span style="color: #f5deb3; font-weight: bold;">with type</span> <span style="color: #FCCE7B;">t</span> <span style="color: #f0e68c;">=</span> string
                          <span style="color: #f5deb3; font-weight: bold;">and module</span> <span style="color: #FCCE7B;">M</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">ModImpl</span>  <span style="color: #ff4500;">;;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ModImpl</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">x</span> <span style="color: #f0e68c;">=</span> float
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">y</span> <span style="color: #f0e68c;">=</span> float 
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> _ <span style="color: #f0e68c;">:</span> <span style="color: #bbc2cf; background-color: #242730;">XY</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">ModImpl</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">New</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">MyType</span> <span style="color: #f5deb3; font-weight: bold;">with type</span> <span style="color: #FCCE7B;">t</span> <span style="color: #f0e68c;">=</span> string
                          <span style="color: #f5deb3; font-weight: bold;">and module</span> <span style="color: #FCCE7B;">M</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">ModImpl</span>  <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-orgd38a9f1" class="outline-3">
<h3 id="orgd38a9f1">includes</h3>
<div class="outline-text-3" id="text-orgd38a9f1">
<p>
复用已有module struct/type. 避免复制粘贴.
类似于OOP中的继承
</p>

<p>
例如, 已有接口Set和其实现ListSet
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">Set</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">empty</span> <span style="color: #f0e68c;">:</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">add</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">mem</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a t <span style="color: #f0e68c;">-&gt;</span> bool
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">elements</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a list
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListSet</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Set</span>  <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> <span style="color: #f0e68c;">=</span> 'a list
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">add</span><span style="color: #DFDFDF;"> e s</span> <span style="color: #f0e68c;">=</span> e<span style="color: #f0e68c;">::</span>s
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">mem</span><span style="color: #DFDFDF;"> e</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span>
    <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #51afef;">if</span> h<span style="color: #f0e68c;">=</span>e <span style="color: #51afef;">then</span> <span style="color: #a991f1;">true</span> <span style="color: #51afef;">else</span> mem e t
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">elements</span><span style="color: #DFDFDF;"> s</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>sort_uniq <span style="color: #FCCE7B;">Stdlib.</span>compare s
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
假设现在要对 ListSet 进行拓展, 增加 of<sub>list</sub> : 'a list -&gt; 'a t 函数
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListSetExtended</span>  <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">include</span> <span style="color: #FCCE7B;">ListSet</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">of_list</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">...</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<p>
对 module type的复用
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">SetExtended</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">include</span> <span style="color: #FCCE7B;">Set</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">of_list</span> <span style="color: #f0e68c;">:</span> 'a list <span style="color: #f0e68c;">-&gt;</span> 'a t
<span style="color: #f5deb3; font-weight: bold;">end</span>

</pre>
</div>
<pre class="example">
module type SetExtended =
  sig
    type 'a t
    val empty : 'a t
    val add : 'a -&gt; 'a t -&gt; 'a t
    val mem : 'a -&gt; 'a t -&gt; bool
    val elements : 'a t -&gt; 'a list
    val of_list : 'a t -&gt; 'a list
  end
</pre>
</div>
<div id="outline-container-org9e25499" class="outline-4">
<h4 id="org9e25499">include的语义</h4>
<div class="outline-text-4" id="text-org9e25499">
</div>
<ul class="org-ul">
<li><a id="org9428149"></a>include 一个 struct<br />
<div class="outline-text-5" id="text-org9428149">
<p>
只是为了少写重复定义的语法糖, 本质上和手工写重复的定义是一样的.
</p>
</div>
</li>

<li><a id="org0f41f9e"></a>include 一个 signature<br /></li>
</ul>
</div>

<div id="outline-container-orgc4b30eb" class="outline-4">
<h4 id="orgc4b30eb">封装和includes</h4>
<div class="outline-text-4" id="text-orgc4b30eb">
<p>
include引入的被封装的struct中的内容对当前struct的实现仍是不可见的. 
</p>

<div class="org-src-container">
<pre class="src src-ocaml">  <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListSetExtended</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">SetExtended</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
    <span style="color: #f5deb3; font-weight: bold;">include</span> <span style="color: #FCCE7B;">ListSet</span>
    <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">of_list</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">Fun.</span>id 
  <span style="color: #f5deb3; font-weight: bold;">end</span>
<span style="color: #62686E;">(* </span><span style="color: #62686E;">&#36825;&#26679;&#23454;&#29616;&#26159;&#38169;&#35823;&#30340; :</span><span style="color: #62686E;"> *)</span> 
    <span style="color: #bbc2cf; background-color: #242730;">Values</span> <span style="color: #51afef;">do</span> <span style="color: #f0e68c;">not</span> <span style="color: #51afef;">match</span><span style="color: #f0e68c;">:</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">of_list</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a
      is <span style="color: #f0e68c;">not</span> included <span style="color: #f5deb3; font-weight: bold;">in</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">of_list</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a list
</pre>
</div>
<p>
和上面的ListSetExtended的例子稍有不同: 这个模块有了signature的约束.
因此 <code>of_list</code> 的类型必须能满足 <code>SetExtended</code> 中的签名. 我们之前提到过, 满足签名不意味着类型要完全一致, 比签名中的类型更宽泛亦可.因此下面这个例子是可以通过编译的. 
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">T</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> 
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">foo</span> <span style="color: #f0e68c;">:</span> 'a list <span style="color: #f0e68c;">-&gt;</span> 'a t 
<span style="color: #f5deb3; font-weight: bold;">end</span> 

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">M</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">T</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span> 
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> <span style="color: #f0e68c;">=</span> 'a list 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">foo</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span> lst  <span style="color: #62686E;">(* </span><span style="color: #62686E;">'a -&gt; 'a</span><span style="color: #62686E;"> *)</span>
<span style="color: #f5deb3; font-weight: bold;">end</span> <span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
但为什么上面的例子不行呢?
原因在于 include 引入的 <code>module ListSet</code> 本身是被封装过的(实现了 <code>sig Set</code> , 因而类型对外是抽象的) 所以在struct的实现中, 不知道这个抽象类型 <code>'a t</code> 其实就是 <code>'a list</code>, 而用Fun.id实现的 <code>of_list</code> 是要求输入类型和输出类型相同的函数, 因此判定 <code>of_list : 'a -&gt; 'a</code> 无法满足 <code>'a list -&gt; 'a t</code> 的约束
</p>

<p>
因此要用ListSet中对外暴露的东西来实现 <code>of_list</code> ,以得到正确的类型:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListSetExtended</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">SetExtended</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">include</span> <span style="color: #FCCE7B;">ListSet</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">of_list</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>fold_right add lst empty 
<span style="color: #f5deb3; font-weight: bold;">end</span>  <span style="color: #ff4500;">;;</span>
</pre>
</div>
</div>
</div>




<div id="outline-container-org8d37222" class="outline-4">
<h4 id="org8d37222">open和include的对比</h4>
</div>

<div id="outline-container-orgcfc683b" class="outline-4">
<h4 id="orgcfc683b">在多个模块中include同一块代码</h4>
<div class="outline-text-4" id="text-orgcfc683b">
<p>
假设现在要对Set的两个实现都添加 <code>of_list</code> 函数. 考虑到抽象原则, 要将重复的代码提出来, 而不是用复制粘贴.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">of_list</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span>  <span style="color: #FCCE7B;">List.</span>fold_right add lst empty
</pre>
</div>
<p>
但这段代码离开Set后就需要将Set的操作作为参数传入:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">set_of_list</span><span style="color: #DFDFDF;"> add empty lst</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>fold_right add lst empty 
</pre>
</div>
<p>
为了复用这段代码, 将它用module包裹起来:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">SetOfList</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">set_of_list</span><span style="color: #DFDFDF;"> add empty lst</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>fold_right add lst empty  
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListSetExtended</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">SetExtended</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">include</span> <span style="color: #FCCE7B;">ListSet</span>
  <span style="color: #f5deb3; font-weight: bold;">include</span> <span style="color: #FCCE7B;">SetOfList</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">of_list</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span> set_of_list add empty lst 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">UniqListSetExtended</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">SetExtended</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">include</span> <span style="color: #FCCE7B;">UniqListSet</span>
  <span style="color: #f5deb3; font-weight: bold;">include</span> <span style="color: #FCCE7B;">SetOfList</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">of_list</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span> set_of_list add empty lst 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<p>
但这样的做法仍不满足抽象原则: 其 <code>of_list</code> 的定义出现了重复
(后面会用functor来解决 )
</p>
</div>
</div>
</div>



<div id="outline-container-orgc639543" class="outline-3">
<h3 id="orgc639543">functors: 从模块到模块的映射</h3>
<div class="outline-text-3" id="text-orgc639543">
<p>
用functor可以解决上面提到的模块中的代码重复
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">T</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">x</span> <span style="color: #f0e68c;">:</span> int
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">IncX</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">M </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> T</span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">M.</span>x<span style="color: #f0e68c;">+</span>1 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">IncX</span> <span style="color: #f0e68c;">:</span> <span style="color: #f5deb3; font-weight: bold;">functor</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">M</span> <span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> T</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f5deb3; font-weight: bold;">sig</span> <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">x</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<p>
用functor是除了struct外第二个能产生模块值的方法:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">A</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span> <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">=</span> 0 <span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">B</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">IncX</span><span style="color: #f0e68c;">(</span><span style="color: #FCCE7B;">A</span><span style="color: #f0e68c;">)</span> 
</pre>
</div>



<p>
除了将functor看作是一个映射, 还可以将其看作是"参数化的struct"
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">IncX</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">M </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> T</span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">M.</span>x<span style="color: #f0e68c;">+</span>1 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
其参数是类型为T的M 
</p>


<p>
functor返回的module可以和输入的module毫无关系 
</p>
<div class="org-src-container">
<pre class="src src-ocaml">
<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">IncX</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">M </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> T</span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span> 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">foo</span><span style="color: #DFDFDF;"> x</span> <span style="color: #f0e68c;">=</span> x<span style="color: #f0e68c;">+</span>1
<span style="color: #f5deb3; font-weight: bold;">end</span> <span style="color: #ff4500;">;;</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">IncX</span> <span style="color: #f0e68c;">:</span> <span style="color: #f5deb3; font-weight: bold;">functor</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">M</span> <span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> T</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f5deb3; font-weight: bold;">sig</span> <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">foo</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<p>
functor可以作用在一个无名的structure上:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">X</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">IncX</span><span style="color: #f0e68c;">(</span><span style="color: #FCCE7B;"> </span><span style="color: #f5deb3; font-weight: bold;">struct</span><span style="color: #FCCE7B;"> </span><span style="color: #f5deb3; font-weight: bold;">let</span><span style="color: #FCCE7B;"> x </span><span style="color: #f0e68c;">=</span><span style="color: #FCCE7B;"> 10 </span><span style="color: #f5deb3; font-weight: bold;">end</span><span style="color: #f0e68c;">)</span> 
</pre>
</div>
</div>

<div id="outline-container-org24c075a" class="outline-4">
<h4 id="org24c075a">functor的语法和语义</h4>
<div class="outline-text-4" id="text-org24c075a">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">F</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">M1</span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;">T1</span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;">  </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">M2</span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;">T2</span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">...</span>  <span style="color: #f0e68c;">:</span> <span style="color: #bbc2cf; background-color: #242730;">S</span>  <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span> 

<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
和普通函数一样, 上面的多参数functor也是某种匿名functor的语法糖.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">F</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #f5deb3; font-weight: bold;">functor</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">M1</span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;">T1</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span>
  <span style="color: #f5deb3; font-weight: bold;">functor</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">M2</span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;">T2</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span>
    <span style="color: #f0e68c;">...</span>
  <span style="color: #f5deb3; font-weight: bold;">functor</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">M</span> <span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> T</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> 
<span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f0e68c;">...</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-orgaa067ac" class="outline-4">
<h4 id="orgaa067ac">functor type的语法和语义</h4>
<div class="outline-text-4" id="text-orgaa067ac">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">Add</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">add</span> <span style="color: #f0e68c;">:</span> int <span style="color: #f0e68c;">-&gt;</span> int
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">AddX</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">M </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> T</span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">add</span><span style="color: #DFDFDF;"> y</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">M.</span>x <span style="color: #f0e68c;">+</span> y
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">CheckAddX</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">T</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">Add</span> <span style="color: #f0e68c;">=</span>  <span style="color: #bbc2cf; background-color: #242730;">AddX</span> 
</pre>
</div>
<p>
CheckAddX 是一个输入类型为T, 输出类型为Add的functor
</p>

<p>
会发现这个functor的签名中包含了参数名! 这点和函数的签名是不同的.
当functor的输出模块使用了输入模块中的类型时, 可以看出这样设计的原因 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">T</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">t</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">x</span> <span style="color: #f0e68c;">:</span> t
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">PairX</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">M </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> T</span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">p</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span><span style="color: #FCCE7B;">M.</span>x <span style="color: #f0e68c;">,</span> 1<span style="color: #f0e68c;">)</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
因为输出类型中使用了 T中声明的抽象类型t , 为了引用到这个t, 必须要有它所在的那个模块名, 因此functor的签名中必须包含参数的名字. 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">T</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">t</span> <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">x</span> <span style="color: #f0e68c;">:</span> t <span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">PairX</span> <span style="color: #f0e68c;">:</span> <span style="color: #f5deb3; font-weight: bold;">functor</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">M</span> <span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> T</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f5deb3; font-weight: bold;">sig</span> <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">p</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">M.</span>t <span style="color: #f0e68c;">*</span> int <span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<pre class="example">
*functor type* 是一种高级编程语言的特性:依赖类型 的例子, 它描述了输出类型被输入类型决定的现象. (和函数不同, 函数的输入输出类型之间是独立的) 
</pre>

<p>
为functor传入的实际模块的类型不一定要和声明中的类型完全一致, 也可以传入其 <b>子类型</b> :
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">F</span> <span style="color: #f0e68c;">(</span><span style="color: #bbc2cf; background-color: #242730;">M</span> <span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> </span><span style="color: #f5deb3; font-weight: bold;">sig</span><span style="color: #FCCE7B;"> </span><span style="color: #f5deb3; font-weight: bold;">val</span><span style="color: #FCCE7B;"> x </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;">int </span><span style="color: #f5deb3; font-weight: bold;">end</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">M.</span>x <span style="color: #f0e68c;">+</span>1
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">A</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">=</span> 1
<span style="color: #f5deb3; font-weight: bold;">end</span>
<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">B</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">x</span> <span style="color: #f0e68c;">=</span> 2
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">y</span> <span style="color: #f0e68c;">=</span> 100
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> _ <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">F</span><span style="color: #f0e68c;">(</span><span style="color: #bbc2cf; background-color: #242730;">A</span><span style="color: #f0e68c;">)</span>
<span style="color: #f5deb3; font-weight: bold;">module</span> _ <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">F</span><span style="color: #f0e68c;">(</span><span style="color: #bbc2cf; background-color: #242730;">B</span><span style="color: #f0e68c;">)</span> 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgda5745a" class="outline-4">
<h4 id="orgda5745a">应用: Map模块中使用functor</h4>
<div class="outline-text-4" id="text-orgda5745a">
<p>
这是用来创建一个具体Map模块的functor
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">Make</span> <span style="color: #f0e68c;">:</span>
  <span style="color: #f5deb3; font-weight: bold;">functor</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">Order</span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> OrderType </span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #bbc2cf; background-color: #242730;">S</span> <span style="color: #f5deb3; font-weight: bold;">with type</span> <span style="color: #FCCE7B;">key</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">Order.</span>t 
</pre>
</div>
<p>
输入类型 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">OrderType</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">t</span>  <span style="color: #62686E;">(* </span><span style="color: #62686E;">key&#30340;&#31867;&#22411;</span><span style="color: #62686E;"> *)</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">compare</span> <span style="color: #f0e68c;">:</span> t <span style="color: #f0e68c;">-&gt;</span> t <span style="color: #f0e68c;">-&gt;</span> int <span style="color: #62686E;">(* </span><span style="color: #62686E;">&#23450;&#20041;&#20102;key1 - key2 = ?</span><span style="color: #62686E;"> *)</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<p>
输出类型 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">S</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">key</span>
  <span style="color: #f0e68c;">.....</span> <span style="color: #62686E;">(* </span><span style="color: #62686E;">&#21508;&#31181;Map&#30340;&#25805;&#20316;</span><span style="color: #62686E;"> *)</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<p>
使用 <code>Map.Make()</code> 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">day</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">Mon</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Tue</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Wed</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Thu</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Fri</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Sat</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Sun</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">int_of_day</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Mon</span> <span style="color: #f0e68c;">-&gt;</span> 1
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Tue</span> <span style="color: #f0e68c;">-&gt;</span> 2
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Wed</span><span style="color: #f0e68c;">-&gt;</span> 3
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Thu</span> <span style="color: #f0e68c;">-&gt;</span> 4
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Fri</span> <span style="color: #f0e68c;">-&gt;</span> 5
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Sat</span> <span style="color: #f0e68c;">-&gt;</span> 6
  <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">Sun</span> <span style="color: #f0e68c;">-&gt;</span> 7

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">DayKey</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">t</span> <span style="color: #f0e68c;">=</span> day
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">compare</span><span style="color: #DFDFDF;"> d1 d2</span> <span style="color: #f0e68c;">=</span>
    <span style="color: #f0e68c;">(</span>int_of_day d1<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">(</span>int_of_day d2<span style="color: #f0e68c;">)</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">DayMap</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">Map.Make</span><span style="color: #f0e68c;">(</span><span style="color: #FCCE7B;">DayKey</span><span style="color: #f0e68c;">)</span>

<span style="color: #FCCE7B;">DayMap.</span> <span style="color: #f0e68c;">(</span>empty <span style="color: #f0e68c;">|&gt;</span> add <span style="color: #bbc2cf; background-color: #242730;">Mon</span> <span style="color: #7bc275;">"monday"</span> <span style="color: #f0e68c;">|&gt;</span> add <span style="color: #bbc2cf; background-color: #242730;">Tue</span> <span style="color: #7bc275;">"tuesday"</span> <span style="color: #f0e68c;">)</span> 

</pre>
</div>

<p>
模块类型约束
Make的返回类型中使用了module类型约束, 来生成一个新的特化的module type 
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #bbc2cf; background-color: #242730;">S</span> <span style="color: #f5deb3; font-weight: bold;">with type</span> <span style="color: #FCCE7B;">key</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">Order.</span>t 
</pre>
</div>
<p>
目的是为了让生成的模块中不含抽象类型, 使得使用者能用键原本的类型, 而不是抽象类型key.
</p>
</div>
</div>



<div id="outline-container-orgb2f903e" class="outline-4">
<h4 id="orgb2f903e">应用: 为多个sig实现编写单元测试</h4>
<div class="outline-text-4" id="text-orgb2f903e">
<p>
本质上是为了在只有模块名不同时避免代码重复.
</p>

<p>
假设要对Stack编写单元测试, 并且有两种Stack实现.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #51afef;">exception</span> <span style="color: #bbc2cf; background-color: #242730;">Empty</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">Stack</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">empty</span> <span style="color: #f0e68c;">:</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">push</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListStack</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> <span style="color: #f0e68c;">=</span> 'a list
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">push</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>cons
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">Empty</span> <span style="color: #f0e68c;">|</span> x <span style="color: #f0e68c;">::</span> _ <span style="color: #f0e68c;">-&gt;</span> x
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">Empty</span> <span style="color: #f0e68c;">|</span> _ <span style="color: #f0e68c;">::</span> s <span style="color: #f0e68c;">-&gt;</span> s
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">VariantStack</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">E</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">S</span> <span style="color: #51afef;">of</span> 'a <span style="color: #f0e68c;">*</span> 'a t
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">E</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">push</span><span style="color: #DFDFDF;"> x s</span> <span style="color: #f0e68c;">=</span> <span style="color: #bbc2cf; background-color: #242730;">S</span> <span style="color: #f0e68c;">(</span>x<span style="color: #f0e68c;">,</span> s<span style="color: #f0e68c;">)</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">peek</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span> <span style="color: #bbc2cf; background-color: #242730;">E</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">Empty</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">S</span> <span style="color: #f0e68c;">(</span>x<span style="color: #f0e68c;">,</span> _<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> x
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">pop</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span> <span style="color: #bbc2cf; background-color: #242730;">E</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #C57BDB;">raise</span> <span style="color: #bbc2cf; background-color: #242730;">Empty</span> <span style="color: #f0e68c;">|</span> <span style="color: #bbc2cf; background-color: #242730;">S</span> <span style="color: #f0e68c;">(</span>_<span style="color: #f0e68c;">,</span> s<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> s
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<p>
可想而知, 测试用的代码基本上是相同的. 差别只在模块名上.
因此要以模块作为参数:
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">StackTester</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">S</span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;">Stack</span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">tests</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[</span>
    <span style="color: #7bc275;">"peek (push x empty) = x"</span> <span style="color: #f0e68c;">&gt;::</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">_</span> <span style="color: #f0e68c;">-&gt;</span> assert_equal 3 <span style="color: #FCCE7B;">S.</span> <span style="color: #f0e68c;">(</span>empty <span style="color: #f0e68c;">|&gt;</span> push 3 <span style="color: #f0e68c;">|&gt;</span> peek<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">)</span>
  <span style="color: #f0e68c;">]</span>
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">LTest</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">StackTester</span><span style="color: #f0e68c;">(</span><span style="color: #FCCE7B;">ListStack</span><span style="color: #f0e68c;">)</span>
<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">VTest</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">StackTester</span><span style="color: #f0e68c;">(</span><span style="color: #FCCE7B;">VariantStack</span><span style="color: #f0e68c;">)</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">alltests</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>flatten <span style="color: #f0e68c;">[</span> <span style="color: #FCCE7B;">LTest.</span>tests<span style="color: #f0e68c;">;</span> <span style="color: #FCCE7B;">VTest.</span>tests <span style="color: #f0e68c;">]</span>
</pre>
</div>

<p>
这里的一个小技巧是用 <code>List.flatten</code> 将list的list "拍扁"为list
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #FCCE7B;">List.</span>flatten <span style="color: #f0e68c;">[</span> <span style="color: #f0e68c;">[</span>2<span style="color: #f0e68c;">;</span>3<span style="color: #f0e68c;">;</span>4<span style="color: #f0e68c;">]</span> <span style="color: #f0e68c;">;[</span>0<span style="color: #f0e68c;">]</span> <span style="color: #f0e68c;">;</span> <span style="color: #f0e68c;">[</span>5<span style="color: #f0e68c;">;</span>7<span style="color: #f0e68c;">]</span> <span style="color: #f0e68c;">]</span>
<span style="color: #62686E;">(* </span><span style="color: #62686E;">- : int list = [2; 3; 4; 0; 5; 7]</span><span style="color: #62686E;"> *)</span>
</pre>
</div>



<p>
但这段代码的方案仍不够精简, 假若Stack的实现有100个, 那么需要将StackTester()应用到每个module上, 这造成了大量重复代码.
因此解决方案是批量应用StackTester()到每个Stack的实现module上, 为此需要将这些实现放进一个list
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">stackimpls</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">module</span> <span style="color: #FCCE7B;">ListStack</span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> </span><span style="color: #FCCE7B;">Stack</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">;</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">module</span> <span style="color: #FCCE7B;">VariantStack</span> <span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> </span><span style="color: #FCCE7B;">Stack</span><span style="color: #f0e68c;">);</span> <span style="color: #f0e68c;">.....</span> <span style="color: #f0e68c;">]</span>

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">get_tests</span><span style="color: #DFDFDF;"> m</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">StackImpl</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span><span style="color: #51afef;">val</span> <span style="color: #FCCE7B;">m </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> </span><span style="color: #FCCE7B;">Stack</span><span style="color: #f0e68c;">)</span>
  <span style="color: #f5deb3; font-weight: bold;">in</span>
    <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">StackTests</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">StackTester</span><span style="color: #f0e68c;">(</span><span style="color: #FCCE7B;">StackImpl</span><span style="color: #f0e68c;">)</span>
    <span style="color: #f5deb3; font-weight: bold;">in</span> <span style="color: #FCCE7B;">StackTests.</span>tests

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">all_tests</span> <span style="color: #f0e68c;">=</span> stackimpls <span style="color: #f0e68c;">|&gt;</span> <span style="color: #FCCE7B;">List.</span>map get_tests <span style="color: #f0e68c;">|&gt;</span> <span style="color: #FCCE7B;">List.</span>flatten 


</pre>
</div>

<p>
这里的 <code>(module ListStack: Stack)</code> 和 <code>let module StackImpl = (val m : Stack)</code> 都使用了first class module, 可以让module作为普通值进行传递  
</p>
</div>
</div>


<div id="outline-container-orge1064fb" class="outline-4">
<h4 id="orge1064fb">应用: 解决为Set添加 <code>of_list</code></h4>
<div class="outline-text-4" id="text-orge1064fb">
<p>
我们之前的做法是分别为每个Set的实现用include引入原有的定义后,再额外定义一个 <code>of_list</code> 方法. 这导致了重复的模式, 现在有了能产生module的函数: functor , 通过它可以将重复部分提出作为functor
</p>


<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">SetWithOfList</span> <span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">M</span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> Set</span><span style="color: #f0e68c;">)</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #f5deb3; font-weight: bold;">include</span> <span style="color: #FCCE7B;">M</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">of_list</span><span style="color: #DFDFDF;"> s</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>fold_right <span style="color: #FCCE7B;">M.</span>add lst  <span style="color: #FCCE7B;">M.</span>empty
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>

<p>
这个方法比起OOP中的继承更加灵活, 产生的module type 不必是被拓展module type的子类型. 
</p>
</div>
</div>
</div>
</div>









<div id="outline-container-org1f1656f" class="outline-2">
<h2 id="org1f1656f">抽象</h2>
<div class="outline-text-2" id="text-org1f1656f">
</div>
<div id="outline-container-org63f79fa" class="outline-3">
<h3 id="org63f79fa">何为抽象?</h3>
<div class="outline-text-3" id="text-org63f79fa">
<p>
作为动词: 它意味着忽略掉一部分信息, 从而将不同的事物能看作是相同的事物.
作为名词: 它是从上面的过程中产生的函数/module/class &#x2026; 
</p>
</div>
</div>


<div id="outline-container-orgca81440" class="outline-3">
<h3 id="orgca81440">规范</h3>
<div class="outline-text-3" id="text-orgca81440">
<p>
名词: 抽象的预期行为
动词: 这是创建这些函数/class/module的行为
</p>
</div>

<div id="outline-container-orgfdb155d" class="outline-4">
<h4 id="orgfdb155d">规范的受众</h4>
<div class="outline-text-4" id="text-orgfdb155d">
<ul class="org-ul">
<li>使用者
<ul class="org-ul">
<li>前置条件: 使用前必须满足的条件</li>
<li>后置条件: 对输出可以进行哪些假设</li>
</ul></li>
<li>实现者 
<ul class="org-ul">
<li>前置: 调用前可以假设已经满足了哪些条件</li>
<li>后置: 调用后必须的满足的条件</li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-orgf6cc5a8" class="outline-4">
<h4 id="orgf6cc5a8">好处</h4>
<div class="outline-text-4" id="text-orgf6cc5a8">
<ul class="org-ul">
<li>局部性: 不用看实现就能理解抽象的含义</li>
<li>可修改: 可以更改实现而不需要修改其使用者的代码</li>
<li>可追责: 在出现问题时能界定是调用者还是实现者犯了错误</li>
</ul>
</div>
</div>


<div id="outline-container-org9d4f564" class="outline-4">
<h4 id="org9d4f564">函数规范的写法</h4>
<div class="outline-text-4" id="text-org9d4f564">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #7e7e87;">(** [f x] is ... &#20989;&#25968;&#30340;&#21151;&#33021;</span>
<span style="color: #7e7e87;">    Example: ... &#20363;&#23376;</span>
<span style="color: #7e7e87;">    Requires: ... &#21069;&#32622;&#26465;&#20214;</span>
<span style="color: #7e7e87;">    Raise: ...  *)</span>
<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">f</span><span style="color: #f0e68c;">:</span> t <span style="color: #f0e68c;">-&gt;</span> u
</pre>
</div>
</div>
</div>


<div id="outline-container-org9bc3f43" class="outline-4">
<h4 id="org9bc3f43">library 规范</h4>
<div class="outline-text-4" id="text-org9bc3f43">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">sort</span> <span style="color: #f0e68c;">:</span>
  <span style="color: #f0e68c;">(</span>'a <span style="color: #f0e68c;">-&gt;</span> 'a <span style="color: #f0e68c;">-&gt;</span> int<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">-&gt;</span> 'a list <span style="color: #f0e68c;">-&gt;</span> 'a list
</pre>
</div>
<p>
根据比较函数将list排序为升序. [一句话概述此函数的功能]
comparison函数必须在比较的两个参数相等时返回0, 当第一个参数更大时返回一个正数, 当第二个参数更大时返回一个负数.例如 <code>compare</code> 就是一个合适的比较函数. [前置条件]
返回的结果list是按照升序排列的. [后置条件]
<code>List.sort</code> 保证使用常量级别的堆空间和log级别的stack空间. [对效率的保证] 
</p>
</div>
</div>


<div id="outline-container-orgbc0027c" class="outline-4">
<h4 id="orgbc0027c">requires子句</h4>
<div class="outline-text-4" id="text-orgbc0027c">
<p>
若结果不符合预期,则应该责怪使用者
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #7e7e87;">(** [hd lst] is the head of [lst].</span>
<span style="color: #7e7e87;">    Requires: [lst] is non-empty. *)</span>
<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">hd</span> <span style="color: #f0e68c;">:</span> 'a list <span style="color: #f0e68c;">-&gt;</span> 'a 
</pre>
</div>
<p>
前置条件precondition不必总是需要在代码中进行验证的, 因为有些验证会花费大量的时间(&gt;常数级别) . 在实践中只去检查那些简单的/开销低的前置条件.
</p>
</div>
</div>

<div id="outline-container-orgcaeadda" class="outline-4">
<h4 id="orgcaeadda">Returns 子句</h4>
<div class="outline-text-4" id="text-orgcaeadda">
<p>
在ocaml的文档中, 不需要显式写出returns子句, 而是被包含第一句中.
若结果不符合预期, 则应该责怪实现者. 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #7e7e87;">(** [sort lst] contains the same elements as [lst], but sorted in ascending order. *)</span>
<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">sort</span> <span style="color: #f0e68c;">:</span> int list <span style="color: #f0e68c;">-&gt;</span> int list
</pre>
</div>
</div>
</div>

<div id="outline-container-org690a019" class="outline-4">
<h4 id="org690a019">Examples 子句</h4>
<div class="outline-text-4" id="text-org690a019">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #7e7e87;">(** Examples:</span>
<span style="color: #7e7e87;">  - [sort [1;3;2]] is [[1;2;3]].</span>
<span style="color: #7e7e87;">  - [sort []] is [[]]. *)</span>
<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">sort</span> <span style="color: #f0e68c;">:</span> int list <span style="color: #f0e68c;">-&gt;</span> int list 
</pre>
</div>
<p>
要列举出包含边界条件的例子.
</p>
</div>
</div>

<div id="outline-container-orge040116" class="outline-4">
<h4 id="orge040116">Raises 子句</h4>
<div class="outline-text-4" id="text-orge040116">
<p>
这也是一个后置条件, 实现者必须提供此行为.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #7e7e87;">(** [hd lst] is the head of [hd].</span>
<span style="color: #7e7e87;">      Requires: [lst] is non-empty.</span>
<span style="color: #7e7e87;">      Raises: [Failure "hd"] if [lst] is empty.  *)</span>
<span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">hd</span> <span style="color: #f0e68c;">:</span> 'a list <span style="color: #f0e68c;">-&gt;</span> 'a 
</pre>
</div>
</div>
</div>



<div id="outline-container-org8434050" class="outline-4">
<h4 id="org8434050">数据抽象</h4>
<div class="outline-text-4" id="text-org8434050">
<p>
<b>数据抽象</b> 是在某种集合上的一系列运算的规范.
例如: stacks有push/pop/peek&#x2026;操作, 而无需指明其值具体是什么
ocaml中的带有抽象类型的signature就是 <b>数据抽象</b> 的例子.
</p>

<p>
<b>数据结构</b> 是数据抽象的一种特殊实现.
例如 <code>ListStack</code> 用 <code>'a list/(::)</code> &#x2026; 实现了 <code>Stack</code> signature.
因此 struct 是数据结构的例子.
</p>
</div>
</div>


<div id="outline-container-org7f68aca" class="outline-4">
<h4 id="org7f68aca">例子: Set</h4>
<div class="outline-text-4" id="text-org7f68aca">
<p>
数据抽象:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">Set</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">sig</span>
  <span style="color: #7e7e87;">(** ['a t] is the type of a set whose elements have type ['a] *)</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span>
  <span style="color: #7e7e87;">(** [empty] is a empty set *)</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">empty</span> <span style="color: #f0e68c;">:</span> 'a t
  <span style="color: #7e7e87;">(** [add e s] is a set containing all the elements of [s] and element [e] *)</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">add</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
  <span style="color: #7e7e87;">(** [size s] is the number of elements in [s]</span>
<span style="color: #7e7e87;">      [size empty] is zero *)</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">size</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> int
    <span style="color: #7e7e87;">(** [mem e s] is true iff [e] is an element of [s] *)</span>
  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">mem</span> <span style="color: #f0e68c;">:</span> 'a <span style="color: #f0e68c;">-&gt;</span> 'a t <span style="color: #f0e68c;">-&gt;</span> bool

  <span style="color: #f5deb3; font-weight: bold;">val</span> <span style="color: #5cEfFF;">union</span> <span style="color: #f0e68c;">:</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t <span style="color: #f0e68c;">-&gt;</span> 'a t
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>
<p>
数据结构: 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListSetImpl</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #7e7e87;">(** the list cannot contain duplicates*)</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> <span style="color: #f0e68c;">=</span> 'a list
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">add</span><span style="color: #DFDFDF;"> e</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[</span>e<span style="color: #f0e68c;">]</span>
    <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #51afef;">if</span> h <span style="color: #f0e68c;">=</span> e <span style="color: #51afef;">then</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #51afef;">else</span> h<span style="color: #f0e68c;">::(</span>add e t<span style="color: #f0e68c;">)</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">size</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>length
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">mem</span><span style="color: #DFDFDF;"> e</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span>
    <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>h <span style="color: #f0e68c;">=</span> e<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">||</span> <span style="color: #f0e68c;">(</span>mem e t<span style="color: #f0e68c;">)</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">union</span><span style="color: #DFDFDF;"> s1 s2</span> <span style="color: #f0e68c;">=</span> s1 <span style="color: #f0e68c;">@</span> s2 <span style="color: #f0e68c;">|&gt;</span> <span style="color: #FCCE7B;">List.</span>sort_uniq <span style="color: #FCCE7B;">Stdlib.</span>compare
<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListSet</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Set</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">ListSetImpl</span> <span style="color: #ff4500;">;;</span> 
</pre>
</div>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListSetDupsImpl</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #7e7e87;">(** the list may contain duplicates*)</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> <span style="color: #f0e68c;">=</span> 'a list 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">[]</span>
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">add</span><span style="color: #DFDFDF;"> e s</span><span style="color: #f0e68c;">=</span> e<span style="color: #f0e68c;">::</span>s
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">size</span><span style="color: #DFDFDF;"> s</span> <span style="color: #f0e68c;">=</span> s <span style="color: #f0e68c;">|&gt;</span> <span style="color: #f0e68c;">(</span><span style="color: #FCCE7B;">List.</span>sort_uniq <span style="color: #FCCE7B;">Stdlib.</span>compare <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">|&gt;</span> <span style="color: #FCCE7B;">List.</span>length 
  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">mem</span><span style="color: #DFDFDF;"> e</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span>
    <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>h <span style="color: #f0e68c;">=</span> e<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">||</span> <span style="color: #f0e68c;">(</span>mem e t<span style="color: #f0e68c;">)</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">union</span><span style="color: #DFDFDF;"> s1 s2</span> <span style="color: #f0e68c;">=</span> s1 <span style="color: #f0e68c;">@</span> s2 
<span style="color: #f5deb3; font-weight: bold;">end</span>
</pre>
</div>


<p>
ch6 P1-36
</p>
</div>
</div>
</div>
<div id="outline-container-org2262dc2" class="outline-3">
<h3 id="org2262dc2">抽象函数 AF</h3>
<div class="outline-text-3" id="text-org2262dc2">
<p>
抽象函数/映射是描述如何将数据的 <b>有效</b> 的具体值映射为用户视角中的抽象值.
</p>

<p>
eg: set的抽象 
[1;2;2] -&gt; {1,2}
[1;2] -&gt; {1,2}
</p>

<p>
抽象函数是文档的一部分,一般写在type的前面. 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #7e7e87;">(** AF: .. *)</span> 
</pre>
</div>


<p>
抽象函数是头脑中的概念, 是没有实现的. 但java中的 <code>tostring</code> 很接近抽象函数的实现. 
</p>
<div class="org-src-container">
<pre class="src src-ocaml">
<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">removedups</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span>
  lst <span style="color: #f0e68c;">|&gt;</span> <span style="color: #FCCE7B;">List.</span>sort_uniq <span style="color: #FCCE7B;">Stdlib.</span>compare

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">string_of_list</span><span style="color: #DFDFDF;"> string_of_ele</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">function</span>
  <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">""</span>  
  <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #7bc275;">"{ "</span> <span style="color: #f0e68c;">^</span> <span style="color: #f0e68c;">(</span><span style="color: #FCCE7B;">List.</span>fold_left <span style="color: #f0e68c;">(</span><span style="color: #51afef;">fun</span> <span style="color: #DFDFDF;">acc e</span> <span style="color: #f0e68c;">-&gt;</span> acc <span style="color: #f0e68c;">^</span> <span style="color: #7bc275;">","</span> <span style="color: #f0e68c;">^</span> <span style="color: #f0e68c;">(</span>string_of_ele e<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">)</span> t <span style="color: #f0e68c;">(</span>string_of_ele h<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">^</span> <span style="color: #7bc275;">" }"</span>

</pre>
</div>
</div>
</div>
<div id="outline-container-orgf90e6cc" class="outline-3">
<h3 id="orgf90e6cc">不变量 RI</h3>
<div class="outline-text-3" id="text-orgf90e6cc">
<p>
有效意味着这个具体值不能违反不变量.
例如, Set中, 若不变量为list中不能有重复元素, 那么 [1;2;2] 就不是一个有效的具体值.
</p>

<p>
不变量在文档中也要写在最前面,
</p>

<p>
不变量的实现是蕴含在各种操作的实现中的.
不变量的维持在操作的实现过程中是可以暂时被违反的, 但在操作的输入输出两端, 不变量是必须成立的. (例如, 平衡二叉树, 先插入到合适的位置, 再去维持平衡) 
</p>
</div>
<div id="outline-container-orgbc84b35" class="outline-4">
<h4 id="orgbc84b35">实现</h4>
<div class="outline-text-4" id="text-orgbc84b35">
<p>
可以实现一个函数在每个操作的输入和输出位置对不变量进行检查.
(防御性编程) 
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">rep_ok</span><span style="color: #DFDFDF;"> </span><span style="color: #f0e68c;">(</span><span style="color: #DFDFDF;">x </span><span style="color: #f0e68c;">:</span><span style="color: #FCCE7B;"> t</span><span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">t</span> <span style="color: #f0e68c;">=</span>
<span style="color: #51afef;">if</span> <span style="color: #7e7e87;">(** check invariants *)</span> <span style="color: #51afef;">then</span> x
<span style="color: #51afef;">else</span> <span style="color: #C57BDB;">failwith</span> <span style="color: #7bc275;">"invariants"</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>




<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">removedups</span><span style="color: #DFDFDF;"> lst</span> <span style="color: #f0e68c;">=</span>
   lst <span style="color: #f0e68c;">|&gt;</span> <span style="color: #FCCE7B;">List.</span>sort_uniq <span style="color: #FCCE7B;">Stdlib.</span>compare

<span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">rep_ok</span><span style="color: #DFDFDF;"> s</span> <span style="color: #f0e68c;">=</span>
  <span style="color: #51afef;">if</span> <span style="color: #FCCE7B;">List.</span>length <span style="color: #f0e68c;">(</span>removedups s<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>length s <span style="color: #51afef;">then</span> s
  <span style="color: #51afef;">else</span> <span style="color: #C57BDB;">failwith</span> <span style="color: #7bc275;">"the set exists dups"</span>
<span style="color: #ff4500;">;;</span>
</pre>
</div>
<p>
在这里, 对不变量的检查的开销是十分巨大的. 会导致操作的效率低下. 
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListSetImpl</span> <span style="color: #f0e68c;">=</span> <span style="color: #f5deb3; font-weight: bold;">struct</span>
  <span style="color: #7e7e87;">(** the list cannot contain duplicates*)</span>
  <span style="color: #f5deb3; font-weight: bold;">type</span> <span style="color: #FCCE7B;">'a t</span> <span style="color: #f0e68c;">=</span> 'a list

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #DFDFDF;">empty</span> <span style="color: #f0e68c;">=</span> rep_ok <span style="color: #f0e68c;">[]</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">add</span><span style="color: #DFDFDF;"> e s</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">match</span> <span style="color: #f0e68c;">(</span> rep_ok s <span style="color: #f0e68c;">)</span> <span style="color: #51afef;">with</span> 
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">[</span>e<span style="color: #f0e68c;">]</span>
    <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #51afef;">if</span> h <span style="color: #f0e68c;">=</span> e <span style="color: #51afef;">then</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #51afef;">else</span>  rep_ok  <span style="color: #f0e68c;">(</span>h<span style="color: #f0e68c;">::(</span>add e t<span style="color: #f0e68c;">))</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">size</span><span style="color: #DFDFDF;"> s</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">List.</span>length <span style="color: #f0e68c;">(</span>rep_ok s<span style="color: #f0e68c;">)</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #f5deb3; font-weight: bold;">rec</span> <span style="color: #5cEfFF;">mem</span><span style="color: #DFDFDF;"> e s</span> <span style="color: #f0e68c;">=</span> <span style="color: #51afef;">match</span> <span style="color: #f0e68c;">(</span>rep_ok s<span style="color: #f0e68c;">)</span> <span style="color: #51afef;">with</span> 
    <span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">[]</span> <span style="color: #f0e68c;">-&gt;</span> <span style="color: #a991f1;">false</span>
    <span style="color: #f0e68c;">|</span> h<span style="color: #f0e68c;">::</span>t <span style="color: #f0e68c;">-&gt;</span> <span style="color: #f0e68c;">(</span>h <span style="color: #f0e68c;">=</span> e<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">||</span> <span style="color: #f0e68c;">(</span>mem e t<span style="color: #f0e68c;">)</span>

  <span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">union</span><span style="color: #DFDFDF;"> s1 s2</span> <span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">(</span>rep_ok s1<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">@</span> <span style="color: #f0e68c;">(</span>rep_ok s2<span style="color: #f0e68c;">)</span> <span style="color: #f0e68c;">|&gt;</span> <span style="color: #FCCE7B;">List.</span>sort_uniq <span style="color: #FCCE7B;">Stdlib.</span>compare <span style="color: #f0e68c;">|&gt;</span> rep_ok


<span style="color: #f5deb3; font-weight: bold;">end</span>

<span style="color: #f5deb3; font-weight: bold;">module</span> <span style="color: #FCCE7B;">ListSet</span> <span style="color: #f0e68c;">:</span> <span style="color: #FCCE7B;">Set</span> <span style="color: #f0e68c;">=</span> <span style="color: #FCCE7B;">ListSetImpl</span> <span style="color: #ff4500;">;;</span> 
</pre>
</div>

<p>
应对这种开销问题的方法就是将 <code>rep_ok</code> 在不需要debug时替换为 恒等函数
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #f5deb3; font-weight: bold;">let</span> <span style="color: #5cEfFF;">rep_ok</span><span style="color: #DFDFDF;"> s</span> <span style="color: #f0e68c;">=</span> s

 <span style="color: #62686E;">(* </span><span style="color: #62686E;">if List.length (removedups s) = List.length s then s</span>
<span style="color: #62686E;">    else failwith "the set exists dups"</span><span style="color: #62686E;"> *)</span>
</pre>
</div>




<p>
交换图: 
</p>
<div class="org-src-container">
<pre class="src src-bash">    &#25277;&#35937;&#30340;&#25805;&#20316;
    * ----&gt; *
    ^       ^
AF  |       | AF
    |       |
    * ----&gt; *
    &#23454;&#29616;&#30340;&#25805;&#20316;
</pre>
</div>

<p>
eg: 实现中允许重复set的交换图
</p>
<div class="org-src-container">
<pre class="src src-bash">       &#25277;&#35937;&#25805;&#20316; union {2,3}

 {1,2} ----------------&gt; {1,2,3} 
   ^                        ^
AF |                        | AF
   |                        |
 [1;2] ----------------&gt; [1;2;2;3]

   &#20855;&#20307;&#23454;&#29616;&#30340;&#25805;&#20316; List.append [2;3] 
</pre>
</div>

<p>
从逻辑上讲, 要得到集合{1,2,3}有两条路径.
</p>

<p>
一个操作的实现是正确的, 若其对应的 AF 图是可交换的.
</p>

<p>
op<sub>abs</sub>(AF(c)) = AF(op<sub>conc</sub>(c)) 
</p>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
