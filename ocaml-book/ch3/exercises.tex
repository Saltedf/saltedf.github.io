% Created 2022-05-16 一 11:54
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.1 (Org mode 9.5.2)}, 
 pdflang={English}}
\begin{document}

\tableofcontents

\section{ch3}
\label{sec:orgcf5ccda}

\subsection{list expressions}
\label{sec:org8d5e3d7}

\subsubsection{使用方括号来创建一个含有整数 1\textasciitilde{}5 的list}
\label{sec:orge39f541}
\begin{verbatim}
[1;2;3;4;5] ;;
\end{verbatim}

\subsubsection{只用 \texttt{::} 和 \texttt{[]} 创建相同的list}
\label{sec:orgf84ca58}
\begin{verbatim}
1::2::3::4::5::[] ;;
\end{verbatim}

\subsubsection{用 \texttt{@} 但不能用 \texttt{::} ，并用上 \texttt{[2;3;4]} 这个表达式来创建相同的list}
\label{sec:orgd76791d}
\begin{verbatim}
[1] @ [2;3;4] @ [5] ;;
\end{verbatim}

\subsection{list的整数乘积}
\label{sec:org33b0a55}
\begin{verbatim}
let product lst =
  let rec product_tr acc = function 
    | [] -> acc 
    | h::t when h!=0 -> product_tr (h*acc) t
    | _ -> 0 
  in
  product_tr 1 lst
;;
\end{verbatim}

\subsection{连接list中的所有字符串}
\label{sec:orgb6874fb}

\begin{verbatim}
let concat lst =
  let rec concat_tr acc = function
    |[] -> acc
    |h::t -> concat_tr (acc ^ h) t 
  in 
  concat_tr "" lst
;;
\end{verbatim}

\subsection{为product编写单元测试}
\label{sec:org4300685}
\begin{verbatim}
open OUnit2
open Product

let test_product = "test_product" >::: [
    "empty list" >:: (fun _ -> assert_equal 1 (product []) ) ;
    "one element" >:: (fun _ -> assert_equal 4 (product [4]) );
    "two elelemts" >:: (fun _ -> assert_equal 30 (product [5;6]) ) ;
    "contains zero" >:: (fun _ -> assert_equal 0 (product [0;34;54;12;1;3;5;6;] )  );
  ]


let _ = run_test_tt_main test_product
\end{verbatim}




\subsection{用模式匹配写下面三个函数}
\label{sec:org368f9d0}

只要输入list满足性质就返回true,否则返回false

\subsubsection{list的首个元素是 “bigred”}
\label{sec:orga1631b4}
\begin{verbatim}
let func1 = function
  | h::_  when h = "bigred" -> true
  | _ ->false
;;
\end{verbatim}

\subsubsection{list恰好有两个/四个元素（不能用length函数）}
\label{sec:orgdf25dfa}
\begin{verbatim}
let func2 = function
  | [_;_] ->  true
  | [ _;_;_;_] ->true
  | _ -> false
;;
\end{verbatim}

\subsubsection{list的前两个元素是相等的}
\label{sec:orgafdebd4}
\begin{verbatim}
let func3 = function
  | a::b::_ when a=b -> true
  | _ -> false
;;
\end{verbatim}


\subsection{用 \texttt{List} 标准库来解决问题：}
\label{sec:org8cbe645}

\subsubsection{编写一个接受 \texttt{int list} 的函数，它返回list的第五个元素}
\label{sec:orgae4c424}
若list少于5个元素，则返回0 。
提示：用 \texttt{List.length} 和 \texttt{List.nth}

\begin{verbatim}
let fifth  lst =
  if (List.length lst) < 5 then 0
  else List.nth lst 4
;;
\end{verbatim}

\subsubsection{编写一个接收 \texttt{int list} 的函数，它返回一个降序排列的list}
\label{sec:org16590f7}
提示：用 \texttt{List.sort} ，并用 \texttt{Stdlib.compare}  作为它的首个参数。以及使用 \texttt{List.rev} (反转list）

\begin{verbatim}
let descend lst =
  lst |>  (List.sort Stdlib.compare)  |> List.rev
;;
\end{verbatim}



\subsection{分别为上面两个函数编写单元测试}
\label{sec:org0250cab}
\begin{verbatim}
open Fifth
open OUnit2

let make_fifth_testcase name expect lst =
  name >:: (fun _ -> assert_equal  expect (fifth lst) )
;;

let fifth_test = "test suite of fifth" >::: [
    make_fifth_testcase "empty list" 0 [] ;
    make_fifth_testcase "lewer than five elements" 0 [1;3;4;5] ;
    make_fifth_testcase "exactly five elements" 5 [1;2;3;4;5] ;
    make_fifth_testcase "more then five elements" 5 [1;2;3;4;5;6] 
  ]

let _  = run_test_tt_main fifth_test 
\end{verbatim}


\begin{verbatim}
open OUnit2
open Descend

let make_descend_testcase name expect lst =
  name >:: (fun _ -> assert_equal expect (descend lst) ) 
;;

let descend_test_suite = "test descend" >::: [
    make_descend_testcase "empty list" [] [] ;
    make_descend_testcase "one element" [3] [3] ;
    make_descend_testcase "ascending list" [3;2;1] [1;2;3] 

  ]

let _ = run_test_tt_main descend_test_suite
\end{verbatim}




\subsection{libray puzzle}
\label{sec:orgbbfc069}
解答只能是1-2行代码 

\subsubsection{编写一个返回list的最后一个元素的函数}
\label{sec:orgc18fed6}
函数应假定输入的list是非空的；提示用两个库函数，不要在代码中使用模式匹配

\begin{verbatim}
let last_element lst =
  assert (lst != []) ; (List.nth lst  ((List.length lst) -1) )
;;
\end{verbatim}

\subsubsection{编写函数 any\textsubscript{zeroes} : int list -> bool}
\label{sec:org45df730}
此函数返回 true 当且仅当 输入list中至少有一个 0
提示：使用一个库函数，不要用模式匹配。

\begin{verbatim}
let any_zeroes lst =
  List.mem 0 lst
;;
\end{verbatim}

\subsection{take/drop}
\label{sec:org0f5641b}


\subsubsection{编写函数 \texttt{take:int-> 'a list->'a list}}
\label{sec:orgb5960e7}

使得 \texttt{take n lst} 返回lst的前n个元素。若lst少于n个元素，则返回整个list
\begin{verbatim}
let take n lst =
  if (List.length lst) <= n then lst
  else
    let rec take_tr acc m l = match (m,l) with 
      | (0, _ )  -> List.rev acc 
      | ( _, h::t)  ->take_tr (h::acc)  (m-1) t
      | _ -> failwith "fail" 
    in
    take_tr [] n lst
;;
\end{verbatim}

\subsubsection{编写drop函数 \texttt{int -> 'a list -> 'a list}}
\label{sec:org07c38f0}
满足 \texttt{drop n lit} 返回除了前n个之外的lst中剩下的元素。若lst少于n个元素，则返回空list

\begin{verbatim}
let drop n lst =
  if (List.length lst) <= n then []
  else
    let rec drop_tr m l = match (m,l) with
      | (0,l) -> l
      | (i,h::t) -> drop_tr (m-1) t
      | _ -> failwith "something wrong"
    in
    drop_tr n lst
;;

\end{verbatim}

\subsection{将take/drop改写成尾递归的写法}
\label{sec:org4aadd2f}
并构造长list来测试这对两个函数的调用是否会导致栈溢出。

\begin{verbatim}
let ( -- ) s e = 
  let rec from acc i j =
    if i > j then acc
    else  from  (j::acc) i (j-1)
  in
  from [] s e
;;
\end{verbatim}

\begin{verbatim}
let longlist = 1 -- 1000000 ;; 
\end{verbatim}


\subsection{unimodal}
\label{sec:org63968de}
编写函数 \texttt{is\_unimodal : int list -> bool} ,它接收一个整数list，并返回此列表是否为unimodal。
一个unimodal list是一个list满足：存在一个元素，在之前的元素构成单调递增序列，在它之后的元素构成数组是单调递减的。
增长部分/减少部分都有可能是空的。由相同元素构成的list也是unimodal，空list也是

\begin{verbatim}

let  is_unimodal  lst =
  let rec impl  is_ascend_seg  l =
      match l with
      |[] -> true
      |[_] -> true
      |h::m::t when h=m  -> impl is_ascend_seg (m::t)  
      |h::m::t when h<m  -> if is_ascend_seg then impl true (m::t) else false
      |h::m::t (*when h>m *)-> impl false (m::t)
  in
  impl true lst
;;
\end{verbatim}
\end{document}